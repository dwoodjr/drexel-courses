<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[drexel-teaching]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>drexel-teaching</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Wed, 02 Jul 2025 18:33:36 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Wed, 02 Jul 2025 18:33:32 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Module 1B: Procedural Thinking Basics]]></title><description><![CDATA[ 
 <br><br>Module Overview 
Learning Focus: Understanding procedural workflows and algorithmic content creation <br>
Builds On: Module 1A (Technical Art fundamentals)
<br><br><br>Procedural thinking involves using algorithms and rules to automate content creation. Instead of manually creating each element, you define a set of instructions that generate content automatically. This approach transforms repetitive manual work into systematic, scalable processes.<br><br>Traditional approach: "I need to model 50 unique trees"<br>
Procedural approach: "I need to create rules that generate 50 unique trees automatically"<br>Key principle: Write the rules once, generate infinite variations. (obviously developing rules takes time, but I hope you get the idea)<br><br><br><br>
<br>Landscape Creation: Algorithmic height maps and erosion simulation
<br>Vegetation Placement: Rules-based distribution of plants and trees
<br>Biome Systems: Automatic climate-based environment generation
<br><br>
<br>Modular Characters: Mix-and-match clothing, accessories, and features
<br>Procedural Animation: Rule-based movement and behavior systems
<br>Dynamic Scaling: Automatic adaptation for different character sizes
<br><br>
<br>Building Generation: Modular construction systems with infinite variations
<br>Dungeon Creation: Algorithmic layout with gameplay flow considerations
<br>Urban Planning: Procedural cities with realistic street layouts and zoning
<br><br><br><br>
<br>Reduces time spent on repetitive tasks
<br>Accelerates iteration through parameter adjustment
<br>Eliminates manual errors in repetitive processes
<br><br>
<br>Enables creation of vast, dynamic worlds
<br>Supports rapid prototyping of multiple design directions
<br>Facilitates easy updates across entire asset libraries
<br><br>
<br>Generates unexpected results that inspire new directions
<br>Provides systematic exploration of design spaces
<br>Maintains consistency while enabling variation
<br><br>GDC Talk = Long Video
This is a lengthy video, please do not attempt to watch the full video during class!<br>
I recommend watching from the beginning to about 6:10 (Usual Evolution+)<br>
Feel free to watch the full outside of class if it particularly interesting to you.
<br><br><br><br>
<br>Creating many similar but varied elements
<br>Needing to iterate quickly on design parameters
<br>Working with systematic, rule-based patterns
<br>Building scalable content pipelines
<br><br>
<br>Creating hero assets requiring precise artistic control
<br>Working with unique, one-off designs
<br>Dealing with highly irregular or organic forms
<br>Fine-tuning specific aesthetic details
<br><br>Combine procedural generation with manual refinement:<br>
<br>Generate base content procedurally
<br>Manually adjust and refine key elements
<br>Use procedural methods for variations and iterations
<br><br><br><br>
<br>Random Placement: Distributing objects with controlled variation
<br>Density Control: Using maps and rules to control placement frequency
<br>Collision Avoidance: Ensuring scattered objects don't intersect inappropriately
<br><br>
<br>Geometric Patterns: Mathematical relationships creating regular designs
<br>Noise-Based Variation: Using algorithmic noise for organic randomness
<br>Rule-Based Systems: Logic that determines pattern behavior
<br><br>
<br>Randomization: Controlled variation within specified ranges
<br>Mathematical Relationships: Linking parameters through equations
<br>Conditional Logic: Rules that trigger based on specific conditions
<br><br>
<br>Component Systems: Combining pre-made pieces in systematic ways
<br>Constraint-Based Placement: Rules governing how pieces connect
<br>Variation Generation: Creating diversity from limited base components
<br><br><br><br>Manual Approach:<br>
<br>Model individual trees
<br>Place each tree by hand
<br>Adjust size and rotation manually
<br>Repeat for hundreds of trees
<br>Procedural Approach:<br>
<br>Create base tree models (3-5+ variations)
<br>Define placement rules (density, slope tolerance, clustering)
<br>Set variation parameters (scale, rotation, species distribution)
<br>Generate forest automatically with controllable parameters<br>
Result: Same visual quality, fraction of the time, infinite variation potential
<br><br><br>Pattern Recognition Exercise (3-4 minutes) Identify Procedural Elements: Think of games you've played recently and identify 3 examples where procedural generation might have been used. Consider:
Examples to look for:

<br>Repeating but varied elements (buildings, trees, rocks)
<br>Large-scale environments with systematic patterns
<br>Character customization systems
<br>Weapon or item generation systems

Analysis Questions:

<br>What made you think this element was procedural?
<br>What rules or patterns do you notice?
<br>How does the system create variety while maintaining consistency?

<br>Write down your examples - you'll share these during class discussion next week.<br><br><br>PCG encompasses different types of automated content creation:<br><br>
<br>Assets: Textures, sounds, models
<br>Components: Individual game elements
<br><br>
<br>Levels: Playable areas and environments
<br>Terrains: Landscapes and geographical features
<br>Maps: Layout and spatial organization
<br><br>
<br>Rules: Mechanical relationships and interactions
<br>Mechanics: Gameplay systems and features
<br><br>
<br>Events: Dynamic occurrences and triggers
<br>Narratives: Story elements and branching paths
<br>Quests: Mission and objective generation
<br><br><br><br>
<br>Infinite Universe: Procedurally generated planets, flora, and fauna
<br>Systematic Variety: Consistent rules creating believable diversity
<br>Player Discovery: Each player experiences unique content
<br><br>
<br>Terrain Generation: Algorithmic landscapes with biome systems
<br>Structure Placement: Villages, dungeons, and landmarks
<br>Resource Distribution: Ore placement following geological rules
<br><br>
<br>Weapon Generation: Millions of unique weapons from modular components
<br>Stat Calculation: Mathematical systems determining weapon properties
<br>Visual Variety: Procedural combinations of parts and materials
<br><br><br>Explore Further

<br><a data-tooltip-position="top" aria-label="https://www.autodesk.com/solutions/proceduralism" rel="noopener nofollow" class="external-link" href="https://www.autodesk.com/solutions/proceduralism" target="_blank">Procedural Workflows Explained - Autodesk</a>
<br><a data-tooltip-position="top" aria-label="https://www.pcgbook.com/" rel="noopener nofollow" class="external-link" href="https://www.pcgbook.com/" target="_blank">Procedural Content Generation in Games - Free Online Book</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=erI7k3lt4UY" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=erI7k3lt4UY" target="_blank">The Art of Procedural Noise(Video)</a>

<br><br>
<br>L-Systems: Rule-based systems for generating fractal-like structures
<br>Voronoi Patterns: Mathematical techniques for organic-looking distributions
<br>Flow Fields: Directing procedural systems with vector fields
<br><br><br>Coming up: We'll explore how visual scripting systems make procedural thinking accessible and powerful for artists.<br>Progress Tracking

<br>Module 1A: What is Technical Art? ‚úì
<br>Module 1B: Procedural Thinking Basics ‚úì
<br>Module 1C: Node-Based Workflows Introduction

<br><br><br>Module Navigation 
Previous: <a data-tooltip-position="top" aria-label="GMAP 395 - Introduction - A" data-href="GMAP 395 - Introduction - A" href="gmap-395\introduction\gmap-395-introduction-a.html" class="internal-link" target="_self" rel="noopener nofollow">Module IA</a><br>
Next: <a data-tooltip-position="top" aria-label="GMAP 395 - Introduction - C" data-href="GMAP 395 - Introduction - C" href="gmap-395\introduction\gmap-395-introduction-c.html" class="internal-link" target="_self" rel="noopener nofollow">Module IC</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Introduction and Overview" data-href="GMAP 395 - Introduction and Overview" href="gmap-395\introduction\gmap-395-introduction-and-overview.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\introduction\gamp-395-introduction-b.html</link><guid isPermaLink="false">GMAP 395/Introduction/GAMP 395 - Introduction - B.md</guid><pubDate>Wed, 02 Jul 2025 18:32:50 GMT</pubDate></item><item><title><![CDATA[Module 1A: What is Technical Art?]]></title><description><![CDATA[ 
 <br><br>Module Overview 
Learning Focus: Understanding the role and importance of technical art in game development<br>
Preparation for: Week 2 and course foundation
<br><br><br>Technical art is the bridge between art and technology in game development. Technical artists combine creative and technical skills to enhance workflows and visual quality, ensuring the seamless integration of assets into game engines while solving cross-disciplinary challenges between artists and programmers.<br><br>Technical artists serve as problem solvers and workflow optimizers in the game development pipeline:<br>
<br>Asset Integration Specialists: Ensure artwork functions properly within game engines
<br>Pipeline Architects: Design and maintain efficient content creation workflows
<br>Cross-Disciplinary Communicators: Translate between artistic vision and technical constraints
<br>Automation Engineers: Create tools and scripts that streamline repetitive tasks
<br>Quality Assurance: Maintain visual and performance standards across projects
<br><br><br>Essential Skill Areas

<br>Attention to Detail: Precision in both creative and technical execution
<br>Communication and Collaboration: Ability to work with diverse teams and explain complex concepts
<br>Strong Art and Technical Knowledge: Understanding both aesthetic principles and technical implementation
<br>Technical Proficiency: Coding, scripting, and tool development capabilities
<br>Creative Problem-Solving: Innovative approaches to workflow and visual challenges

<br><br>Technical artists think in systems and workflows rather than individual assets. They ask questions like:<br>
<br>"How can we automate this process?"
<br>"What if we need to make 100 variations of this asset?"
<br>"How do we maintain quality while meeting performance requirements?"
<br>"What tools can we build to help the team work more efficiently?"
<br><br><br><br><br>In Character Creation:<br>
<br>Automated rigging systems for faster character setup
<br>Procedural clothing and accessory systems
<br>Dynamic hair and fur solutions
<br>In Environment Art:<br>
<br>Modular building systems with automatic UV mapping
<br>Procedural terrain and foliage placement
<br>Automated LOD (Level of Detail) generation
<br>In VFX and Animation:<br>
<br>Real-time particle systems optimized for performance
<br>Dynamic lighting solutions that respond to gameplay
<br>Automated texture streaming and compression
<br><br><br>In GMAP 395, you'll develop technical art skills through:<br>Procedural Workflows: Learning to create systems that generate content automatically<br>
Pipeline Integration: Understanding how different tools work together efficiently<br>
Performance Optimization: Balancing visual quality with real-time rendering requirements <br><br>Technical art skills are increasingly valuable because:<br>
<br>Industry Demand: Studios need artists who understand technical constraints
<br>Workflow Efficiency: Companies value employees who can optimize processes
<br>Creative Problem-Solving: Technical artists often find innovative solutions to complex challenges
<br>Cross-Disciplinary Value: These skills transfer across many creative technology fields
<br><br><br>Quick Reflection (2-3 minutes) Before moving to the next module, consider these questions:
Current Skills Inventory:

<br>Which technical art skills do I already have? (Consider: scripting, 3D software, problem-solving, automation)
<br>What technical challenges have I encountered in previous art projects?
<br>How comfortable am I with learning new software and technical workflows?

Course Connection:

<br>What aspects of technical art am I most excited to learn?
<br>How might these skills benefit my current or future projects?

<br>Write down 2-3 specific technical art skills you want to develop this quarter. You'll reference these later when deciding on your project ideas and during our first critique session.<br><br><br>Dive Deeper

<br><a data-tooltip-position="top" aria-label="https://www.riotgames.com/en/artedu/technical-art" rel="noopener nofollow" class="external-link" href="https://www.riotgames.com/en/artedu/technical-art" target="_blank">What is Technical Art? - Riot Games</a>
<br><a data-tooltip-position="top" aria-label="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" rel="noopener nofollow" class="external-link" href="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" target="_blank">Technical Artist Career Profile - ScreenSkills</a>
<br><a data-tooltip-position="top" aria-label="https://www.tech-artists.org/t/about-the-professional-category/9845" rel="noopener nofollow" class="external-link" href="https://www.tech-artists.org/t/about-the-professional-category/9845" target="_blank">Tech-Artists Community Site</a>
<br><a data-tooltip-position="top" aria-label="https://www.cgspectrum.com/career-pathways/technical-artist" rel="noopener nofollow" class="external-link" href="https://www.cgspectrum.com/career-pathways/technical-artist" target="_blank">Technical Artist Career Pathways - CG Spectrum</a>

<br><br>Technical art is one of the fastest-growing specializations in game development. As projects become more complex and development timelines shorter, the need for artists who can create efficient, scalable workflows becomes critical.<br><br><br>Coming up: We'll explore how algorithmic thinking and rule-based systems can automate content creation and enhance creative workflows.<br>Progress Tracking

<br>Module 1A: What is Technical Art? ‚úì
<br>Module 1B: Procedural Thinking Basics
<br>Module 1C: Node-Based Workflows Introduction

<br><br><br>Module Navigation 
Next: <a data-tooltip-position="top" aria-label="GAMP 395 - Introduction - B" data-href="GAMP 395 - Introduction - B" href="gmap-395\introduction\gamp-395-introduction-b.html" class="internal-link" target="_self" rel="noopener nofollow">Module IB</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Introduction and Overview" data-href="GMAP 395 - Introduction and Overview" href="gmap-395\introduction\gmap-395-introduction-and-overview.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\introduction\gmap-395-introduction-a.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - Introduction - A.md</guid><pubDate>Wed, 02 Jul 2025 18:32:45 GMT</pubDate></item><item><title><![CDATA[Module 1C: Node-Based Workflows Introduction]]></title><description><![CDATA[ 
 <br><br>Module Overview 
Learning Focus: Understanding visual scripting and data flow concepts<br>
Builds On: Modules 1A &amp; 1B (Technical Art and Procedural Thinking)
<br><br><br>Node-based workflows use visual scripting and data-driven approaches to create procedural systems and assets. Instead of writing traditional code, you connect visual nodes that represent specific operations, creating a flowchart-like system that's both powerful and accessible to artists.<br><br>Nodes represent specific tasks or operations:<br>
<br>Input Nodes: Provide data to the system (geometry, textures, parameters)
<br>Processing Nodes: Modify or transform data (scale, rotate, duplicate, filter)
<br>Output Nodes: Generate final results (meshes, materials, effects)
<br>Connections define data flow:<br>
<br>Data flows from left to right or top to bottom (typically)
<br>Each connection carries specific types of information
<br>Visual feedback shows how changes propagate through the system
<br><br><br><br>A Directed Acyclic Graph is a structure where:<br>
<br>Directed: Connections flow in one direction (like water flowing downstream)
<br>Acyclic: No loops or circular references that would create infinite processing (typically)
<br>Graph: Network of connected nodes representing relationships
<br><br>Non-linear workflows enable:<br>
<br>Iterative development: Change parameters anywhere in the chain
<br>Modular construction: Swap out pieces without rebuilding everything
<br>Dependency management: Clear understanding of how changes affect final output
<br>Applications in Game Development:<br>
<br>Organizing and optimizing procedural pipelines
<br>Managing dependencies between assets and systems
<br>Building complex modeling, texturing, or animation workflows
<br>Creating real-time gameplay systems
<br>DAG Resources

<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Directed_acyclic_graph" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank">Directed Acyclic Graph - Wikipedia</a>
<br><a data-tooltip-position="top" aria-label="https://www.getdbt.com/blog/guide-to-dags" rel="noopener nofollow" class="external-link" href="https://www.getdbt.com/blog/guide-to-dags" target="_blank">Guide to DAGs - dbt</a>

<br><br><br><br>
<br>Procedural modeling and geometric operations
<br>Real-time parameter adjustment with immediate visual feedback
<br>Modular node groups for reusable operations
<br><br>
<br>Industry-standard procedural modeling and VFX creation
<br>Complex simulations (fluids, destruction, crowds)
<br>Extensive node library for specialized operations
<br><br>
<br>Visual shader creation without traditional coding
<br>Real-time preview of material changes
<br>Cross-platform compatibility with automatic code generation
<br><br>
<br>Visual scripting for gameplay logic and interactive systems
<br>Artist-friendly programming for complex game mechanics
<br>Integration with rendering and animation systems
<br><br><br><br><br><br>
<br>Visual representation makes logic easier to understand
<br>No syntax requirements - drag, drop, and connect
<br>Immediate feedback through real-time previews
<br>Error prevention through type-safe connections
<br><br>
<br>Isolate operations in individual nodes for easy debugging
<br>Reusable components can be saved and shared
<br>Clear data flow shows exactly how information moves through the system
<br>Non-destructive editing preserves original data
<br><br>
<br>Parameter tweaking without rebuilding entire systems
<br>A/B testing through parallel node chains
<br>Version control through node group management
<br>Documentation through visual system layout
<br><br><br><br>
<br>Terrain creation with height maps and erosion simulation
<br>Building generation using modular architectural components
<br>Vegetation systems with realistic distribution patterns
<br><br>
<br>Complex surface properties combining multiple texture layers
<br>Animated materials with time-based parameter changes
<br>Conditional rendering based on distance or performance requirements
<br><br>
<br>Interactive mechanics without traditional programming
<br>AI behavior trees using visual logic systems
<br>UI systems with dynamic layout and content
<br><br><br><br>
<br>Geometry: 3D mesh data, points, edges, faces
<br>Attributes: Properties attached to geometry (color, scale, rotation)
<br>Numbers: Float values, integers, vectors
<br>Boolean: True/false logic for conditional operations
<br><br><br>
<br>Primitive Objects: Basic shapes (cube, sphere, plane)
<br>Import Nodes: External data (models, images, point clouds)
<br>Parameter Controls: User-adjustable values and settings
<br><br>
<br>Transform Operations: Move, rotate, scale geometry
<br>Duplication Systems: Arrays, scattering, instancing
<br>Deformation Tools: Bend, twist, noise displacement
<br>Boolean Operations: Combine, subtract, intersect geometry
<br><br>
<br>Math Operations: Add, multiply, compare values
<br>Conditional Logic: If/then statements for branching behavior
<br>Random Generators: Controlled variation and noise
<br>Attribute Manipulation: Reading and writing object properties
<br><br><br>Visual Thinking Exercise (3-4 minutes) Sketch a Simple Node Network: Think of any simple creative process and draw it as connected boxes with arrows. Examples could be:

<br>Making breakfast (ingredients ‚Üí cooking steps ‚Üí final dish)
<br>Getting dressed (choosing clothes ‚Üí putting them on ‚Üí final outfit)
<br>Creating a simple drawing (basic shapes ‚Üí details ‚Üí colors ‚Üí finished art)
<br>Or any process you can think of!

Drawing Guidelines:

<br>Use simple boxes for each step
<br>Label each box with what happens
<br>Use arrows to show the order/flow
<br>Think about: What do I start with? What steps transform it? What's the result?

<br>The goal: Practice thinking in "data flow" - how information or materials move from step to step to create something new.<br><br><br><br>
<br>Begin with basic operations and verify each step
<br>Add complexity gradually rather than building everything at once
<br>Test frequently to catch issues early in the process
<br><br>
<br>What information do I start with? (input data)
<br>What transformations do I need? (processing steps)
<br>What's my desired end result? (output goals)
<br><br>
<br>Group related operations into reusable components
<br>Create parameter interfaces for easy adjustment
<br>Build libraries of useful node groups for future projects
<br><br>
<br>Expose key parameters at the top level for easy access
<br>Use preview modes to work with simplified data during development
<br>Document your networks with clear naming and organization
<br><br><br><br>Procedural destruction sequences:<br>
<br>Input: Building geometry
<br>Processing: Fracture patterns, physics simulation, debris generation
<br>Output: Realistic destruction animation with thousands of pieces
<br><br>Dynamic weather materials:<br>
<br>Input: Base terrain textures, weather parameters
<br>Processing: Blend wet/dry states, add puddle formation, adjust surface properties
<br>Output: Real-time material that responds to game weather systems
<br><br>Modular environment pieces:<br>
<br>Input: Basic architectural forms
<br>Processing: Add surface details, wear patterns, modular connection points
<br>Output: Library of compatible building pieces for level design
<br><br><br>Explore Node-Based Systems

<br><a data-tooltip-position="top" aria-label="https://www.sidefx.com/tutorials/intro-to-houdinis-node-based-workflow/" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/tutorials/intro-to-houdinis-node-based-workflow/" target="_blank">Introduction to Node-Based Workflows in Houdini</a>
<br><a data-tooltip-position="top" aria-label="https://www.sidefx.com/docs/houdini/nodes/index.html" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/docs/houdini/nodes/index.html" target="_blank">Houdini Node Documentation</a>
<br><a data-tooltip-position="top" aria-label="https://spin.atomicobject.com/blender-node-based-workflows/" rel="noopener nofollow" class="external-link" href="https://spin.atomicobject.com/blender-node-based-workflows/" target="_blank">Blender Node-Based Workflows</a>

<br><br><br>You now have the foundational knowledge to understand:<br>
<br>The role of technical art in bridging creativity and technology
<br>Procedural thinking as a systematic approach to content creation
<br>Node-based workflows as visual tools for implementing procedural systems
<br>Pre-Class Preparation Complete

<br>Module 1A: What is Technical Art? ‚úì
<br>Module 1B: Procedural Thinking Basics ‚úì
<br>Module 1C: Node-Based Workflows Introduction ‚úì

<br><br><br>
<br>DAG: Directed Acyclic Graph - visual representation of data flow without loops
<br>Node: Individual operation or process in a visual system
<br>Data Flow: Movement of information from input through processing to output
<br>Procedural: Content created through rules and algorithms rather than manual construction
<br>Modular: Components designed to work together in flexible combinations
<br>Pipeline: Series of connected processes that transform data from start to finish
<br>Next up: Module 1 (Weeks 2-3) where you will apply these concepts hands-on with Blender Geometry Nodes and Unity integration!<br><br><br>Module Navigation 
Previous: <a data-tooltip-position="top" aria-label="GAMP 395 - Introduction - B" data-href="GAMP 395 - Introduction - B" href="gmap-395\introduction\gamp-395-introduction-b.html" class="internal-link" target="_self" rel="noopener nofollow">Module IB</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Introduction and Overview" data-href="GMAP 395 - Introduction and Overview" href="gmap-395\introduction\gmap-395-introduction-and-overview.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\introduction\gmap-395-introduction-c.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - Introduction - C.md</guid><pubDate>Wed, 02 Jul 2025 18:32:56 GMT</pubDate></item><item><title><![CDATA[Module 1A: Game Feel and Tactile Experience]]></title><description><![CDATA[ 
 <br><br>Module Overview 
 Learning Focus: Understanding game feel and its impact on player experience<br>
Builds On: Course introduction and design fundamentals: <a data-href="GMAP 395 - Introduction and Overview" href="gmap-395\introduction\gmap-395-introduction-and-overview.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Introduction and Overview</a>
<br><br><br>Game Feel is the visceral and tactile experience of interacting with a game that makes it feel responsive and "tangible" to the player.<br>üí≠ Steve Swink's Definition "Real-time control of virtual objects in a simulated space, with interaction emphasized by polish."
‚Äî Steve Swink, Game Feel: A Game Designer's Guide to Virtual Sensation
<br><br>Game Feel consists of three essential elements:<br>
<br>‚ö° Real-Time Control

<br>Immediate response to player input
<br>Minimal input lag for responsive interaction
<br>Frame-perfect timing for competitive games


<br>üåç Simulated Space

<br>Believable virtual environments
<br>Realistic or stylized physics systems
<br>Consistent world rules and behaviors


<br>‚ú® Polish

<br>Visual feedback (particles, animations, screen shake)
<br>Audio feedback (sound effects, music cues)
<br>Haptic feedback (controller vibration)


<br><br><br><br><br><br>üçÑ Super Mario Bros.

<br>Precision: Tight, predictable platforming controls
<br>Momentum: Satisfying acceleration and deceleration
<br>Feedback: Clear audio/visual cues for all actions

<br>üèîÔ∏è Celeste

<br>Forgiveness: "Coyote time" and input buffering
<br>Challenge: Demanding yet fair difficulty
<br>Polish: Exceptional particle effects and screen shake

<br>üëπ DOOM (2016)

<br>Weight: Impactful, heavy combat feel
<br>Speed: Fast-paced, fluid movement
<br>Violence: Satisfying weapon feedback and gore (particles + decals)

<br><br><br><br>Key aspects that contribute to compelling game feel:<br>
<br>üéØ Momentum and Inertia

<br>Creating sense of weight in character movement
<br>Realistic acceleration/deceleration curves
<br>Object physics that feel believable


<br>‚ö° Input Responsiveness

<br>Reducing input lag for tight controls
<br>Frame data considerations in fighting games
<br>Predictable timing for player mastery


<br>üéÆ Real-World Example 
The Legend of Zelda: Breath of the Wild - Rolling boulders demonstrate weight and momentum, making interactions feel satisfying and physically believable.

<br><br><br><br>Performance vs. Feel Balance:<br>
<br>Frame Rate Consistency

<br>Stable 60/90/120fps for responsive controls
<br>Frame pacing for smooth motion
<br>Input latency optimization


<br>Physics Simulation Quality

<br>Collision detection accuracy
<br>Realistic material properties
<br>Consistent simulation timesteps


<br>Feedback Systems

<br>Immediate visual/audio responses
<br>Layered feedback for complex actions
<br>Contextual haptic patterns


<br><br>‚ú® Polish Elements That Enhance Feel

<br>Screen Shake: Emphasizes impact and power
<br>Particle Effects: Visual confirmation/communication of actions
<br>Sound Design: Audio cuess that reinforce interactions
<br>Animation Curves: Smooth, appealing motion
<br>Camera Movement: Dynamic perspectives that follow action

<br><br><br>ü§î Analysis Exercise (3-4 minutes)
Think of a game you've played recently that had exceptional "game feel":
Consider these aspects:

<br>What made the controls feel responsive?
<br>How did the game provide feedback for your actions?
<br>What elements made interactions feel satisfying?

Write down 2-3 specific examples of how the game achieved good feel through:

<br>Visual feedback
<br>Audio design
<br>Control responsiveness

<br><br><br><br>
<br>Precise jump timing and landing feedback (character controller is key here)
<br>Clear momentum and gravity systems
<br>Forgiving mechanics (invincibility frames, jump buffering)
<br><br>
<br>Weighty weapon impacts
<br>Satisfying hit confirmation
<br>Fluid combo systems
<br><br>
<br>Realistic handling and tire physics
<br>Environmental feedback (weather, surface types)
<br>Speed sensation through visual effects
<br><br>
<br>Clear manipulation feedback (especially for physics puzzles)
<br>Satisfying completion effects
<br>Intuitive interaction metaphors
<br><br><br>üìñ Further Reading

<br><a data-tooltip-position="top" aria-label="https://www.amazon.com/Game-Feel-Designers-Virtual-Sensation/dp/0123743281" rel="noopener nofollow" class="external-link" href="https://www.amazon.com/Game-Feel-Designers-Virtual-Sensation/dp/0123743281" target="_blank">Game Feel: A Game Designer's Guide to Virtual Sensation</a> by Steve Swink
<br><a data-tooltip-position="top" aria-label="https://www.schellgames.com/art-of-game-design/" rel="noopener nofollow" class="external-link" href="https://www.schellgames.com/art-of-game-design/" target="_blank">The Art of Game Design</a> by Jesse Schell
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=Fy0aCDmgnxg" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=Fy0aCDmgnxg" target="_blank">Juice It or Lose It</a> - Game design talk

<br><br>
<br>Frame data analyzers for fighting games
<br>Input lag testing equipment
<br>Player behavior recording software
<br><br><br>Coming up: We'll explore how algorithmic content creation enhances game development efficiency and creativity.<br>üìç Progress Tracking

<br>Module 1A: Game Feel and Tactile Experience ‚úì
<br>Module 1B: Procedural Workflows Introduction
<br>Module 1C: Node-Based Systems and Advanced Techniques
<br>Module 1D: Lighting Fundamentals and Technical Systems
<br>Module 1E: Color Theory and Advanced Lighting
<br>Module 1F: Case Studies and Practical Implementation

<br><br>üß≠ Module Navigation 
Next: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1B - Procedural Workflows Introduction" data-href="GMAP 395 - Module 1B - Procedural Workflows Introduction" href="gmap-395\module-1\submodules\gmap-395-module-1b-procedural-workflows-introduction.html" class="internal-link" target="_self" rel="noopener nofollow">Module 1B</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\module-1\submodules\gmap-395-module-1a-game-feel-and-tactile-experience.html</link><guid isPermaLink="false">GMAP 395/Module 1/submodules/GMAP 395 - Module 1A - Game Feel and Tactile Experience.md</guid><pubDate>Wed, 02 Jul 2025 18:31:55 GMT</pubDate></item><item><title><![CDATA[Module 1B: Procedural Workflows Introduction]]></title><description><![CDATA[ 
 <br><br>Module Overview 
Learning Focus: Understanding procedural content generation and algorithmic workflows<br>
Builds On: <a data-href="GMAP 395 - Module 1A - Game Feel and Tactile Experience" href="gmap-395\module-1\submodules\gmap-395-module-1a-game-feel-and-tactile-experience.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1A - Game Feel and Tactile Experience</a> (Game Feel fundamentals) and content from <a data-href="GAMP 395 - Introduction - B" href="gmap-395\introduction\gamp-395-introduction-b.html" class="internal-link" target="_self" rel="noopener nofollow">GAMP 395 - Introduction - B</a>
<br><br><br>Procedural workflows use algorithms and rules to automate content creation, enabling developers to generate vast amounts of varied content efficiently. This is often refered to as Procedural Content Generation of PCG.<br><br>Traditional Approach: "I need to model 50 unique trees manually"<br>
Procedural Approach: "I need to create rules that generate 50 unique trees automatically"<br>üí° Core Principle Write the rules once, generate infinite variations.<br><br><br><br>
<br>Reduces repetitive tasks - Focus on creative rules rather than manual labor
<br>Accelerates iteration - Adjust parameters instead of rebuilding assets
<br>Eliminates manual errors - Consistent application of rules
<br><br>
<br>Enables vast worlds - Generate content beyond manual capabilities
<br>Supports rapid prototyping - Test multiple design directions quickly
<br>Facilitates easy updates - Modify rules to update entire asset libraries
<br><br>
<br>Generates unexpected results - Algorithmic serendipity sparks creativity
<br>Provides systematic exploration - Methodically explore design possibilities
<br>Maintains consistency - Unified rules ensure cohesive and consistence aesthetics (with parameters providing variability when needed)
<br><br><br><br><br>
<br>Landscape Creation - Algorithmic height maps and erosion simulation
<br>Vegetation Placement - Rules-based distribution of plants and trees
<br>Biome Systems - Climate-based environment generation
<br>Blender GN Terrain PCG Tutorial Example

<br><br>
<br>Modular Characters - Mix-and-match clothing, accessories, features
<br>Procedural Animation - Rule-based movement and behavior systems
<br>Dynamic Scaling - Automatic adaptation for different character sizes
<br><br>
<br>Building Generation - Modular construction with infinite variations
<br>Dungeon Creation - Algorithmic layouts with gameplay flow
<br>Urban Planning - Procedural cities with realistic street layouts
<br><br><br>The terms and definitions for the "taxonomy of PCG" were originally provided by a paper <a data-tooltip-position="top" aria-label="chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://atlarge-research.com/pdfs/2013-hendrikx-procedural.pdf" rel="noopener nofollow" class="external-link" href=".\chrome-extension:\\efaidnbmnnnibpcajpcglclefindmkaj\https:\\atlarge-research.com\pdfs\2013-hendrikx-procedural.pdf" target="_blank">Procedural Content Generation for Games: A Survey</a>. These terms are very useful for understanding the various levels of components for PCG and their breakdown within video games. <br><br>
<br>Assets: Textures, sounds, models
<br>Components: Individual game elements
<br><br>
<br>Levels: Playable areas and environments
<br>Terrains: Landscapes and geographical features
<br>Maps: Layout and spatial organization
<br><br>
<br>Rules: Mechanical relationships and interactions
<br>Mechanics: Gameplay systems and features
<br><br>
<br>Events: Dynamic occurrences and triggers
<br>Narratives: Story elements and branching paths
<br>Quests: Mission and objective generation
<br>üìö Deep Dive Resources 
<a data-tooltip-position="top" aria-label="https://www.pcgbook.com/" rel="noopener nofollow" class="external-link" href="https://www.pcgbook.com/" target="_blank">Procedural Content Generation in Games - Free Online Book</a><br>
<a data-tooltip-position="top" aria-label="https://www.researchgate.net/publication/320615781_Modern_Trends_in_Automatic_Generation_of_Content_for_Video_Games#fullTextFileContent" rel="noopener nofollow" class="external-link" href="https://www.researchgate.net/publication/320615781_Modern_Trends_in_Automatic_Generation_of_Content_for_Video_Games#fullTextFileContent" target="_blank">Modern Trends in Automatic Generation of Content for Video Games</a><br>
<a data-tooltip-position="top" aria-label="chrome-extension://efaidnbmnnnibpcajpcglclefindmkaj/https://atlarge-research.com/pdfs/2013-hendrikx-procedural.pdf" rel="noopener nofollow" class="external-link" href=".\chrome-extension:\\efaidnbmnnnibpcajpcglclefindmkaj\https:\\atlarge-research.com\pdfs\2013-hendrikx-procedural.pdf" target="_blank">Procedural Content Generation for Games: A Survey</a>
<br><br><br><br>
<br>Creating many similar but varied elements
<br>Needing rapid iteration on design parameters
<br>Working with systematic, rule-based patterns
<br>Building scalable content pipelines
<br><br>
<br>Creating hero assets (see note below) requiring precise artistic control
<br>Working with unique, one-off designs
<br>Dealing with highly irregular or organic forms
<br>Fine-tuning specific aesthetic details
<br>On "Hero Assets"
There are many instances where a hero asset can be partially or fully procedurally generated. It depends on the game and the context fo the game experience.
<br><br>Best Practice Workflow

<br>Generate base content procedurally
<br>Manually adjust and refine key elements
<br>Use procedural methods for variations and iterations

<br><br><br><br>Scattering/Distribution:<br>
<br>Random placement with controlled variation
<br>Density maps for placement frequency
<br>Collision avoidance systems
<br>Parameter Manipulation:<br>
<br>Randomization within specified ranges
<br>Mathematical relationships between properties
<br>Conditional logic triggering behaviors
<br>Pattern Generation:<br>
<br>Geometric patterns from mathematical relationships
<br>Noise-based variation for organic randomness
<br>Rule-based systems determining pattern behavior
<br><br>
<br>Component Systems - Combining pre-made pieces systematically
<br>Constraint-Based Placement - Rules governing component connections
<br>Variation Generation - Creating diversity from limited base components
<br><br><br><br>
<br>Infinite Universe - Procedurally generated planets, flora, fauna
<br>Systematic Variety - Consistent rules creating believable diversity
<br>Player Discovery - Each player experiences "unique" content
<br>üîó Technical Deep Dive <a data-tooltip-position="top" aria-label="https://www.rambus.com/blogs/the-algorithms-of-no-mans-sky-2/" rel="noopener nofollow" class="external-link" href="https://www.rambus.com/blogs/the-algorithms-of-no-mans-sky-2/" target="_blank">The Algorithms of No Man's Sky</a><br><br>
<br>Terrain Generation - Algorithmic landscapes with biome systems
<br>Structure Placement - Villages, dungeons, landmarks
<br>Resource Distribution - Ore placement following geological rules
<br><br>
<br>Weapon Generation - Millions of unique weapons from modular components
<br>Stat Calculation - Mathematical systems determining properties
<br>Visual Variety - Procedural combinations of parts and materials
<br><br><br><br>Over-Generation Problem Excessively random content can feel disjointed and meaningless.
Solution: Blend procedural elements with curated designs and cohesive artistic vision.
<br>Player Fatigue Risk Repetitive patterns may reduce engagement over time.
Solution: Introduce meaningful variability and uniqueness within procedural design systems.
<br><br>
<br>Balance randomness with intention
<br>Maintain artistic cohesion
<br>Test extensively with players
<br>Iterate on rules based on feedback
<br><br><br>üéØ Pattern Recognition Exercise (4-5 minutes)
Identify Procedural Elements: Think of games you've played and identify 3 examples where procedural generation might have been used.
Look for:

<br>Repeating but varied elements (buildings, trees, rocks)
<br>Large-scale environments with systematic patterns
<br>Character customization systems
<br>Weapon or item generation systems

Analysis Questions:

<br>What made you think this element was procedural?
<br>What rules or patterns do you notice?
<br>How does the system create variety while maintaining consistency?

<br><br><br>üìñ Further Exploration

<br><a data-tooltip-position="top" aria-label="https://dl.acm.org/doi/10.1145/2422956.2422957" rel="noopener nofollow" class="external-link" href="https://dl.acm.org/doi/10.1145/2422956.2422957" target="_blank">Procedural Content Generation Survey</a>
<br><a data-tooltip-position="top" aria-label="https://www.autodesk.com/solutions/proceduralism" rel="noopener nofollow" class="external-link" href="https://www.autodesk.com/solutions/proceduralism" target="_blank">Procedural Workflows Explained - Autodesk</a>
<br><a data-tooltip-position="top" aria-label="https://www.gdcvault.com/search.php#&amp;category=free&amp;firstfocus=&amp;keyword=procedural" rel="noopener nofollow" class="external-link" href="https://www.gdcvault.com/search.php#&amp;category=free&amp;firstfocus=&amp;keyword=procedural" target="_blank">GDC Talks on PCG</a>

<br><br>
<br>L-Systems - Rule-based fractal generation
<br>Voronoi Patterns - Organic distribution techniques
<br>Flow Fields - Vector-based procedural direction
<br>Noise Functions - Mathematical randomness tools
<br><br><br>Coming up: We'll explore visual scripting and node-based workflows that make procedural thinking accessible to artists.<br>üìç Progress Tracking

<br>Module 1A: Game Feel and Tactile Experience ‚úì
<br>Module 1B: Procedural Workflows Introduction ‚úì
<br>Module 1C: Node-Based Systems and Advanced Techniques
<br>Module 1D: Lighting Fundamentals and Technical Systems
<br>Module 1E: Color Theory and Advanced Lighting
<br>Module 1F: Case Studies and Practical Implementation

<br><br>üß≠ Module Navigation 
Previous: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1A - Game Feel and Tactile Experience" data-href="GMAP 395 - Module 1A - Game Feel and Tactile Experience" href="gmap-395\module-1\submodules\gmap-395-module-1a-game-feel-and-tactile-experience.html" class="internal-link" target="_self" rel="noopener nofollow">Moduel 1A</a><br>
Next: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1C - Node-Based Systems and Advanced Techniques" data-href="GMAP 395 - Module 1C - Node-Based Systems and Advanced Techniques" href="gmap-395\module-1\submodules\gmap-395-module-1c-node-based-systems-and-advanced-techniques.html" class="internal-link" target="_self" rel="noopener nofollow">Module 1C</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\module-1\submodules\gmap-395-module-1b-procedural-workflows-introduction.html</link><guid isPermaLink="false">GMAP 395/Module 1/submodules/GMAP 395 - Module 1B - Procedural Workflows Introduction.md</guid><pubDate>Wed, 02 Jul 2025 18:32:05 GMT</pubDate></item><item><title><![CDATA[Module 1C: Node-Based Systems and Advanced Techniques]]></title><description><![CDATA[ 
 <br><br>Module Overview 
Learning Focus: Visual scripting, 3D geometry fundamentals, and advanced procedural operations<br>
Builds On: Module 1B (Procedural workflows): <a data-href="GMAP 395 - Module 1B - Procedural Workflows Introduction" href="gmap-395\module-1\submodules\gmap-395-module-1b-procedural-workflows-introduction.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1B - Procedural Workflows Introduction</a>
<br><br><br>Node-based workflows use visual scripting where operations are represented as connected nodes, creating clear data flow (represented as edges or connectors) and modular logic systems.<br><br>
<br>Nodes: Individual operations or data sources
<br>Connections: Data flow between operations
<br>Parameters: Adjustable values within nodes
<br>Groups: Reusable node combinations
<br>üí° Key Principle Visual representation makes complex procedural logic accessible to artists while maintaining programmer-level flexibility.<br><br><br><br>
<br>Industry-standard procedural modeling and VFX
<br>Complete node-based workflow for all operations
<br>Advanced simulation and procedural generation
<br><br>
<br>Visual scripting for gameplay logic
<br>Real-time interactive system creation
<br>No traditional coding required
<br><br><br>
<br>Node-based material and shader creation
<br>Real-time preview and iteration
<br>Artist-friendly visual interface
<br><br>
<br>Procedural modeling within Blender
<br>Non-destructive geometry manipulation
<br>Integrated with Blender's ecosystem
<br><br><br><br>Basic Components:<br>
<br>Vertices: Points in 3D space (x, y, z coordinates)
<br>Edges: Lines connecting vertices
<br>Faces: Surfaces defined by edge loops
<br>Normals: Perpendicular vectors indicating surface direction
<br>
Also see: https://www.mathsisfun.com/geometry/<br><br>Vectors:<br>
<br>Direction and magnitude in 3D space
<br>Used for movement, rotation, scaling operations
<br><a data-tooltip-position="top" aria-label="https://www.khanacademy.org/math/algebra-home/alg-vectors/alg-vector-basics/v/introduction-to-vectors-and-scalars" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/math/algebra-home/alg-vectors/alg-vector-basics/v/introduction-to-vectors-and-scalars" target="_blank">Khan Academy Vector Basics</a>
<br>Matrices:<br>
<br>Mathematical representations of transformations
<br>Enable complex spatial operations
<br><a data-tooltip-position="top" aria-label="https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:matrices/x9e81a4f98389efdf:mat-intro/v/introduction-to-the-matrix" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:matrices/x9e81a4f98389efdf:mat-intro/v/introduction-to-the-matrix" target="_blank">Matrix Introduction</a>
<br>Quaternions:<br>
<br>Rotation representation avoiding gimbal lock
<br>More efficient than Euler angles for complex rotations
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=zjMuIxRvygQ" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=zjMuIxRvygQ" target="_blank">Quaternion Visualization</a> + <a rel="noopener nofollow" class="external-link" href="https://eater.net/quaternions" target="_blank">https://eater.net/quaternions</a>
<br><br><br>Check-out:
Many of these procedural operation are outlines in the guide/demo for Module 1 - Part 1: <a data-href="GMAP 395 - Guide - Procedural Modeling Fundamentals" href="gmap-395\gmap-395-guide-procedural-modeling-fundamentals.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Guide - Procedural Modeling Fundamentals</a>
<br><br>Scattering/Copying:<br>
<br>Distribute objects across surfaces or volumes
<br>Control density through weight maps
<br>Example: Procedural foliage placement
<br>Randomization/Noise:<br>
<br>Add controlled variation to prevent repetition
<br>Multiple noise types for different effects
<br>Mathematical patterns for organic randomness
<br><br>Boolean Operations:<br>
<br>Combine (union), subtract (difference), or intersect shapes
<br>Create complex forms from simple primitives
<br>Essential for architectural and mechanical modeling
<br>Deformations:<br>
<br>Non-destructive shape modification
<br>Bend, twist, taper operations
<br>Terrain sculpting and organic modeling
<br>Instancing:<br>
<br>Efficiently reuse geometry with variations
<br>Memory-optimized for large-scale scenes
<br>Essential for performance in complex environments
<br><br>Splines and Curves:<br>
<br>Define paths for object placement or movement
<br>Smooth curve generation and manipulation
<br>Road networks, river systems, cable routing
<br>Constraints:<br>
<br>Limit and guide procedural behaviors
<br>Collision avoidance and spacing rules
<br>Maintain artistic intent within procedural systems
<br><br><br><br><br>Applications:<br>
<br>Organic textures and displacement
<br>Terrain height variation
<br>Cloud and fluid simulation
<br><br><br>L-Systems:<br>
<br>Rule-based fractal generation
<br>Tree and plant structure creation
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=egxBK_EGauM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=egxBK_EGauM" target="_blank">L-Systems Fundamentals</a>
<br><br>
<br>Rule-based architectural generation
<br>Procedural building and city creation
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=zCeqBV0Amm0" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=zCeqBV0Amm0" target="_blank">Procedural Building Systems</a>
<br><br>
<br>Vector-based directional systems
<br>Particle guidance and animation
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=na7LuZsW2UM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=na7LuZsW2UM" target="_blank">Flow Fields Beauty</a>
<br><br><br><br>Creating reusable, interchangeable components that work together systematically.<br><br>
<br>Reusability: Assets work across multiple projects
<br>Flexibility: Easy updates and maintenance
<br>Performance: Optimized memory usage through instancing
<br>Scalability: Supports large-scale content creation
<br><br>Modular assets populated procedurally create diverse environments efficiently - seen in games like No Man's Sky and Minecraft.<br>üéÆ Modular Environment Example <a data-tooltip-position="top" aria-label="https://www.beyondextent.com/articles/balancing-modularity-and-uniqueness-in-environment-art" rel="noopener nofollow" class="external-link" href="https://www.beyondextent.com/articles/balancing-modularity-and-uniqueness-in-environment-art" target="_blank">Balancing Modularity and Uniqueness in Environment Art</a><br><br><br><br>Step-by-Step Process:<br>
<br>Define base tree models (3-5 variations)
<br>Create placement rules (density, slope tolerance, clustering)
<br>Set variation parameters (scale, rotation, species distribution)
<br>Use spline paths for clearings and roads
<br>Add noise-based variation for natural irregularity
<br>Apply modular rock/debris scattering
<br>Result: Infinite forest variations with controllable artistic direction.<br><br><br>üîç Workflow Breakdown (5 minutes)
Choose a complex environment from a game you know:
Identify potential node operations:

<br>What elements could be scattered/distributed?
<br>Which components appear modular?
<br>Where might noise or randomization be applied?
<br>What geometric operations seem necessary?

Sketch a simple node flow showing how you might recreate key elements procedurally.
<br><br><br>üõ†Ô∏è Hands-On Learning

<br><a data-tooltip-position="top" aria-label="https://www.sidefx.com/tutorials/foundations-205-nodes-networks-assets/" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/tutorials/foundations-205-nodes-networks-assets/" target="_blank">Nodes, Networks, and Assets</a>
<br><a data-tooltip-position="top" aria-label="https://spin.atomicobject.com/blender-node-based-workflows/" rel="noopener nofollow" class="external-link" href="https://spin.atomicobject.com/blender-node-based-workflows/" target="_blank">Blender Node-Based Workflows</a>
<br>=

<br><br>
<br><a data-tooltip-position="top" aria-label="https://www.redblobgames.com/maps/terrain-from-noise/" rel="noopener nofollow" class="external-link" href="https://www.redblobgames.com/maps/terrain-from-noise/" target="_blank">Making Maps with Noise Functions</a>
<br><a data-tooltip-position="top" aria-label="https://thebookofshaders.com/11/" rel="noopener nofollow" class="external-link" href="https://thebookofshaders.com/11/" target="_blank">Noise and Procedural Generation</a>
<br><a data-tooltip-position="top" aria-label="https://www.mit.edu/~tknight/IJDC/page_introduction.htm" rel="noopener nofollow" class="external-link" href="https://www.mit.edu/~tknight/IJDC/page_introduction.htm" target="_blank">Shape Grammars Introduction (MIT)</a>
<br><br><br>Coming up: We'll explore how lighting systems work technically and artistically in modern games.<br>üìç Progress Tracking

<br>Module 1A: Game Feel and Tactile Experience ‚úì
<br>Module 1B: Procedural Workflows Introduction ‚úì
<br>Module 1C: Node-Based Systems and Advanced Techniques ‚úì
<br>Module 1D: Lighting Fundamentals and Technical Systems
<br>Module 1E: Color Theory and Advanced Lighting
<br>Module 1F: Case Studies and Practical Implementation

<br><br>üß≠ Module Navigation 
Previous: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1B - Procedural Workflows Introduction" data-href="GMAP 395 - Module 1B - Procedural Workflows Introduction" href="gmap-395\module-1\submodules\gmap-395-module-1b-procedural-workflows-introduction.html" class="internal-link" target="_self" rel="noopener nofollow">Module 1B</a><br>
Next: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems" data-href="GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems" href="gmap-395\module-1\submodules\gmap-395-module-1d-lighting-fundamentals-and-technical-systems.html" class="internal-link" target="_self" rel="noopener nofollow">Module 1D</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\module-1\submodules\gmap-395-module-1c-node-based-systems-and-advanced-techniques.html</link><guid isPermaLink="false">GMAP 395/Module 1/submodules/GMAP 395 - Module 1C - Node-Based Systems and Advanced Techniques.md</guid><pubDate>Wed, 02 Jul 2025 18:32:13 GMT</pubDate></item><item><title><![CDATA[Module 1D: Lighting Fundamentals and Technical Systems]]></title><description><![CDATA[ 
 <br><br>Module Overview 
Learning Focus: Technical lighting systems, optimization, and core lighting principles<br>
Builds On: Module 1C (Node-based systems and workflows)
<br><br><br>Game lighting balances artistic vision with technical constraints to create immersive, performant visual experiences.<br><br>
<br>üé≠ Enhance mood and atmosphere - Emotional storytelling through light
<br>üëÄ Guide player attention - Direct focus to important elements
<br>üîç Improve visual clarity - Ensure gameplay readability
<br>üì¢ Communicate mechanics - Light as gameplay information
<br>‚ö° Balance aesthetics with performance - Maintain target frame rates
<br><br><br><br><br>Quality:<br>
<br>How light interacts with surfaces
<br>Shadow softness and light falloff
<br>Surface material response
<br>Quantity:<br>
<br>Light intensity and coverage
<br>Brightness levels appropriate to scene
<br>Balance preventing visual fatigue
<br>Direction:<br>
<br>Light angle and position
<br>Dramatic silhouetting effects
<br>Texture and form enhancement
<br><br><br><br>Direct Lighting:<br>
<br>Light hits surfaces directly from source
<br>Fast, predictable rendering
<br>Limited realism without bounces
<br>Indirect Lighting:<br>
<br>Light bounces off surfaces before reaching viewer
<br>Creates realistic ambient illumination
<br>More computationally expensive
<br><br><br>Simulates realistic light interactions:<br>
<br>Light bouncing between surfaces
<br>Color bleeding from colored surfaces
<br>Realistic ambient lighting
<br>üìö Deep Dive <a data-tooltip-position="top" aria-label="https://www.adobe.com/products/substance3d/discover/what-is-global-illumination.html" rel="noopener nofollow" class="external-link" href="https://www.adobe.com/products/substance3d/discover/what-is-global-illumination.html" target="_blank">Adobe Guide to Global Illumination</a><br><br><br><br>Directional Light:<br>
<br>Simulates sunlight with infinite reach
<br>Parallel rays across entire scene
<br>Efficient for outdoor environments
<br>Point Light:<br>
<br>Emits uniformly in all directions
<br>Ideal for bulbs, fires, magical effects
<br>Falloff creates natural attenuation
<br>Spot Light:<br>
<br>Cone-shaped beam with defined angle
<br>Perfect for flashlights, stage lighting
<br>Controllable cone angle and edge softness
<br>Area Light:<br>
<br>Illuminates from surface rather than point
<br>Soft, realistic shadows
<br>Usually baked-only due to performance cost
<br>üéÆ Level Design Resource <a data-tooltip-position="top" aria-label="https://book.leveldesignbook.com/process/lighting" rel="noopener nofollow" class="external-link" href="https://book.leveldesignbook.com/process/lighting" target="_blank">The Level Design Book - Lighting</a><br><br><br><br>Dynamic Lighting:<br>
<br>Updates continuously during gameplay
<br>Interactive with moving objects
<br>Higher performance cost
<br>Static/Baked Lighting:<br>
<br>Pre-calculated for non-moving elements
<br>Stored in lightmaps and textures
<br>Optimal performance for static geometry
<br>Mixed Lighting:<br>
<br>Combines dynamic and static methods
<br>Static lighting with dynamic shadows
<br>Best balance of quality and performance
<br>üìñ Technical Reference <a data-tooltip-position="top" aria-label="https://docs.unity3d.com/6000.0/Documentation/Manual/LightModes-introduction.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/6000.0/Documentation/Manual/LightModes-introduction.html" target="_blank">Unity Documentation on Light Modes</a><br><br><br><br><br>
<br>
üéØ Limit Realtime Lights

<br>Use baked lighting wherever possible
<br>Reserve dynamic lights for key gameplay elements


<br>
üîÄ Leverage Mixed Lighting

<br>Combine baked GI with dynamic shadows
<br>Best quality-to-performance ratio


<br>
üìç Light Probes

<br>Optimize lighting for dynamic objects
<br>Sample baked lighting at key positions


<br>
ü™û Reflection Probes

<br>Simulate realistic reflections efficiently
<br>Baked cubemaps for static reflections


<br>
üìà Profile Regularly

<br>Monitor lighting performance impact
<br>Identify bottlenecks early


<br>üîç Advanced Reading <a data-tooltip-position="top" aria-label="https://vintay.medium.com/difference-between-realtime-mixed-and-baked-lighting-in-unity-6bda1f24bfb" rel="noopener nofollow" class="external-link" href="https://vintay.medium.com/difference-between-realtime-mixed-and-baked-lighting-in-unity-6bda1f24bfb" target="_blank">Realtime vs. Mixed vs. Baked Lighting</a><br><br><br><br>
<br>Highlight interactable objects with warm light
<br>Use contrast to direct attention
<br>Create visual paths through lighting
<br><br>
<br>Dim, flickering lights for horror tension
<br>Warm hearth light for safety and comfort
<br>Cool moonlight for mystery or isolation
<br><br>
<br>Light-activated mechanisms
<br>Shadow-based puzzles
<br>Reflective surface challenges
<br><br><br><br><br>
<br>Pre-render static lights for performance
<br>Generate lightmaps and ambient occlusion
<br>Quality vs. baking time trade-offs
<br><br>
<br>Atmospheric depth through fog and scattering
<br>God rays and light shafts
<br>Performance-intensive but impactful
<br><br>
<br>Fine-tune light interactions for materials
<br>Specialized lighting models
<br>Platform-specific optimizations
<br><br><br>üìö Pipeline Resources

<br><a data-tooltip-position="top" aria-label="https://www.geeksforgeeks.org/opengl-rendering-pipeline-overview/" rel="noopener nofollow" class="external-link" href="https://www.geeksforgeeks.org/opengl-rendering-pipeline-overview/" target="_blank">OpenGL Rendering Pipeline Overview</a>
<br><a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Graphics_pipeline" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Graphics_pipeline" target="_blank">Graphics Pipeline Wikipedia</a>

<br><br><br><br>
<br>Gradual lighting transitions over time
<br>Color temperature shifts (warm to cool)
<br>Intensity changes matching natural patterns
<br><br>
<br>Lights responding to player actions
<br>Environmental triggers
<br>Gameplay state changes
<br><br>
<br>Color and intensity shifts for drama
<br>Lighting supporting narrative moments
<br>Emotional guidance through illumination
<br><br><br>üí° Scene Assessment (4-5 minutes)
Think of a memorable game scene with what you feel was effective lighting:
Analyze these elements:

<br>How did lighting guide your attention?
<br>What mood did the lighting create?
<br>Which light types were likely used?

<br><br><br>üéì Further Learning

<br><a data-tooltip-position="top" aria-label="https://www.realtimerendering.com/" rel="noopener nofollow" class="external-link" href="https://www.realtimerendering.com/" target="_blank">Real-Time Rendering Techniques</a>
<br><a data-tooltip-position="top" aria-label="https://gdcvault.com/browse?keyword=lighting" rel="noopener nofollow" class="external-link" href="https://gdcvault.com/browse?keyword=lighting" target="_blank">GDC Lighting Talks</a>
<br><a data-tooltip-position="top" aria-label="https://www.artstation.com/search?sort_by=relevance&amp;query=lighting artist" rel="noopener nofollow" class="external-link" href="https://www.artstation.com/search?sort_by=relevance&amp;query=lighting%20artist" target="_blank">Lighting Artist Portfolio Examples</a>

<br><br>
<br>Light Transport Theory - Physics of light behavior
<br>Shadow Mapping Techniques - Real-time shadow algorithms
<br>HDR and Tone Mapping - High dynamic range lighting
<br>Physically Based Rendering - Realistic material lighting
<br><br><br>Coming up: We'll explore how color enhances lighting design and creates emotional impact.<br>üìç Progress Tracking

<br>Module 1A: Game Feel and Tactile Experience ‚úì
<br>Module 1B: Procedural Workflows Introduction ‚úì
<br>Module 1C: Node-Based Systems and Advanced Techniques ‚úì
<br>Module 1D: Lighting Fundamentals and Technical Systems ‚úì
<br>Module 1E: Color Theory and Advanced Lighting
<br>Module 1F: Case Studies and Practical Implementation

<br><br>üß≠ Module Navigation 
Previous: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1C - Node-Based Systems and Advanced Techniques" data-href="GMAP 395 - Module 1C - Node-Based Systems and Advanced Techniques" href="gmap-395\module-1\submodules\gmap-395-module-1c-node-based-systems-and-advanced-techniques.html" class="internal-link" target="_self" rel="noopener nofollow">Module 1C</a><br>
Next: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1E - Color Theory and Advanced Lighting" data-href="GMAP 395 - Module 1E - Color Theory and Advanced Lighting" href="gmap-395\module-1\submodules\gmap-395-module-1e-color-theory-and-advanced-lighting.html" class="internal-link" target="_self" rel="noopener nofollow">Module 1E</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\module-1\submodules\gmap-395-module-1d-lighting-fundamentals-and-technical-systems.html</link><guid isPermaLink="false">GMAP 395/Module 1/submodules/GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems.md</guid><pubDate>Wed, 02 Jul 2025 18:32:19 GMT</pubDate></item><item><title><![CDATA[Module 1E: Color Theory and Advanced Lighting]]></title><description><![CDATA[ 
 <br><br>Module Overview 
Learning Focus: Color theory in lighting design, emotional impact, and visual storytelling<br>
Builds On: Module 1D (Lighting fundamentals and technical systems): <a data-href="GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems" href="gmap-395\module-1\submodules\gmap-395-module-1d-lighting-fundamentals-and-technical-systems.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems</a>
<br><br><br>Color transforms lighting from technical illumination into emotional storytelling. Strategic color choices guide players, create atmosphere, and enhance immersion through psychological and visual impact.<br><br>
<br>Warm colors (red, orange, yellow) convey energy, comfort, or danger
<br>Cool colors (blue, green, purple) suggest calm, mystery, or isolation
<br>Saturation levels affect intensity and mood
<br><br>
<br>High contrast naturally draws attention to key elements
<br>Color coding helps players understand interactive systems
<br>Consistent palettes create visual hierarchy and clarity
<br><br><br><br>Hue: The color itself (red, blue, yellow) Saturation: Color intensity or purity Value: Brightness or darkness level<br><br><br>Complementary Colors:<br>
<br>Opposite on color wheel (blue/orange)
<br>Create strong contrast and visual impact
<br>Ideal for focal points and dramatic lighting
<br>Analogous Colors:<br>
<br>Adjacent on color wheel (red/orange/yellow)
<br>Create peaceful, harmonious atmospheres
<br>Perfect for cohesive environmental lighting
<br>Triadic Colors:<br>
<br>Equally spaced around wheel (red/yellow/blue)
<br>Balanced, vibrant combinations
<br>Dynamic but not overwhelming
<br>Useful Tool for Color Palettes
<a data-tooltip-position="top" aria-label="https://color.adobe.com/" rel="noopener nofollow" class="external-link" href="https://color.adobe.com/" target="_blank">Adobe Color</a>
<br><br><br><br>Warm Light (2700K-3500K):<br>
<br>Sunlight, firelight, tungsten bulbs
<br>Creates comfort, intimacy, energy
<br>Perfect for safe spaces, taverns, homes
<br>Cool Light (5000K-7000K):<br>
<br>Moonlight, fluorescent, daylight
<br>Suggests sterility, distance, technology
<br>Ideal for sci-fi, hospitals, underwater scenes
<br><br>
<br>Dawn/dusk transitions from warm to cool
<br>Seasonal changes affecting ambient temperature
<br>Emotional beats supported by temperature changes
<br><br><br><br>A previsualization tool mapping emotional journey through color, ensuring consistency and coherence in visual storytelling.<br><br><br>
<br>Break down game/level into key emotional moments
<br>Assign dominant palettes based on mood and theme
<br>Create thumbnail sketches with approximate lighting
<br>Ensure smooth transitions between emotional beats
<br>üé® Simple Example Color Journey

<br>Tutorial area: Warm, welcoming yellows and oranges
<br>First challenge: Cooler blues with warm accent lights
<br>Boss battle: Dramatic reds and stark contrasts
<br>Victory moment: Return to warm, celebratory golds

<br>üìö Learning Resources

<br><a data-tooltip-position="top" aria-label="https://photography.tutsplus.com/tutorials/how-to-colourscripts-animation--cms-38391" rel="noopener nofollow" class="external-link" href="https://photography.tutsplus.com/tutorials/how-to-colourscripts-animation--cms-38391" target="_blank">How to Make a Color Script</a>
<br><a data-tooltip-position="top" aria-label="https://www.khanacademy.org/computing/pixar/art-of-lighting/introduction-to-virtual-lighting/a/exercise-5-color-scripts" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/computing/pixar/art-of-lighting/introduction-to-virtual-lighting/a/exercise-5-color-scripts" target="_blank">Khan Academy: Color Scripts</a>

<br><br><br><br>
<br>Kelvin temperature values for realistic light sources
<br>Color picker integration with temperature sliders
<br>Real-time preview of temperature changes
<br><br><br>Techniques:<br>
<br>LUT (Look-Up Tables) for consistent color grading
<br>Tone mapping for high dynamic range scenes
<br>Color correction balancing overall scene mood
<br>LUTs Resources
<a data-tooltip-position="top" aria-label="https://blog.frost.kiwi/WebGL-LUTS-made-simple/" rel="noopener nofollow" class="external-link" href="https://blog.frost.kiwi/WebGL-LUTS-made-simple/" target="_blank">How video games use LUTs and how you can too</a><br>
<a rel="noopener nofollow" class="external-link" href="https://youtube.com/shorts/TYx5SgEGemc?si=1Gx1VgLHvt_QPHK-" target="_blank">https://youtube.com/shorts/TYx5SgEGemc?si=1Gx1VgLHvt_QPHK-</a>
<br><br>
<br>Scripted color changes responding to gameplay events
<br>Ambient color zones for area-specific atmospheres
<br>Player-triggered lighting color shifts
<br><br><br><br>
<br>Ambient base - Overall environmental illumination
<br>Key lights - Primary directional sources
<br>Fill lights - Secondary illumination reducing harsh shadows
<br>Accent lights - Highlighting specific details or areas
<br><br>
<br>Gradual transitions hinting at narrative progression
<br>Color symbolism reinforcing thematic elements
<br>Interactive lighting responding to player choices
<br><br>
<br>LOD systems for lighting detail based on distance
<br>Render pipelines optimized for lighting complexity
<br>Post-processing effects enhancing without additional light sources
<br><br><br>üé® Color Mood Exercise (5 minutes)
Choose two contrasting game environments you know well:
For each environment, identify:

<br>Dominant color palette
<br>Color temperature (warm/cool)
<br>Emotional impact intended
<br>How color guides player behavior

Compare: How do the different color approaches create distinct experiences?
<br><br><br><br>
<br>Desaturated palettes with stark accent colors
<br>Sickly greens and cold blues for unease
<br>Sudden warm light as false safety or revelation
<br><br>
<br>Rich, saturated palettes for magical worlds
<br>Golden hour lighting for heroic moments
<br>Mystical purples and blues for magical effects
<br><br>
<br>Cool, clinical lighting for technology themes
<br>Neon accents creating cyberpunk aesthetics
<br>Stark contrasts between natural and artificial
<br><br>
<br>Realistic color temperatures matching time of day
<br>Seasonal palettes supporting environmental storytelling
<br>Dynamic weather affecting color and mood
<br><br><br><br>
<br>Day/night cycles with natural color progression
<br>Seasonal shifts affecting ambient lighting
<br>Weather patterns modifying color and intensity
<br><br>
<br>Health status reflected in environmental color
<br>Power-up states changing lighting hues
<br>Proximity alerts through color temperature shifts
<br><br>
<br>Music synchronization for rhythm games
<br>Environmental audio affecting color dynamics
<br>Combat intensity driving lighting changes
<br><br><br>üé® Industry Learning

<br><a data-tooltip-position="top" aria-label="https://conceptartempire.com/best-color-theory-books/" rel="noopener nofollow" class="external-link" href="https://conceptartempire.com/best-color-theory-books/" target="_blank">Digital Color Theory for Artists</a>
<br><a data-tooltip-position="top" aria-label="https://www.numberanalytics.com/blog/the-art-of-color-grading-in-game-development" rel="noopener nofollow" class="external-link" href="https://www.numberanalytics.com/blog/the-art-of-color-grading-in-game-development" target="_blank">Color Grading Techniques</a>

<br><br>
<br>Real-time Global Illumination techniques
<br>HDR Color Workflows for high-end visuals
<br>Mobile Optimization for color-rich lighting
<br><br><br>Coming up: We'll examine real-world examples and practical implementation strategies.<br>üìç Progress Tracking

<br>Module 1A: Game Feel and Tactile Experience ‚úì
<br>Module 1B: Procedural Workflows Introduction ‚úì
<br>Module 1C: Node-Based Systems and Advanced Techniques ‚úì
<br>Module 1D: Lighting Fundamentals and Technical Systems ‚úì
<br>Module 1E: Color Theory and Advanced Lighting ‚úì
<br>Module 1F: Case Studies and Practical Implementation

<br><br>üß≠ Module Navigation 
Previous: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems" data-href="GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems" href="gmap-395\module-1\submodules\gmap-395-module-1d-lighting-fundamentals-and-technical-systems.html" class="internal-link" target="_self" rel="noopener nofollow">Module 1D</a><br>
Next: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1F - Case Studies and Practical Implementation" data-href="GMAP 395 - Module 1F - Case Studies and Practical Implementation" href="gmap-395\module-1\submodules\gmap-395-module-1f-case-studies-and-practical-implementation.html" class="internal-link" target="_self" rel="noopener nofollow">Moduel 1F</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\module-1\submodules\gmap-395-module-1e-color-theory-and-advanced-lighting.html</link><guid isPermaLink="false">GMAP 395/Module 1/submodules/GMAP 395 - Module 1E - Color Theory and Advanced Lighting.md</guid><pubDate>Wed, 02 Jul 2025 18:32:24 GMT</pubDate></item><item><title><![CDATA[Module 1F: Case Studies and Practical Implementation]]></title><description><![CDATA[ 
 <br><br>Module Overview 
Learning Focus: Real-world applications, comparative analysis, and implementation strategies<br>
Builds On: All previous modules - synthesis and application
<br><br><br><br><img alt="GMAP 395/Module 1/Media/6492c4ab6751d8f29f5e4826_LAUNCH_Screenshot_101-p-500.webp" src="lib\media\6492c4ab6751d8f29f5e4826_launch_screenshot_101-p-500.webp"><br>Platform: High-spec PC and consoles (PS4/PS5, Xbox One/Series)<br>Lighting Techniques:<br>
<br>Real-time ray tracing for accurate reflections and indirect lighting
<br>Dynamic global illumination creating realistic light bounces
<br>Volumetric lighting for atmospheric fog and light beams
<br>Supernatural lighting effects supporting narrative themes
<br>Technical Implementation:<br>
<br>Hardware ray tracing when available, software fallbacks for older systems
<br>Selective baking for static geometry optimization
<br>LOD scaling reducing ray tracing complexity at distance
<br>üåü Key Achievements

<br>Immersive supernatural atmosphere through advanced lighting
<br>Scalable quality maintaining mood across different hardware
<br>Dynamic lighting supporting interactive destruction

<br><br><br><br><br><img alt="GMAP 395/Module 1/Media/iPad_02-600x800.png" src="lib\media\ipad_02-600x800.png"><br>Platform: Mobile devices with limited processing power<br>Lighting Techniques:<br>
<br>Fully baked lighting using pre-calculated lightmaps
<br>Ambient occlusion baked into textures for depth
<br>Color as light - vibrant palettes implying illumination
<br>Fixed camera angles enabling efficient pre-rendering
<br>Optimization Strategies:<br>
<br>Static environments allowing complete pre-calculation
<br>Minimal dynamic lights - focus on artistic gradients
<br>Simplified shadow systems maintaining visual appeal
<br>üé® Key Achievements

<br>Dreamlike aesthetic achieved through artistic lighting choices
<br>Consistent 60fps performance on low-power mobile hardware
<br>Iconic visual style through color and lighting harmony

<br><br><br><br><br>Control: Maximum realism and immersion through cutting-edge technology Monument Valley: Artistic expression within strict technical constraints<br><br><br><img alt="150518_r26517.webp" src="lib\media\150518_r26517.webp"><br><br><br>Procedural Systems Integration:<br>
<br>Terrain generation using noise algorithms and mathematical functions
<br>Modular asset placement - trees, rocks, buildings from reusable components
<br>Atmospheric systems procedurally determining weather and lighting
<br>Creature generation combining modular parts with behavioral rules
<br>Node-Based Implementation:<br>
<br>Hierarchical rule systems governing planetary characteristics
<br>Biome definitions using environmental parameters
<br>Consistent art direction through carefully crafted base rules
<br>üîó Technical Deep Dive <a data-tooltip-position="top" aria-label="https://www.rambus.com/blogs/the-algorithms-of-no-mans-sky-2/" rel="noopener nofollow" class="external-link" href="https://www.rambus.com/blogs/the-algorithms-of-no-mans-sky-2/" target="_blank">The Algorithms of No Man's Sky</a><br><br><br><br><br>Step 1: Modular Asset Creation<br>
<br>Design 3-5 base tree models with LOD variants
<br>Create modular rock and debris pieces
<br>Develop reusable ground textures and materials
<br>Step 2: Procedural Distribution<br>
<br>Noise-based placement for natural tree distribution
<br>Slope constraints preventing trees on steep terrain
<br>Clustering rules creating realistic forest patterns
<br>Step 3: Lighting Integration<br>
<br>Dynamic sunlight filtering through procedural canopy
<br>Dappled shadow patterns from leaf transparency
<br>Color temperature shifts in forest clearings vs. dense areas
<br>Step 4: Performance Optimization<br>
<br>Instancing for repeated tree geometry
<br>LOD switching based on distance and importance
<br>Selective shadow casting for performance balance
<br>‚ú® Result Infinite forest variations with consistent artistic vision, optimal performance, and compelling lighting atmosphere.<br><br><br>üéØ Industry Resources

<br><a data-tooltip-position="top" aria-label="https://www.tech-artists.org/" rel="noopener nofollow" class="external-link" href="https://www.tech-artists.org/" target="_blank">Tech-Artists.org</a> - Professional community
<br><a data-tooltip-position="top" aria-label="https://www.gdcvault.com/" rel="noopener nofollow" class="external-link" href="https://www.gdcvault.com/" target="_blank">GDC Vault</a> - Industry talks and presentations
<br><a data-tooltip-position="top" aria-label="https://www.realtimerendering.com/" rel="noopener nofollow" class="external-link" href="https://www.realtimerendering.com/" target="_blank">Real-Time Rendering</a> - Technical reference
<br><a data-tooltip-position="top" aria-label="https://www.pcgbook.com/" rel="noopener nofollow" class="external-link" href="https://www.pcgbook.com/" target="_blank">Procedural Content Generation Book</a> - Comprehensive PCG guide

<br><br><br><br>
<br>AI-assisted content generation automating repetitive tasks
<br>Machine learning optimization for lighting and performance
<br>Real-time ray tracing becoming standard across platforms
<br><br>
<br>Cloud computing enabling complex procedural generation
<br>Cross-platform development demanding flexible optimization
<br>User-generated content requiring robust modular systems
<br><br>
<br>Accessibility-first lighting ensuring visual clarity for all players
<br>Sustainable development optimizing for energy efficiency
<br>Procedural diversity supporting inclusive content creation
<br><br><br>üí≠ Course Integration Questions
Personal Development:

<br>Which concepts most challenge your current thinking about game development?
<br>How will you apply procedural thinking to your future projects?
<br>What lighting techniques most excite you for creative exploration?

Professional Application:

<br>How do these technical art concepts change your understanding of game development pipelines?
<br>What skills will you prioritize developing further?
<br>How might you contribute to a game development team using these concepts?

<br><br><br>Module 1 establishes the foundation for advanced technical art topics. The integration of procedural workflows, lighting systems, and systematic thinking prepares you for complex game development challenges.<br>Next modules will build on these fundamentals: advanced shader development, VFX systems, and specialized technical art applications.<br>üìç Module 1 Complete

<br>Module 1A: Game Feel and Tactile Experience ‚úì
<br>Module 1B: Procedural Workflows Introduction ‚úì
<br>Module 1C: Node-Based Systems and Advanced Techniques ‚úì
<br>Module 1D: Lighting Fundamentals and Technical Systems ‚úì
<br>Module 1E: Color Theory and Advanced Lighting ‚úì
<br>Module 1F: Case Studies and Practical Implementation ‚úì

<br><br>üß≠ Module Navigation
 Previous: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1E - Color Theory and Advanced Lighting" data-href="GMAP 395 - Module 1E - Color Theory and Advanced Lighting" href="gmap-395\module-1\submodules\gmap-395-module-1e-color-theory-and-advanced-lighting.html" class="internal-link" target="_self" rel="noopener nofollow">Module 1E</a><br>
Next: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Module 2</a><br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\module-1\submodules\gmap-395-module-1f-case-studies-and-practical-implementation.html</link><guid isPermaLink="false">GMAP 395/Module 1/submodules/GMAP 395 - Module 1F - Case Studies and Practical Implementation.md</guid><pubDate>Wed, 02 Jul 2025 18:32:29 GMT</pubDate><enclosure url="lib\media\6492c4ab6751d8f29f5e4826_launch_screenshot_101-p-500.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\6492c4ab6751d8f29f5e4826_launch_screenshot_101-p-500.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Assignment 1: Procedural Game Art and Lighting Systems]]></title><description><![CDATA[ 
 <br><br><br>Assignment Overview  
In this assignment, students will:

<br>Create a procedural game asset in a DCC tool of their choice (e.g., Blender, Houdini, Unity).
<br>Import this asset into Unity to design and implement a lighting system that complements the asset's visual and thematic qualities.
<br>Ensure the asset and lighting align with the class theme: <a data-tooltip-position="top" aria-label="GMAP 395 - SU25 - Theme" data-href="GMAP 395 - SU25 - Theme" href="gmap-395\gmap-395-su25-theme.html" class="internal-link" target="_self" rel="noopener nofollow">"So What About Tomorrow?"</a>.
<br>Present their work within a Unity scene via Video Recording; and also produce a README file documenting their process and a recorded video explaining their approach.

<br><br><br>Assignment Breakdown

<br>Part 1: Procedural Game Art <br>
Create a procedural asset using a DCC software like Blender or Houdini. The asset must reflect the <a data-href="GMAP 395 - SU25 - Theme" href="gmap-395\gmap-395-su25-theme.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - SU25 - Theme</a>.<br>

<br>Part 2: Lighting Systems in Unity <br>
Import the procedural asset into Unity, set up a lighting system that complements the theme and enhances its presentation.<br>


<br><br><br><br>How to Approach the Theme  
The theme So What About Tomorrow? is intentionally open-ended. Interpret it creatively‚Äîexamples include:

<br>Technological Speculation: Future tools, interfaces, or environments.
<br>Temporal Archaeology: Past technologies reimagined or rediscovered.
<br>Evolution and Change: Transformation processes over time.

<br><br><br>Key Steps for Part 1

<br>Choose a DCC software like Blender, Houdini, or Maya.

<br>The tutorial for part 1 of this module uses Blender Geometry Nodes


<br>Use procedural techniques/operations and a node-based workflow to create or modify a game art asset.
<br>Ensure the asset embodies the class theme.
<br>Export the asset to a format suitable for Unity (e.g., .fbx, .obj).

<br>Example Ideas for Procedural Assets

<br>A futuristic interface that evolves over time.
<br>Ancient technology being reclaimed by nature.
<br>A structure showing multiple temporal states simultaneously.

<br><br><br>Key Steps for Part 2

<br>Import your procedural asset into Unity.
<br>Set up a lighting system that complements the theme and highlights your asset:

<br>Use at least one directional light to simulate natural or artificial light.
<br>Add secondary lights (spotlights, area lights, etc.) for mood and detail.


<br>Design the scene to enhance the asset‚Äôs presentation within the theme.

<br>Lighting Design Tips

<br>Think about how lighting enhances temporal concepts (e.g., contrasts between old and new, revelation of hidden details).
<br>Experiment with lighting that suggests the passage of time or technological evolution.

<br><br><br>What to Submit

<br>Procedural Asset Source File:

<br>Upload your DCC project file (e.g., .blend, .hip, .mb) to show procedural workflows.


<br>README File:

<br>Create a README file in TXT or Markdown format that explains your work.
<br>Include:

<br>A description of your procedural asset and its thematic inspiration.
<br>Details of your lighting setup in Unity.
<br>Any challenges you faced and how you solved them.




<br>Recorded Video (5‚Äì10 Minutes):

<br>Record a video that breaks down your design process (use screen recording software like OBS).
<br>The video must cover:

<br>Procedural Operations: Explain how you created your procedural game asset.
<br>Lighting Setup: Discuss your lighting choices in Unity, including tools and techniques used.
<br>Theme Alignment: Reflect on how your work ties into So What About Tommorow?.





<br>README Example Format
# Assignment 1: Procedural Game Art and Lighting Systems

## Procedural Asset
- Software Used: Blender  
- Description: A modular crystal formation inspired by black holes, procedurally generated using Geometry Nodes.

## Unity Lighting Setup
- Lighting Design: Directional light for a natural glow, spotlights for eerie highlights.  
- Post-Processing: Enabled bloom and vignette for a mystical, void-like effect.

## Challenges
- Issue: Balancing the asset‚Äôs high-detail geometry for real-time performance.  
- Solution: Reduced polygon count and baked high-resolution normals.  

<br><br>Submission Guidelines

<br>Submission Format: Upload your project as a ZIP file to Drexel Learn.
<br>File Naming Convention: abc123_Lastname_Firstname_A1.zip.
<br>Late submissions will incur a 10% penalty per day.

<br><br><br>By completing this assignment, you will:

<br>Understand and apply procedural workflows to create modular assets.
<br>Develop an artistic vision aligned with the theme.
<br>Gain technical skills in importing assets into Unity and optimizing them for real-time use.
<br>Explore Unity‚Äôs lighting systems to design atmospheric and visually appealing scenes.
<br>Develop an iterative workflow for asset creation, scene design, and troubleshooting.

<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\gmap-395-asn-1-brief.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - ASN 1 - Brief.md</guid><pubDate>Wed, 02 Jul 2025 18:30:04 GMT</pubDate></item><item><title><![CDATA[Critique Brief: Project Vision &amp; Preproduction Planning]]></title><description><![CDATA[ 
 <br><br>Overview 
Purpose: Develop your quarter-long project concept through thematic exploration, skill goal-setting, and procedural thinking<br>
Format: Individual presentation (3-4 minutes) + peer feedback<br>
Due: Week 2 class session
<br><br><br>This week's critique focuses on preproduction planning - the critical thinking and research phase that sets up successful projects. You'll present your initial project vision by connecting the course theme with your personal learning goals and procedural thinking approach.<br><br><br><br>Write 2-3 sentences explaining your personal interpretation of the course theme.<br>Consider questions like:<br>
<br>What aspect of the theme interests you most?
<br>What mood or feeling do you want to convey through your work?
<br>How does the theme connect to your personal interests or artistic vision?
<br><br>Gather visual references that inspire your interpretation of the course theme.<br>Reference Categories to Consider:<br>
<br>Games: Environments, interfaces, characters that connect to the course theme
<br>Film/TV: Production design, visual effects, cinematography relevant to the theme
<br>Architecture: Design approaches that relate to thematic concepts
<br>Technology: Concept art, industrial design, interface design
<br>Art/Design: Any visual work that explores the course theme or related concepts
<br>Strategic Selection Criteria:<br>
<br>Procedural Potential: Look for elements that seem like they could be created through rules or algorithms
<br>Modular Possibilities: Identify systems that appear to be built from reusable components
<br>*Technical Interest: Choose references that connect to skills you want to develop*
<br><br><br><br>Identify 2-3 specific technical art skills you want to develop this quarter.<br>Skill Categories to Consider:<br>
<br>Procedural Modeling: Geometry nodes, algorithmic content creation, automated workflows
<br>Lighting Systems: Dynamic lighting, atmosphere creation, cinematic techniques
<br>Shader Development: Custom materials, interactive surfaces, visual effects
<br>Particle Systems: Environmental effects, interactive dynamics, performance optimization
<br>Camera &amp; Post-Processing: Cinematic presentation, interactive cameras, visual polish
<br>For Each Skill Goal, Consider:<br>
<br>Why does this skill interest you?
<br>How does it connect to your theme interpretation?
<br>What specific aspect or technique do you want to explore?
<br>How might this skill appear in your final project?
<br><br><br><br>Based on your theme interpretation and skill goals, propose a preliminary project concept.<br>Consider the Final Project Requirements:<br>
<br>Interactive Scene: Unity-based experience showcasing your chosen module specialization
<br>Module Focus: Which of the four modules (Modeling+Lighting, Shaders, Effects, Camera) most interests you for deep exploration?
<br>Integration: How will all four modules work together in your scene?
<br>Project Scope Questions:<br>
<br>What type of environment, object, or experience do you want to create?
<br>How will players interact with your scene?
<br>What story or concept will your technical choices communicate?
<br>How ambitious is this vision for an 11-week timeline?
<br><br><br><br>Choose one aspect of your project concept and break it down into procedural steps.<br>Process:<br>
<br>
Identify a System: Pick one element that could benefit from procedural/algorithmic approaches (e.g., environment generation, material variation, particle behavior, camera movement)

<br>
Map the Logic: Write out the step-by-step process in "pseudocode" or simple logic:
Example: Abandoned Tech Panel System
- Start with: Base wall surface
- Add: Grid of potential panel locations
- Rule: 70% chance each location gets a panel
- If panel: Choose from 3 panel types randomly
- If damaged: Add rust/wear based on proximity to water sources
- Add: Flickering lights with 30% failure rate


<br>
Consider Interactions: How might player interaction or environmental changes affect this system?

<br>Alternative Examples:<br>
<br>Material Aging: How surfaces change over time based on use patterns
<br>Lighting Transitions: Rules for day/night cycles or mood changes
<br>Particle Responses: How effects react to player presence or environmental triggers
<br>Camera Behavior: Logic for focusing on points of interest or following player actions
<br><br><br><br>Present your preproduction research covering:<br>
<br>Theme Interpretation

<br>Show 3-4 key mood board references
<br>Explain your personal interpretation of the course theme


<br>Skill Goals

<br>Share your 2-3 technical development objectives
<br>Connect them to your theme and references


<br>Project Concept

<br>Describe your preliminary project vision
<br>Explain which module you're most interested in specializing in
<br>Show how theme, skills, and concept connect


<br>Procedural Thinking

<br>Walk through your logic flow exercise
<br>Explain the system you mapped out and why


<br><br>Using the <a data-tooltip-position="top" aria-label="https://www.bitesizelearning.co.uk/resources/six-thinking-hats-technique#:~:text=The classic Six Thinking Hats,of perspectives to be heard." rel="noopener nofollow" class="external-link" href="https://www.bitesizelearning.co.uk/resources/six-thinking-hats-technique#:~:text=The%20classic%20Six%20Thinking%20Hats,of%20perspectives%20to%20be%20heard." target="_blank">Six Thinking Hats method</a>, provide feedback from different perspectives:<br>‚ö™ White Hat - Facts &amp; Information<br>
<br>What additional references, techniques, or research might help?
<br>Are there specific technical resources or examples to suggest?<br>
üî¥ Red Hat - Emotional Response
<br>What's your gut reaction to this project concept?
<br>What excites or concerns you about this direction?<br>
‚ö´ Black Hat - Critical Analysis
<br>What potential challenges or risks do you see?
<br>Are there technical or scope limitations to consider?<br>
üíõ Yellow Hat - Positive Assessment
<br>What strengths and opportunities does this concept offer?
<br>How does this approach play to the presenter's interests or skills?<br>
üîµ Blue Hat - Process &amp; Structure
<br>Is the project concept clear and well-organized?
<br>How effectively do the theme, skills, and technical approach connect?<br>
üü¢ Green Hat - Creative Alternatives
<br>What creative variations or alternative approaches could be explored?
<br>How might this concept be pushed further or in unexpected directions?
<br><br><br><br>
<br>Research Quality: Thoughtful selection and variety of references
<br>Self-Reflection: Clear articulation of learning goals and interests
<br>Planning Depth: Evidence of strategic thinking about project scope and approach
<br><br>
<br>Theme Connection: Strong personal interpretation of the course theme
<br>Technical Integration: Realistic and specific connection between skills and concept
<br>Project Viability: Appropriate scope and clear direction for quarter-long development
<br><br>
<br>Logic Clarity: Clear breakdown of systematic/algorithmic thinking
<br>Creative Application: Innovative or thoughtful approach to procedural solutions
<br>Implementation Potential: Realistic understanding of how logic could be executed
<br><br><br><br>
<br>Mood board: 10+ references organized thematically
<br>Written summary: Theme interpretation + skill goals + project concept (1 page max)
<br>Logic flow diagram: Visual or written breakdown of one procedural system
<br><br>
<br>Post your materials in your individual thread for feedback
<br>Include any questions about technical implementation or project scope
<br>Respond to *3*** peer posts with constructive feedback and suggestions
<br><br><br>Based on this week's presentations, we'll dive into procedural modeling fundamentals and begin developing the technical skills you've identified. Come prepared to start building!<br>Next Steps:<br>
<br>Refine your project concept based on feedback
<br>Begin gathering technical references for your chosen specialization
<br>Prepare questions about procedural modeling techniques
<br><br>Success Tips

<br>Be specific rather than vague about your goals and concepts
<br>Connect everything - theme, skills, and project should reinforce each other
<br>Think systematically - break complex ideas into manageable procedural steps
<br>Stay curious - use this as an opportunity to explore new directions

<br>Navigation 
Return to: <a data-href="GMAP 395 - Introduction and Overview" href="gmap-395\introduction\gmap-395-introduction-and-overview.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Introduction and Overview</a><br>
Return to: <a data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Welcome</a><br>
See: <a data-tooltip-position="top" aria-label="Six Thinking Hats Giving Good Game Design Feedback" data-href="Six Thinking Hats Giving Good Game Design Feedback" href="gmap-395\weeklies\six-thinking-hats-giving-good-game-design-feedback.html" class="internal-link" target="_self" rel="noopener nofollow">üé© Six Thinking Hats: Giving Good Game Design Feedback</a>
]]></description><link>gmap-395\weeklies\gmap-395-weekly-1.html</link><guid isPermaLink="false">GMAP 395/Weeklies/GMAP 395 - Weekly - 1.md</guid><pubDate>Wed, 02 Jul 2025 18:02:18 GMT</pubDate></item><item><title><![CDATA[üé© Six Thinking Hats: Giving Good Game Design Feedback]]></title><description><![CDATA[ 
 <br><br>The Six Thinking Hats method helps provide structured and meaningful feedback. Instead of just saying, ‚ÄúI like this‚Äù or ‚ÄúThis part is bad‚Äù, this method encourages you to analyze different aspects of the project from multiple perspectives.<br>Each hat represents a different way of thinking about a certain topic/idea, even about your own or another's game! You don‚Äôt need to use every hat in every response, but using at least three will make your feedback more valuable.<br><br><br>
üßê What are the objective facts about the project?
<br>
<br>What engine and tools are being used?
<br>What mechanics or interactions are already implemented?
<br>What is the current progress based on the assignment requirements?
<br>‚úÖ Example:<br>
"This project is using Unity with Shader Graph for post-processing effects. The main interaction involves triggering particle effects when the player approaches the artifact."<br><br><br>
‚ù§Ô∏è What is your emotional reaction?
<br>
<br>How does the game or visual style make you feel?
<br>Does the atmosphere match the intended theme?
<br>Is there a sense of excitement, mystery, or immersion?
<br>‚úÖ Example:<br>
"The eerie glow of the procedural artifact really sells the ‚ÄòSomething from the Void‚Äô theme! The lighting gives it a mysterious, almost supernatural feel."<br><br><br>
‚ö†Ô∏è What could be improved?
<br>
<br>What isn‚Äôt working well yet?
<br>Are there technical issues (glitches, lighting problems, unclear mechanics)?
<br>Does anything feel unfinished or confusing?
<br>‚úÖ Example:<br>
"The portal shader effect is cool, but the animation is a bit too fast. Slowing it down might make it feel more mystical."<br><br><br>
üåü What is working well?
<br>
<br>What parts of the project stand out as strong design choices?
<br>What mechanics, visuals, or interactions are impressive?
<br>Does anything feel polished or well-executed?
<br>‚úÖ Example:<br>
"The camera effects are really well done! The depth of field gives a cinematic quality when approaching the artifact."<br><br><br>
üí° What creative suggestions can you offer?
<br>
<br>How could the project be expanded or enhanced?
<br>Are there cool ideas that might fit well with what‚Äôs already there?
<br>What additional effects, interactions, or mechanics could improve the experience?
<br>‚úÖ Example:<br>
"Since your artifact pulses when approached, maybe add an ambient sound effect that gets louder as players get closer?"<br><br><br>
üìå What should be done next?
<br>
<br>What is the biggest priority for improvement?
<br>Are there missing elements that need to be added?
<br>What should the creator focus on before the next milestone?
<br>‚úÖ Example:<br>
"The next step could be refining the lighting and adjusting the post-processing settings. Maybe add a slight vignette effect to enhance the void-like atmosphere?"<br><br><br>When giving feedback, use at least three hats to provide a balanced response. Example structure:<br>Feedback for [Student + Project Name]

What‚Äôs working well? 
- The glowing edges on the artifact are really effective at drawing attention.  

What could be improved?  
- The shader animation is a bit too fast; slowing it down might add more mystery.  

Creative suggestion:  
- What if you added a slight distortion effect around the artifact, like it‚Äôs warping space around it?  
<br>Remember: Your feedback should be specific and constructive‚Äîhelp your peers refine their projects!<br><br>]]></description><link>gmap-395\weeklies\six-thinking-hats-giving-good-game-design-feedback.html</link><guid isPermaLink="false">GMAP 395/Weeklies/Six Thinking Hats Giving Good Game Design Feedback.md</guid><pubDate>Wed, 02 Jul 2025 17:58:47 GMT</pubDate></item><item><title><![CDATA[Procedural Modeling with Modular Thinking - A Beginner's Guide]]></title><description><![CDATA[ 
 <br><br><br>Procedural modeling means creating geometry through systematic, repeatable processes rather than manually placing every vertex. This approach excels in game development where you need efficient workflows, consistent results, and the ability to iterate quickly.<br>This guide teaches modular thinking - breaking complex forms into simple, reusable components that combine into sophisticated systems. While examples use Blender's Geometry Nodes, these principles apply to any procedural modeling tool.<br>How This Connects:
This guide pairs with the <a data-tooltip-position="top" aria-label="GMAP 395 - Guide - CT and CPS" data-href="GMAP 395 - Guide - CT and CPS" href="gmap-395\gmap-395-guide-ct-and-cps.html" class="internal-link" target="_self" rel="noopener nofollow">Critical Thinking and Creative Problem-Solving</a> - the systematic problem-solving approaches there apply directly to procedural modeling challenges, while working through geometry problems reinforces those thinking patterns.
<br>Example File üìÅ
Below is a link to download the blender file used for the short concept demo videos in this guide. It has all of the geometry nodes and obejcts labeled by chapter number i.e. 2.1 - Wall<br>
<a data-tooltip-position="top" aria-label="https://1drv.ms/u/c/b08de2251f1b33a4/EW7K_KEbB-ZAjmKnlqxON4QBNv5zooAmg0e5PpGnMCV_6Q?e=9gv9IN" rel="noopener nofollow" class="external-link" href="https://1drv.ms/u/c/b08de2251f1b33a4/EW7K_KEbB-ZAjmKnlqxON4QBNv5zooAmg0e5PpGnMCV_6Q?e=9gv9IN" target="_blank">procGenGuide.blend</a>
<br><br><br><br><br>üéØ Problem/Goal: When should you choose procedural approaches over traditional modeling?<br>Key Decision Point Ask yourself: "Will I need multiple variations of this, or will it change frequently during development?"<br><br><br><br><br>Building System Breakdown 
Manual approach:

<br>Model walls, roof, windows individually (3 days)
<br>Copy and modify for 5 variations (2 more days)
<br>Client wants changes (start over: 2+ days)

Procedural approach:

<br>Define parameter system (4 days)
<br>Generate 50 variations (instant)
<br>Client changes (adjust parameters: hours)

<br>When to Choose Procedural ‚úÖ Need multiple variations ‚úÖ Expect frequent changes  
‚úÖ Repetitive patterns involved ‚úÖ Performance optimization needed
‚ùå One-off hero assets ‚ùå Highly organic, unique forms ‚ùå Tight deadline with simple needs
<br><br><br><br>
<br>üîß Full Procedural: Everything generated from parameters
<br>üé® Template-Based: Manual base with procedural variations
<br>üîÑ Hybrid Workflow: Manual hero pieces, procedural background
<br>Essential Tools

<br><a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/index.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/index.html" target="_blank">Blender Geometry Nodes</a>
<br><a data-tooltip-position="top" aria-label="https://www.sidefx.com/learn/" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/learn/" target="_blank">Houdini</a>
<br><a data-tooltip-position="top" aria-label="https://knowledge.autodesk.com/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/ENU/Maya-CharacterAnimation/files/GUID-3CB2B4B3-9F8E-4E99-8210-CC4AE5CDA31C-htm.html" rel="noopener nofollow" class="external-link" href="https://knowledge.autodesk.com/support/maya/learn-explore/caas/CloudHelp/cloudhelp/2018/ENU/Maya-CharacterAnimation/files/GUID-3CB2B4B3-9F8E-4E99-8210-CC4AE5CDA31C-htm.html" target="_blank">Maya MASH</a>

<br><br>Identify procedural opportunities in your current project:<br>
<br>What gets repeated with variations?
<br>What might change during development?
<br>Where do you spend time on repetitive tasks?
<br>Success Metric You can quickly evaluate whether a modeling task would benefit from procedural approaches and explain the trade-offs.<br><br><br><br>üéØ Problem/Goal: Building complex systems from simple, reusable components.<br><br><br><br><br>System Implementation 
Geometry Nodes hierarchy:

<br>Wall Component: length, height ‚Üí wall geometry
<br>Building Component: uses walls, adds roof_type, door_count
<br>District Component: arranges buildings with spacing, variety
<br>Village Component: combines districts with roads and features

<br>Modular Design Principles

<br>Single Responsibility: Each component does one thing well
<br>Composability: Components combine in predictable ways
<br>Parameterization: Expose the right level of control
<br>Documentation: Clear naming and organization

<br><br><br><br>
<br>üèóÔ∏è Hierarchical Systems: Clear levels of complexity
<br>üï∏Ô∏è Network Systems: Flexible component connections
<br>üìã Template Systems: Pre-built arrangements with variation
<br>Modular Pitfalls

<br>Over-engineering simple tasks
<br>Creating too many parameters (analysis paralysis)
<br>Losing artistic control to systems
<br>Ignoring performance implications

<br><br>Apply modular thinking to non-geometry systems:<br>
<br>UI System: Buttons ‚Üí Panels ‚Üí Screens ‚Üí Full Interface
<br>Animation Rig: Controls ‚Üí Sub-systems ‚Üí Character ‚Üí Scene
<br>Material Library: Textures ‚Üí Shaders ‚Üí Material Sets ‚Üí Environment
<br>Success Metric You naturally think in terms of reusable components and can design systems that others can understand and extend.<br><br><br><br><br>üéØ Problem/Goal: Understanding the building blocks of all geometry.<br><br><br><br><br>Wall Component Setup
 In Geometry Nodes:

<br>Cube Primitive ‚Üí base shape
<br>Transform: Scale X (length), Z (height), Y (thickness)
<br>Set Origin: Bottom center for ground placement (set position offset)
<br>Distribute Points on Faces: End faces for connections
<br>Instance Cubes: Small connection indicators

<br>Concept Demo Video üìπ
<a data-tooltip-position="top" aria-label="https://1drv.ms/v/c/b08de2251f1b33a4/ERL47mcntPxJlFRbvcZ46SUBX3-JJKYBapzzIc7oqFNUFQ?e=agdBNx" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/c/b08de2251f1b33a4/ERL47mcntPxJlFRbvcZ46SUBX3-JJKYBapzzIc7oqFNUFQ?e=agdBNx" target="_blank">gmap395_g_pm_2.1.mp4</a>
<br>Transform Best Practices

<br>Consistent Origins: Decide on pivot standards for your project
<br>Parameter Ranges: Set min/max values that make sense
<br>Local vs. World: Understand coordinate system implications
<br>Non-Destructive: Keep original proportions accessible

<br><br><br><br>
<br>üìê Mathematical Generation: Create primitives from formulas
<br>üìç Point-Based Construction: Build from vertex positions
<br>üé® Profile-Based: Extrude shapes from 2D curves
<br>Geometry Nodes Primitives

<br>Cube - Basic box primitive
<br>Cylinder - Radial geometry
<br>Sphere - Subdivided sphere (UV or Icosphere)
<br>Grid - Plane with subdivisions

<br><br>Create modular primitives for specific art styles:<br>
<br>Cyberpunk: Angular, tech-heavy base shapes
<br>Organic Forest: Curved, natural-form primitives
<br>Minimalist: Clean, simple geometric bases
<br>Success Metric You can quickly generate appropriate base geometry and transform it systematically for different contexts.<br><br><br><br>üéØ Problem/Goal: Growing 2D shapes into 3D forms and adding surface detail.<br><br><br><br><br>Window Frame Process 
Geometry Nodes workflow:

<br>Select Faces: Choose wall faces for windows
<br>Inset Faces: Create window frame border (0.1m)
<br>Extrude Faces: Push inward for depth (-0.05m)
<br>Inset Faces (inverse extrude): Inner frame detail (0.02m)
<br>Delete Geometry: Remove center faces for opening

<br>Concept Demo Video üìπ
<a data-tooltip-position="top" aria-label="https://1drv.ms/v/c/b08de2251f1b33a4/EU0O-Ifre0RKp5aDMt73VAwBVugbBvb8iC6UwTSvcA8hDQ?e=06d7jE" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/c/b08de2251f1b33a4/EU0O-Ifre0RKp5aDMt73VAwBVugbBvb8iC6UwTSvcA8hDQ?e=06d7jE" target="_blank">gmap395_g_pm_2.2.mp4</a>
<br>A Note of Selections in GN
The selection capabilities are somewhat tool specific, it depends greatly on how that particular tool handles geometry data. In Blender GN, selection takes a bit more math or manual work. A hybrid approach of "preprocessing" you geometry and segmenting manually the pieces that need procedural elements is the better approach. With that said, below are some good sources on making selections in GN:<br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=p4rwhifXNCw" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=p4rwhifXNCw" target="_blank">Select What You Want in Geometry Nodes - Blender Tutorial</a><br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=BTFD1fnTVtk&amp;t=303s" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=BTFD1fnTVtk&amp;t=303s" target="_blank">Where to Begin in Geometry Nodes: Selections</a>
<br>Surface Detail Strategy

<br>Primary forms first: Establish main shapes before details
<br>Consistent depth: Use similar inset/extrude values across project
<br>Normal direction: Understand inside vs. outside faces
<br>Edge flow: Maintain good topology for further operations

<br><br><br><br>
<br>üìè Linear Extrusion: Straight path, constant profile
<br>üéØ Path Following: Profile follows curve
<br>üîÑ Adaptive Profile: Shape changes along path
<br>Extrusion Gotchas

<br>Normal direction: Pay attention to face orientation
<br>Topology complexity: Too many operations create messy geometry
<br>Scale sensitivity: Large scale differences can cause issues
<br>Boolean preparation: Clean geometry for later operations

<br><br>Apply extrusion thinking to character/vehicle design:<br>
<br>Armor pieces: Layered protection with depth
<br>Vehicle panels: Surface detail and functional elements
<br>Weapon design: Grip details, decorative elements
<br>Success Metric You can efficiently add surface detail that enhances form while maintaining clean, workable topology.<br><br><br><br>üéØ Problem/Goal: Combining and cutting shapes to create complex forms.<br><br><br><br><br>Boolean Window System 
Setup process:

<br>Base wall geometry (from previous examples)
<br>Create cutout shapes (rectangles for windows/doors)
<br>Position with parameters (height, spacing, count)
<br>Instance on Points to place multiple cutouts
<br>Realize Instances to convert to geometry
<br>Boolean Union to combine all cutouts
<br>Boolean Difference final cutouts from wall

<br>Concept Demo Video üìπ
<a data-tooltip-position="top" aria-label="https://1drv.ms/v/c/b08de2251f1b33a4/EU4nnovT-FxOs0LysLrkIOwBUx-T-ezlLUdatMG5iEZUMg?e=zQTF4Q" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/c/b08de2251f1b33a4/EU4nnovT-FxOs0LysLrkIOwBUx-T-ezlLUdatMG5iEZUMg?e=zQTF4Q" target="_blank">gmap395_g_pm_2.3.mp4</a>
<br>Boolean Best Practices

<br>Clean input geometry: No overlapping faces, good normals
<br>Appropriate resolution: Match detail levels between objects
<br>Order of operations: Union small pieces before main subtraction
<br>Fallback plans: Have manual alternatives for complex cases

<br><br><br><br>
<br>üîß Direct Boolean: Use boolean operations throughout
<br>‚úÇÔ∏è Manual Cutting: Use traditional modeling tools
<br>üé® Displacement: Use textures to fake surface details
<br>Boolean Limitations

<br>Topology mess: Can create n-gons and poor edge flow
<br>Performance cost: Complex booleans are computationally expensive
<br>Precision issues: Floating-point errors with very small/large objects
<br>Art direction: May not give desired aesthetic control

<br>Boolean Alternatives When booleans don't work well:

<br>Knife Project: Cut along edges manually
<br>Displacement Maps: Fake depth with textures
<br>Separate Objects: Model pieces individually, assemble visually

<br><br>Use boolean thinking for prop/mechanical design:<br>
<br>Complex machinery: How would you break down a vehicle engine?
<br>Architectural details: Gothic cathedral with intricate stonework
<br>Character armor: Layered protection with functional details
<br>Success Metric You understand when booleans are appropriate and can predict potential problems before they occur.<br><br><br><br><br>üéØ Problem/Goal: Efficiently creating repeated elements with controlled variation.<br><br><br><br><br>Fence System Implementation 
Geometry Nodes setup:

<br>Input: Curve path for fence line
<br>Distribute Points on Curve: Even spacing for posts
<br>Instance on Points: Post geometry at each point
<br>Curve to Mesh: Generate panels between posts
<br>Random Value: Add height/rotation variation
<br>Switch: Randomly select from multiple post designs

<br>Concept Demo Video üìπ
<a data-tooltip-position="top" aria-label="https://1drv.ms/v/c/b08de2251f1b33a4/EZqeQxK-EQlLpOsMCnxfhzYBhj8N56oIYGNQpIkhHhXeDA?e=TOc44L" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/c/b08de2251f1b33a4/EZqeQxK-EQlLpOsMCnxfhzYBhj8N56oIYGNQpIkhHhXeDA?e=TOc44L" target="_blank">gmap395_g_pm_3.1.mp4</a>
<br>Array Variation Techniques

<br>Controlled randomness: Use seed values for repeatable results
<br>Natural clustering: Group similar elements with noise
<br>Progressive variation: Gradual changes across array
<br>Rule-based selection: Different elements based on conditions

<br><br><br><br>
<br>üìê Simple Duplication: Basic copy and offset
<br>üéØ Curve Following: Elements follow complex paths
<br>üåç Surface Scattering: Distribution across 3D surfaces
<br>üìä Data-Driven: Arrays controlled by external information
<br>Array Performance Considerations

<br>Instance vs. Copy: Use instances when possible for memory efficiency
<br>LOD Systems: Reduce detail for distant/background elements
<br>Culling: Remove elements outside camera view
<br>Batching: Group similar instances for rendering efficiency

<br><br>Create arrays for different game contexts:<br>
<br>Foliage System: Trees and plants with natural variation
<br>Urban Details: Street lights, signs, traffic elements
<br>Crowd System: Characters with different appearances and behaviors
<br>Success Metric You can create natural-looking patterns that feel random but are actually controllable and repeatable.<br><br><br><br>üéØ Problem/Goal: Managing memory and performance while creating visual variety.<br><br><br><br><br>Rock Scattering System 
Advanced distribution:

<br>Terrain Analysis: Use slope angle to control placement
<br>Density Texture: Paint where rocks should/shouldn't appear
<br>Rock Library: 8 different rock models in 3 size categories
<br>Smart Selection: Larger rocks on steeper slopes
<br>Clustering: Use noise to group rocks naturally
<br>Variation: Random scale (80-120%), rotation, material wear

<br>Concept Demo Video üìπ
<a data-tooltip-position="top" aria-label="https://1drv.ms/v/c/b08de2251f1b33a4/EZak32LBDTxFi5iFdzWtib4B3GyaLFz-B_CTvlMCsq6amA?e=kZAQoZ" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/c/b08de2251f1b33a4/EZak32LBDTxFi5iFdzWtib4B3GyaLFz-B_CTvlMCsq6amA?e=kZAQoZ" target="_blank">gmap395_g_pm_3.2.mp4</a>
<br>Natural Variation Strategies

<br>Size hierarchy: Mix large, medium, small elements
<br>Clustering rules: Group similar items, break uniformity
<br>Environmental logic: Consider how things would naturally occur
<br>Layered randomness: Multiple variation systems working together

<br><br><br><br>
<br>üé≤ Pure Random: Simple random selection
<br>üìä Weighted Selection: Bias toward certain variations
<br>üó∫Ô∏è Map-Driven: Use textures to control placement
<br>üéÆ Gameplay-Responsive: Variation based on player actions
<br>Optimization Techniques Distance-based LOD:

<br>Near: Full detail instances
<br>Medium: Simplified geometry
<br>Far: Billboard sprites or removal

Frustum Culling:

<br>Remove instances outside camera view
<br>Dynamic loading for streaming worlds

<br><br>Design instancing for your game's specific needs:<br>
<br>What repeated elements could benefit from variation?
<br>How would you balance memory vs. visual diversity?
<br>What environmental logic should guide placement?
<br>Success Metric You can create rich, varied environments that perform well and feel naturally distributed rather than obviously systematic.<br><br><br><br><br>üéØ Problem/Goal: Ensuring procedural geometry works well with texturing pipelines.<br><br><br><br><br>UV Workflow for Procedural Buildings 
Geometry Nodes setup:

<br>Material ID Assignment:

<br>Walls get material index 0
<br>Trim/details get index 1
<br>Windows/doors get index 2


<br>UV Generation:

<br>Auto unwrap with angle-based seams
<br>Normalize scale for consistent detail
<br>Apply world-space coordinates for seamless tiling


<br>Optimization:

<br>Pack UVs efficiently
<br>Minimize stretching
<br>Align to texture grids



<br>Concept Demo Video üìπ
<a data-tooltip-position="top" aria-label="https://1drv.ms/v/c/b08de2251f1b33a4/EZMUz4oFugxMqN5rgWwG_IQB2PQM3lkO2v5iOPnzWDgqGw?e=yZ399t" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/c/b08de2251f1b33a4/EZMUz4oFugxMqN5rgWwG_IQB2PQM3lkO2v5iOPnzWDgqGw?e=yZ399t" target="_blank">gmap395_g_pm_4.1.mp4</a>
<br>Procedural UV Tutorials for GN
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=02XNGOVpSV4" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=02XNGOVpSV4" target="_blank">Blender Tutorial: Procedural UV Unwrapping with Geometry Nodes</a><br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=Ubeot7lIvTM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=Ubeot7lIvTM" target="_blank">How to create proper UV Maps with Geometry Nodes in Blender</a>
<br>UV Best Practices for Procedural Work

<br>Consistent texel density: Same detail level across all generated geometry
<br>Predictable seams: Place seams where they won't be noticeable
<br>Tiling-friendly: Consider how textures will repeat
<br>Material zones: Group faces that need similar treatment

<br><br><br><br>
<br>üéØ Manual UV Layout: Traditional unwrapping workflow
<br>üåç Triplanar Mapping: No UVs needed, use world coordinates
<br>üìã Texture Atlasing: Combine multiple textures into single atlas
<br>üìä Procedural Textures: Generate patterns instead of using images
<br>UV Pitfalls

<br>Scale inconsistency: Different texel density across objects
<br>Seam visibility: Poor seam placement ruins illusion
<br>Stretching: Distorted textures from bad UV ratios
<br>Waste: Inefficient UV packing reduces texture resolution

<br>Geometry Nodes UV Tools

<br>UV Unwrap - Automatic unwrapping with various methods
<br>Set Position - Manual UV coordinate control
<br>Store Named Attribute - Save UV data for later use
<br>Sample Texture - Read texture values in node graph

<br><br>Plan UV strategy for a complex procedural system:<br>
<br>Vehicle Customization: How would you handle paint jobs, decals, wear?
<br>Character System: Clothing, skin, accessories with different materials?
<br>Environment Kit: Modular pieces that tile seamlessly?
<br>Success Metric Your procedural geometry textures properly without visible seams or stretching, and maintains consistent quality across variations.<br><br><br><br>üéØ Problem/Goal: Creating procedural systems that work within game engine constraints.<br><br><br><br><br>Mobile Optimization Strategy
Performance targets:

<br>Building cluster: 10,000 triangles maximum
<br>Individual buildings: 500-2,000 triangles based on importance
<br>3 LOD levels per building type

Optimization implementation:

<br>Distance-based LOD: Far buildings become simple boxes
<br>Selective detail: Hero buildings get full budgets
<br>Smart culling: Remove back faces, occluded geometry
<br>Texture sharing: Common materials across building types

<br>Performance Planning

<br>Budget first: Define limits before building systems
<br>Measure early: Profile on target hardware regularly
<br>Graceful degradation: Systems should work at multiple quality levels
<br>User settings: Expose quality options for different devices

<br><br><br><br>
<br>üìê Geometric Optimization: Reduce polygons while maintaining silhouette
<br>üé® Texture Optimization: Use detail textures instead of geometry
<br>‚öôÔ∏è Shader Optimization: Move complexity from geometry to materials
<br>üíæ Streaming: Load/unload content based on proximity
<br>Optimization Traps

<br>Premature optimization: Don't optimize before measuring problems
<br>Over-optimization: Sacrificing too much quality for minor gains
<br>Platform assumptions: Different devices have different bottlenecks

<br>
<br>Ignoring tools: Engine-specific optimizations can be more effective
<br>Profiling Tools

<br>Blender: Statistics panel, vertex count displays
<br>Unity: Profiler, Frame Debugger, Graphics tools
<br>Unreal: Stat commands, GPU Visualizer
<br>Third-party: RenderDoc, Intel GPA, NVIDIA Nsight

<br><br>Optimize an existing asset for a more constrained platform:<br>
<br>What would you prioritize when moving from PC to mobile?
<br>How would you maintain visual quality while cutting resources?
<br>What features could become optional quality settings?
<br>Success Metric You can hit performance targets while maintaining acceptable visual quality, and you understand the trade-offs involved.<br><br><br><br>üéØ Problem/Goal: Moving procedural work from creation tools into game engines effectively.<br><br><br><br><br>Production Pipeline 
Export preparation:

<br>Apply Geometry Nodes: Bake procedural results to mesh
<br>LOD Generation: Create multiple detail levels
<br>Material Baking: Combine complex materials into textures
<br>UV Optimization: Pack efficiently for engine import

Engine integration:

<br>Prefab Setup: Organize components for easy use
<br>Parameter Scripts: Expose key controls to level designers
<br>Documentation: Clear instructions for non-technical users

<br>Pipeline Best Practices

<br>Standardized naming: Consistent conventions across projects
<br>Modular exports: Separate components for flexibility
<br>Version tracking: Clear file organization and change logs
<br>Testing workflow: Regular validation on target platform

<br><br><br><br>
<br>üíæ Full Baking: Export only final geometry, maximum compatibility
<br>üîÑ Hybrid Systems: Some runtime, some baked content
<br>üéÆ Engine-Native: Use engine's built-in procedural tools
<br>‚òÅÔ∏è Server Generation: Generate content remotely, stream to clients
<br>Integration Challenges

<br>Tool differences: Features available in creation tool vs. engine
<br>Performance gaps: Editor performance vs. runtime performance
<br>Team coordination: Different specialists using different tools
<br>Iteration speed: How quickly can changes propagate through pipeline

<br>Engine-Specific Tools Unity:

<br>ProBuilder for runtime geometry creation
<br>Visual Effect Graph for procedural effects
<br>Custom editor tools for designer workflows

Unreal:

<br>Blueprint construction scripts
<br>Procedural mesh component
<br>Material parameter collections

<br><br>Plan integration strategy for your current project:<br>
<br>What needs to be procedural vs. baked?
<br>How will non-technical team members interact with the system?
<br>What performance requirements must the pipeline meet?
<br>Success Metric You have a smooth workflow from creation tool to game engine that supports both iteration speed and final performance requirements.<br><br><br><br><br>üéØ Problem/Goal: Building complete environment systems using procedural approaches.<br><br><br><br><br>Village System Implementation 
Master control parameters:

<br>Village size (small/medium/large)
<br>Prosperity level (poor/modest/wealthy)
<br>Defensive needs (peaceful/fortified/military)
<br>Cultural style (generic/regional variants)

System hierarchy:

<br>Terrain Foundation: Generate or import landscape
<br>Road Network: Main paths connecting to outside world
<br>Lot Division: Parcels for different building types
<br>Building Placement: Procedural architecture with variations
<br>Infrastructure: Wells, market areas, defensive walls
<br>Detail Layer: Props, vegetation, wear patterns
<br>Atmosphere: Lighting, particle effects, ambient details

<br>Environment System Design

<br>Hierarchical dependency: Each level builds on the previous
<br>Cultural consistency: All elements should feel like they belong together
<br>Functional logic: Consider how people would actually use the space
<br>Performance scaling: System should work at different quality levels

<br><br><br><br>
<br>üß© Kit-of-Parts: Pre-made pieces arranged procedurally
<br>üå± Full Procedural: Everything generated from parameters
<br>üìã Template-Based: Hand-crafted layouts with procedural variation
<br>üé® Artist-Directed: Procedural tools guided by manual art direction
<br>Environment System Pitfalls

<br>Uncanny valley: Systems that feel too perfect or systematic
<br>Performance scaling: Complex systems that don't optimize well
<br>Art direction loss: Procedural systems overriding artistic vision
<br>Iteration difficulty: Systems so complex they become hard to modify

<br><br>Plan environment system for your game concept:<br>
<br>What are the core environmental elements?
<br>How would you ensure variety while maintaining consistency?
<br>What level of procedural generation vs. manual art direction makes sense?
<br>Success Metric You can create compelling, believable environments that feel hand-crafted but benefit from procedural efficiency and variation.<br><br><br><br>üéØ Problem/Goal: Applying procedural thinking to smaller-scale asset creation.<br><br><br><br><br>Weapon Customization System 
Component breakdown:

<br>Base Type: Determines overall weapon category and stats
<br>Handle System: Length affects reach, material affects durability
<br>Blade/Head: Shape affects damage type, size affects power
<br>Detail Elements: Decorative pieces, engravings, gems
<br>Wear System: Usage-based deterioration and battle damage

Procedural features:

<br>Auto-fitting: Components adjust to work together properly
<br>Style consistency: Decoration follows cultural/material themes
<br>Performance integration: Visual choices affect gameplay stats
<br>Wear progression: Procedural damage accumulation over time

<br>Prop Procedural Guidelines

<br>Clear use cases: Not every prop benefits from procedural generation
<br>Art direction respect: Systems should enhance, not replace, artistic vision
<br>Performance awareness: Complex systems for simple props can be overkill
<br>User experience: If designers will use it, make it intuitive

<br><br><br><br>
<br>üéØ Full Procedural: Everything parameterized and generated
<br>üß© Modular Manual: Hand-made pieces, procedural arrangement
<br>üìã Template Customization: Base designs with procedural variation
<br>üé® Artist-Guided Procedural: Procedural tools controlled by manual art direction
<br>Prop Procedural Tools Blender:

<br>Geometry Nodes for component assembly
<br>Material nodes for surface variation
<br>Particle systems for detail distribution

Game Engines:

<br>Runtime component swapping
<br>Shader parameter variation
<br>Physics-based wear simulation

<br><br>Identify procedural opportunities in your asset pipeline:<br>
<br>What asset types get repeated with variations?
<br>Where do you spend time on manual, repetitive tasks?
<br>What would benefit from player or designer customization?
<br>Success Metric You can identify when procedural approaches add value to prop creation and implement systems that enhance rather than complicate the creative process.<br><br><br><br>How critical thinking enhances procedural modeling:<br>
<br>Problem decomposition helps break complex geometry challenges into manageable systems
<br>Research skills help you find and adapt techniques from different domains
<br>Iterative approaches let you test and refine procedural systems efficiently
<br>Documentation practices help you build reusable procedural libraries
<br>How procedural projects develop problem-solving skills:<br>
<br>Systematic thinking becomes second nature when building modular systems
<br>Parameter relationships teach cause-and-effect reasoning
<br>Debugging procedural systems builds logical troubleshooting skills
<br>Optimization constraints force creative problem-solving within limits
<br>Building Your Personal Toolkit

<br>Start with simple systems and gradually increase complexity
<br>Build libraries of reusable components and techniques
<br>Document your successful approaches for future projects
<br>Study how others solve similar challenges and adapt their methods

<br>Next Steps for Continued Learning

<br>Practice these concepts on personal projects
<br>Experiment with different procedural tools and workflows
<br>Join communities focused on procedural content creation
<br>Analyze existing games to understand their procedural systems

<br>Remember Procedural modeling isn't about replacing artistic skill - it's about amplifying it. The goal is to spend more time on creative decisions and less time on repetitive tasks, while maintaining the ability to iterate and experiment freely.<br>The thinking patterns you develop here apply beyond geometry - to materials, animation, level design, and any systematic creative work.<br><br><br>]]></description><link>gmap-395\gmap-395-guide-procedural-modeling-fundamentals.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - Guide - Procedural Modeling Fundamentals.md</guid><pubDate>Tue, 01 Jul 2025 20:30:36 GMT</pubDate></item><item><title><![CDATA[Module 1 - Procedural Modeling and Lighting]]></title><description><![CDATA[ 
 <br><br><br>This module introduces foundational skills in procedural modeling and lighting systems. Students will explore creating modular assets and environments using DCC tools and plugins.<br>Module Overview Video üìπ
<a data-tooltip-position="top" aria-label="https://1drv.ms/v/c/b08de2251f1b33a4/Efav2YsR0JdOk_rWTc0hYQIBYaenUaj9qcafIpPiFFF44g?e=jx9lD2" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/c/b08de2251f1b33a4/Efav2YsR0JdOk_rWTc0hYQIBYaenUaj9qcafIpPiFFF44g?e=jx9lD2" target="_blank">Module 1 - Overview Video</a>
<br><br><br><a data-href="GMAP 395 - Module 1A - Game Feel and Tactile Experience" href="gmap-395\module-1\submodules\gmap-395-module-1a-game-feel-and-tactile-experience.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1A - Game Feel and Tactile Experience</a><br>
<a data-href="GMAP 395 - Module 1B - Procedural Workflows Introduction" href="gmap-395\module-1\submodules\gmap-395-module-1b-procedural-workflows-introduction.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1B - Procedural Workflows Introduction</a><br>
<a data-href="GMAP 395 - Module 1C - Node-Based Systems and Advanced Techniques" href="gmap-395\module-1\submodules\gmap-395-module-1c-node-based-systems-and-advanced-techniques.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1C - Node-Based Systems and Advanced Techniques</a><br>
<a data-href="GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems" href="gmap-395\module-1\submodules\gmap-395-module-1d-lighting-fundamentals-and-technical-systems.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1D - Lighting Fundamentals and Technical Systems</a><br>
<a data-href="GMAP 395 - Module 1E - Color Theory and Advanced Lighting" href="gmap-395\module-1\submodules\gmap-395-module-1e-color-theory-and-advanced-lighting.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1E - Color Theory and Advanced Lighting</a><br>
<a data-href="GMAP 395 - Module 1F - Case Studies and Practical Implementation" href="gmap-395\module-1\submodules\gmap-395-module-1f-case-studies-and-practical-implementation.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Module 1F - Case Studies and Practical Implementation</a><br><br>N/A<br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Guide - CT and CPS" data-href="GMAP 395 - Guide - CT and CPS" href="gmap-395\gmap-395-guide-ct-and-cps.html" class="internal-link" target="_self" rel="noopener nofollow">Critical Thinking and Creative Problem Solving</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - Guide - Procedural Modeling Fundamentals" data-href="GMAP 395 - Guide - Procedural Modeling Fundamentals" href="gmap-395\gmap-395-guide-procedural-modeling-fundamentals.html" class="internal-link" target="_self" rel="noopener nofollow">Procedural Modeling Fundamentals</a><br><br><a data-tooltip-position="top" aria-label="GMAP 395/Notes/GMAP 395 - WK 2 - Tutorial" data-href="GMAP 395/Notes/GMAP 395 - WK 2 - Tutorial" href="gmap-395\notes\gmap-395-wk-2-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 2 - Tutorial</a><br>
<a data-href="GMAP 395 - WK 3 - Tutorial" href="gmap-395\module-1\tutorials\gmap-395-wk-3-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 3 - Tutorial</a><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - ASN 1 - Brief" data-href="GMAP 395 - ASN 1 - Brief" href="gmap-395\module-1\gmap-395-asn-1-brief.html" class="internal-link" target="_self" rel="noopener nofollow">Assignment 1 - Procedural Modeling + Lightning Systems</a><br><br><a data-href="GMAP 395 - WK 2 - Slides" href="gmap-395\module-1\legacy\gmap-395-wk-2-slides.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 2 - Slides</a><br>
<a data-href="GMAP 395 - WK 2 - Video Lecture" href="gmap-395\module-1\legacy\gmap-395-wk-2-video-lecture.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 2 - Video Lecture</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - WK 3 - Slides" data-href="GMAP 395 - WK 3 - Slides" href="gmap-395\module-1\legacy\gmap-395-wk-3-slides.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 3 - Slides + Video</a><br><br><br>
<br>Introduction to procedural modeling with Blender.
<br>Basics of lighting systems with Unity.
<br>Overview of procedural and modular workflows.
<br><br><br>By the end of this module, you will:<br>
<br>Gain foundational knowledge in procedural modeling techniques and lighting systems.
<br>Explore the use of industry-standard tools like Blender and Unity.
<br>Understand the importance of modular workflows in game art development.
<br>Build confidence in preparing and setting up tools for complex projects.
<br><br><br>
<br>Confirm your computer meets the recommended specifications for Blender and Unity.
<br>Install <a data-tooltip-position="top" aria-label="https://www.blender.org/download/" rel="noopener nofollow" class="external-link" href="https://www.blender.org/download/" target="_blank">Blender</a> 3.9 or higher.
<br>Install Unity (2022.3) via the <a data-tooltip-position="top" aria-label="https://unity.com/download" rel="noopener nofollow" class="external-link" href="https://unity.com/download" target="_blank">Unity Hub</a>
<br>If you have never used Blender

<br>If you have never used Unity

<br><br><br><br><br>
<br>Blender 3.9 or higher: Download from <a rel="noopener nofollow" class="external-link" href="https://www.blender.org/download/" target="_blank">https://www.blender.org/download/</a>.
<br><br>
<br>Unity (LTS version): Download from <a rel="noopener nofollow" class="external-link" href="https://unity.com/download" target="_blank">https://unity.com/download</a>.
<br>Ensure the system specifications match or exceed Unity's requirements.
<br><br><br><br><br><br>
<br><a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/4.3/getting_started/about/index.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/4.3/getting_started/about/index.html" target="_blank">Blender Quick Start Guide</a>
<br><a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/introduction.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/introduction.html" target="_blank">Introduction to Geometry Nodes</a>
<br><a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/interface/keymap/introduction.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/interface/keymap/introduction.html" target="_blank">Blender Keyboard Shortcuts</a>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/pathway/unity-essentials" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/pathway/unity-essentials" target="_blank">Unity Essentials (Getting Started)</a>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/mission/creative-core-lighting?uv=2022.3&amp;pathwayId=61a65568edbc2a00206076dd" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/mission/creative-core-lighting?uv=2022.3&amp;pathwayId=61a65568edbc2a00206076dd" target="_blank">Unity Lighting Tutorials</a>
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\module-1\gmap-395-module-1.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - Module 1.md</guid><pubDate>Tue, 01 Jul 2025 20:09:01 GMT</pubDate></item><item><title><![CDATA[Critical Thinking and Creative Problem Solving for Artists, Designers, and Technologists]]></title><description><![CDATA[ 
 <br><br><br>In creative and technical work, the ability to solve problems systematically often matters more than any specific tool knowledge. Whether you're debugging a shader, designing a character, or optimizing game performance, the same core thinking skills apply.<br>This guide teaches you to approach challenges methodically rather than hoping for inspiration or getting paralyzed by complexity. You'll learn to break down problems, research effectively, and iterate toward solutions.<br>How This Connects: 
This guide pairs with the <a data-href="GMAP 395 - Guide - Procedural Modeling Fundamentals" href="gmap-395\gmap-395-guide-procedural-modeling-fundamentals.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Guide - Procedural Modeling Fundamentals</a> - the problem-solving framework here applies directly to technical modeling challenges, while working through geometry problems reinforces these thinking patterns.
<br><br><br><br><br>üéØ Problem/Goal: You're tasked with creating an entire game environment but feel overwhelmed by the scope.<br>Quick Reality Check, Ask yourself: "If I had to demo this in 2 weeks, what's the absolute minimum that needs to work?"<br><br><br><br><br>Breaking It Down Step-by-Step 
Instead of: "I need to make a castle, fast" (panic mode)
Try this:

<br>üî¥ Core: Outer walls + main gate + courtyard
<br>üü° Systems: Towers (3), inner buildings (2), details
<br>üü¢ Order: Blockout ‚Üí structures ‚Üí props ‚Üí polish

<br>Common Pitfall Don't start with the most exciting part - start with what everything else depends on.<br><br><br><br>üîΩ **Top-Down**
Layout ‚Üí Major structures ‚Üí Details ‚Üí Polish

üîº **Bottom-Up** 
Modular pieces ‚Üí Combinations ‚Üí Full system

üë• **Collaborative**
Team brainstorm ‚Üí Divide responsibilities ‚Üí Regular check-ins
<br>Learn More

<br><a data-tooltip-position="top" aria-label="https://www.artstation.com/learning/courses/aJ/environment-design-fundamentals" rel="noopener nofollow" class="external-link" href="https://www.artstation.com/learning/courses/aJ/environment-design-fundamentals" target="_blank">Environment Design Fundamentals</a>
<br><a data-tooltip-position="top" aria-label="https://www.gamedeveloper.com/production/" rel="noopener nofollow" class="external-link" href="https://www.gamedeveloper.com/production/" target="_blank">Game Production Pipelines</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=dHMNeNapL1E" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=dHMNeNapL1E" target="_blank">Scoping for Indie Games</a>

<br><br>Apply this to shader creation: Break down realistic water material:<br>
<br>üî¥ Core: Base color + basic normal
<br>üü° Systems: Waves + foam + reflection + refraction
<br>üü¢ Dependencies: Surface ‚Üí animation ‚Üí interaction effects
<br>Success Metric You've mastered this when you can take any overwhelming task and create a clear, ordered breakdown in under 30 minutes.<br><br><br><br>üéØ Problem/Goal: Understanding what you're really working with and against so you can plan realistically.<br>Design Wisdom "Constraints are not limitations - they're the foundation that makes creativity possible."<br><br><br><br><br>Constraint-Driven Design Given: Mobile character with strict limits
Constraints become features:

<br>Low poly ‚Üí Stylized, iconic look
<br>Single texture ‚Üí Cohesive color palette
<br>No transparency ‚Üí Bold, graphic design
<br>Small screen ‚Üí Strong silhouette focus

<br><br><br><br>
<br>üéØ Constraint Prioritization: Rank which limits are hardest vs. most flexible
<br>üí° Creative Reframing: Ask "What becomes possible because of this limitation?"
<br>üìä Resource Auditing: List available tools, time, and skills
<br>Pro Technique Document your constraints visually - create a "constraint poster" for your workspace as a constant reminder.<br><br>Apply constraint analysis to a UI design:<br>
<br>Technical: Screen sizes, input methods, performance
<br>Usability: Accessibility, user experience, platform conventions
<br>Aesthetic: Brand guidelines, art direction, readability
<br>Success Metric You can quickly identify the 3 most limiting constraints for any project and explain how they'll shape your approach.<br><br><br><br><br>üéØ Problem/Goal: You need to create something you've never made before and don't know where to start.<br><br><br><br><br>Research Strategy in Action Goal: Cartoon-style water shader
Research layers:

<br>üé® Visual: How does stylized water "read" as water?
<br>üîß Technical: What real-time techniques exist?
<br>üí≠ Conceptual: How do animators suggest water movement?

<br>Reference Organization

<br>Create folders by project and concept
<br>Tag images with keywords and techniques
<br>Note why each reference is useful
<br>Share collections with team members

<br><br><br><br>
<br>üñºÔ∏è Mood Boards: Feeling and atmosphere over technical specifics
<br>üîß Technical Breakdowns: Focus on construction methods
<br>üë• Collaborative Research: Team members research different aspects
<br>Essential Resources

<br><a data-tooltip-position="top" aria-label="https://www.artstation.com/learning" rel="noopener nofollow" class="external-link" href="https://www.artstation.com/learning" target="_blank">ArtStation Learning</a>
<br><a data-tooltip-position="top" aria-label="https://80.lv/" rel="noopener nofollow" class="external-link" href="https://80.lv/" target="_blank">80 Level Breakdowns</a>
<br><a data-tooltip-position="top" aria-label="http://www.realtimerendering.com/" rel="noopener nofollow" class="external-link" href="http://www.realtimerendering.com/" target="_blank">Real-Time Rendering Resources</a>

<br><br>Research for character design across game genres:<br>
<br>Visual: Art styles, proportions, appeal factors
<br>Technical: Rigging constraints, animation needs, performance
<br>Conceptual: Psychology of character design, cultural considerations
<br>Success Metric You can efficiently gather diverse, relevant references and explain how each one informs your creative decisions.<br><br><br><br>üéØ Problem/Goal: The exact solution doesn't exist, but similar problems have been solved elsewhere.<br><br><br><br><br>Translation Process 
Film technique: Complex particle systems<br>
Core principle: Layered depth creates visual richness<br>
Game adaptation: Animated texture layers with depth sorting
<br>Common Mistake Don't just copy techniques - understand why they work first.<br><br><br><br>
<br>üéØ Direct Adaptation: Recreate exactly, then optimize
<br>üí° Principle Extraction: Understand the why, rebuild the how
<br>üîÑ Hybrid Methods: Combine multiple source approaches
<br>Cross-Pollination Technique Regularly browse fields outside your specialty - architecture, fashion, industrial design, biology.<br><br>Adapt web design patterns to game UI:<br>
<br>Hover effects ‚Üí Controller/touch feedback
<br>Navigation patterns ‚Üí Game menu systems
<br>Responsive design ‚Üí Multiple screen sizes
<br>Success Metric You can see solutions in unexpected places and successfully adapt them to your creative challenges.<br><br><br><br>üéØ Problem/Goal: Not all tutorials and advice are good - how do you know what to trust?<br><br><br><br>Conflicting Advice Scenario
 Source A: "Never exceed 1,000 triangles"<br>
Source B: "Up to 5,000 triangles is fine"<br>
Source C: "It depends on your target device"
<br>Evaluation process:<br><br>Validation Strategy

<br>Context Check: When, where, why was this advice given?
<br>Small Test: Build minimal example to verify claims
<br>Reasoning Analysis: Understand the underlying logic

<br><br><br><br>
<br>üë• Community Validation: Ask experienced practitioners
<br>üß™ Personal Testing: Build experiments to verify claims
<br>üìö Contextual Research: Find advice specific to your situation
<br>Information Quality Red Flags

<br>No source attribution or credentials
<br>Claims without supporting evidence
<br>Advice that seems too good to be true
<br>Information that contradicts established best practices

<br><br>Evaluate design principles for different audiences:<br>
<br>Research: What evidence supports these principles?
<br>Test: How do different user groups respond?
<br>Context: When do these principles apply vs. not apply?
<br>Success Metric You can quickly assess information credibility and know when to dig deeper vs. accept advice.<br><br><br><br><br>üéØ Problem/Goal: You need to test ideas quickly without investing too much time in any single approach.<br><br><br><br><br>Prototype Progression 
Week 1: Gray boxes, test jump feel<br>
Week 2: Basic character shape, test animations<br>
Week 3: Add visual feedback, test player reactions<br>
Week 4: Final art pass on proven mechanics
<br>Prototyping Hierarchy

<br>Core functionality (does it work?)
<br>User experience (does it feel right?)
<br>Visual polish (does it look good?)

<br><br><br><br>
<br>üìÑ Paper Prototypes: Test concepts without digital tools
<br>üñºÔ∏è Digital Mockups: Non-functional visual representations
<br>üîß Hybrid Methods: Combine low-fi and high-fi strategically
<br>Prototype Pitfalls

<br>Making prototypes too polished (wastes time)
<br>Testing only one variable at a time (misses interactions)
<br>Skipping documentation (loses valuable insights)

<br><br>Prototype a new art style:<br>
<br>Visual test: Single character/prop in new style
<br>Consistency test: Multiple assets using same approach
<br>Context test: Assets in actual game environment
<br>Success Metric You can rapidly test core assumptions and pivot based on prototype feedback without emotional attachment to early work.<br><br><br><br>üéØ Problem/Goal: Learning from your process so you can improve and repeat successes.<br><br><br><br><br>Documentation Template 
Project: Stylized Water Shader<br>
Goal: Cartoon ocean for mobile game<br>
Research: 3 days studying animated films<br>
Attempts: Tried particle system (too heavy), vertex animation (wrong look)<br>
Breakthrough: Combined UV scrolling with vertex displacement<br>
Result: 60fps on target device, matches art style<br>
Next time: Start with performance constraints, not visual goals
<br>Documentation Timing

<br>During work: Quick notes, screenshots of progress
<br>After sessions: Reflection on what worked/didn't
<br>Project end: Complete analysis and lessons learned

<br><br><br><br>
<br>üìù Written Logs: Traditional journaling and note-taking
<br>üì∏ Visual Documentation: Screenshots, progress videos, annotated images
<br>üé• Process Recording: Screen capture while working
<br>Documentation Tools

<br>Text: Notion, Obsidian, simple markdown files
<br>Visual: Milanote, PureRef, Pinterest boards
<br>Mixed: Personal wiki, team knowledge base

<br><br>Document a challenging modeling or animation process:<br>
<br>Process: What steps did you follow?
<br>Problems: Where did you get stuck and how did you solve it?
<br>Patterns: What problem-solving approaches emerged?
<br>Success Metric You have a growing personal knowledge base that you actively reference and update, making each project easier than the last.<br><br><br><br><br>üéØ Problem/Goal: Getting help when stuck and explaining your work to others effectively.<br><br><br><br>Poor vs. Good Help Requests
‚ùå Poor request: "My shader is broken, help!"
‚úÖ Good request: "I'm creating a stylized water shader for mobile. It should look cartoon-like but I'm getting realistic results. Here's what I have [screenshot], here's what I want [reference image], and here's what I've tried [node graph]. Working in Blender 3.6, targeting Android devices. Any suggestions for the cartoon look?"
<br><br><br><br><br>
<br>üí¨ Synchronous: Real-time conversation, screen sharing
<br>üìß Asynchronous: Detailed written explanations with materials
<br>üé• Video: Record problem demonstration with narration
<br>Help Request Template

<br>Goal: What are you trying to achieve?
<br>Current State: What's happening now?
<br>Context: Tools, platform, constraints
<br>Attempts: What have you already tried?
<br>Specific Ask: What kind of help do you need?

<br><br>Explain a complex technical process to a non-technical team member:<br>
<br>Use analogies and visual aids
<br>Focus on outcomes rather than methods
<br>Check understanding throughout explanation
<br>Success Metric You consistently get helpful responses to your questions and can explain your work clearly to different audiences.<br><br><br><br>üéØ Problem/Goal: Accelerating your growth by understanding how others think through challenges.<br><br><br><br><br>What to Look For 
Surface level: What tools they use, what settings they choose<br>
Deeper level: When they pause to evaluate, how they handle mistakes, what order they work in<br>
Deepest level: How they think about problems, what principles guide their decisions
<br>Active Learning Approach

<br>Watch once for overall impression
<br>Watch again taking notes on decision points
<br>Try to replicate the approach on your own project
<br>Adapt the method to your specific needs

<br><br><br><br>
<br>üéì Structured Learning: Courses, workshops, formal training
<br>üí¨ Community Learning: Forums, Discord servers, study groups
<br>üîç Self-Directed Study: Analyzing published work and breakdowns
<br>Learning Communities

<br><a data-tooltip-position="top" aria-label="https://polycount.com/" rel="noopener nofollow" class="external-link" href="https://polycount.com/" target="_blank">Polycount</a> - Technical art community
<br><a data-tooltip-position="top" aria-label="https://realtimevfx.com/" rel="noopener nofollow" class="external-link" href="https://realtimevfx.com/" target="_blank">Real-Time VFX</a> - Effects artists
<br><a data-tooltip-position="top" aria-label="https://techartaid.com/" rel="noopener nofollow" class="external-link" href="https://techartaid.com/" target="_blank">Tech Art Aid</a> - Technical art resources

<br><br>Analyze a workflow from a different creative field:<br>
<br>Architecture: How do architects plan complex projects?
<br>Film: How do VFX artists approach problem-solving?
<br>Product Design: How do industrial designers iterate?
<br>Adapt one insight to your game development work.<br>Success Metric You can identify valuable learning opportunities in unexpected places and successfully integrate new approaches into your workflow.<br><br><br><br>The techniques in this guide become more powerful with practice. Start applying them to small challenges before tackling major projects. Each problem you solve systematically builds your confidence and expands your toolkit.<br>Key Takeaways

<br>Break down complex challenges into manageable pieces
<br>Research broadly and adapt solutions creatively
<br>Iterate quickly and learn from failures
<br>Document your process for future reference
<br>Collaborate effectively to amplify your capabilities

<br>Next Steps

<br>Practice these techniques on your current projects
<br>Build your personal reference and knowledge libraries
<br>Find communities where you can both seek and offer help
<br>Continue learning by analyzing others' problem-solving approaches

<br>Remember: The goal isn't to never get stuck, but to have systematic ways of getting unstuck. Every challenge becomes an opportunity to strengthen your problem-solving skills.<br><br><br>]]></description><link>gmap-395\gmap-395-guide-ct-and-cps.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - Guide - CT and CPS.md</guid><pubDate>Tue, 01 Jul 2025 20:18:32 GMT</pubDate></item><item><title><![CDATA[Blender to Unity "Brickify" Demo Guide]]></title><description><![CDATA[ 
 <br><br>Duration: 15-20 minutes<br>
Goal: Turn any object into LEGO-style bricks using procedural modeling<br><br><br>What we're making: A system that converts any 3D object into LEGO-style bricks Why this example: Shows point cloud generation, procedural modeling, and instancing - core technical art concepts<br><br><br><br>
"Today we're going to create a system that can turn ANY 3D object into LEGO bricks. We'll build one perfect brick, then teach Blender how to copy it thousands of times intelligently. This is how studios create massive environments from small modular pieces."
<br>Key Teaching Point: "We're not just making bricks - we're making a SYSTEM that makes bricks."<br><br><br>Action:<br>
<br>Delete default cube
<br>Add Cube (Shift+A ‚Üí Mesh ‚Üí Cube)
<br>Scale to (1, 1, 0.4) - "Standard LEGO proportions"
<br>Tab into Edit Mode
<br>Select top face, Inset (I) by 0.1
<br>Extrude (E) up by 0.1 to create the "stud"
<br>Talking Points:<br>
<br>"LEGO bricks have very specific proportions - this isn't random"
<br>"The stud on top is what makes it recognizably LEGO"
<br>"Real LEGO designers follow these exact ratios"
<br>Question to Class: "Why do you think LEGO uses these exact proportions?" Expected Answer: So all pieces fit together perfectly<br>Action Continue: 7. Tab back to Object Mode 8. Add Smooth Shading (right-click ‚Üí Shade Smooth) 9. Rename to "LEGO_Brick"<br>Visual Check: Should look like a recognizable LEGO brick with rounded shading<br><br><br>Action:<br>
<br>Add another object (Shift+A ‚Üí Mesh ‚Üí Monkey or UV Sphere)
<br>Scale to about 2-3 units
<br>Position away from brick (X = 4)
<br>Rename to "Target_Object"
<br>Talking Points:<br>
<br>"This is what we're going to 'brickify'"
<br>"Could be any object - character, building, logo, anything"
<br>"The system will work on any geometry"
<br>Question to Class: "What kinds of objects do you think this would be useful for in games?" Possible Answers: Buildings, terrain, stylized characters, destructible objects<br><br><br><br>Action:<br>
<br>Select Target_Object
<br>Add Modifier ‚Üí Geometry Nodes
<br>Click "New" in modifier panel
<br>In node editor, add Points ‚Üí Distribute Points on Faces
<br>Connect Target_Object geometry to Distribute Points input
<br>Connect Distribute Points to Group Output
<br>Set Density to around 20-30
<br>Talking Points:<br>
<br>"Distribute Points creates a cloud of points following the surface"
<br>"Each point will become a place where we put a brick"
<br>"Higher density = more bricks, but also more geometry"
<br>Question to Class: "What happens if we make the density too high?" Demonstrate: Increase to 100, show slowdown, decrease back<br>Teaching Point: "Procedural power comes with performance responsibility"<br><br><br>Action:<br>
<br>Add Instances ‚Üí Instance on Points
<br>Connect Distribute Points ‚Üí Instance on Points ‚Üí Group Output
<br>In Instance input, click the object picker icon
<br>Select "LEGO_Brick" from the scene
<br>Talking Points:<br>
<br>"Instance on Points puts a copy of our brick at every point"
<br>"Instancing is efficient - one brick definition, thousands of copies"
<br>"This is how games render forests, crowds, and repeated elements"
<br>Visual Check: Target object should now be covered in LEGO bricks!<br>Question to Class: "This looks cool, but what's missing to make it look more like real LEGO?" Expected Answer: Random rotation, color variation, better spacing<br><br><br>Action:<br>
<br>Add Utilities ‚Üí Random Value (between Instance on Points and Group Output)
<br>Set Data Type to Vector
<br>Set Min to (0, 0, 0), Max to (0, 0, 360) - only Z rotation
<br>Connect Random Value to Instance on Points "Rotation" input
<br>Talking Points:<br>
<br>"Random rotation makes it look more natural"
<br>"Real LEGO builders don't align everything perfectly"
<br>"Controlled randomness feels more organic"
<br>Action Continue: 5. Add another Random Value node 6. Set Data Type to Vector (for color) 7. Set Min to (0.2, 0.2, 0.2), Max to (1, 1, 1) 8. Connect to Instance on Points "Instance" ‚Üí could connect to a Set Material node if time allows<br>Teaching Point: "Procedural systems let us add complexity without adding work"<br><br><br><br>Action:<br>
<br>Apply the Geometry Nodes modifier (down arrow ‚Üí Apply)
<br>Select all bricks (A to select all)
<br>Join objects (Ctrl+J) if multiple objects created
<br>File ‚Üí Export ‚Üí FBX
<br>Name: "Brickified_Object_v001.fbx"
<br>Export settings: Apply Modifiers ‚úì, Selected Objects Only ‚úì
<br>Talking Points:<br>
<br>"Apply modifier 'bakes' our procedural system into real geometry"
<br>"Version numbers help track iterations"
<br>"Unity needs regular mesh data, not procedural instructions"
<br>Question to Class: "Why can't Unity read Geometry Nodes directly?" Answer: Different software, different languages - need common format (FBX)<br><br><br>Action:<br>
<br>Open Unity 2022 (new 3D project)
<br>Import FBX to Assets folder
<br>Drag model into scene
<br>Position at origin (0,0,0)
<br>Talking Points:<br>
<br>"Pipeline complete - Blender creates, Unity displays"
<br>"Same asset can be used in levels, as props, in cutscenes"
<br>Visual Check: Brickified object should appear in Unity scene<br><br><br>Action:<br>
<br>Rotate Main Camera to get good angle
<br>Create Directional Light (right-click ‚Üí Light ‚Üí Directional Light)
<br>Angle light from side (Rotation: 45, -30, 0)
<br>Set Intensity to 2
<br>Add Point Light above object (Position: 0, 5, 0)
<br>Set Point Light color to warm orange/yellow
<br>Talking Points:<br>
<br>"Lighting sells the 'toy' aesthetic"
<br>"Directional light = sunlight, Point light = room lighting"
<br>"Two-point lighting is classic studio setup"
<br>Question to Class: "How does the lighting make this feel more like toys?" Answer: Bright, clean lighting like a toy commercial or display<br><br><br><br>Go back to Blender:<br>
<br>Undo back to before applying modifier
<br>Change point density from 30 to 50
<br>Re-export as "v002"
<br>Import to Unity and compare
<br>Talking Points:<br>
<br>"This is procedural power - change one number, get completely different result"
<br>"Same workflow scales from 100 bricks to 100,000 bricks"
<br>"Artist controls density based on performance needs and visual goals"
<br>Question to Class: "In a real game, when might you want fewer vs. more bricks?" Answers: Fewer for distant objects, more for hero pieces, performance considerations<br><br><br>Quick Brainstorm: "How could we expand this system?"<br>
<br>Different brick sizes (1x1, 2x1, 2x2)
<br>Color coding by height or surface angle
<br>Hollow interiors vs. solid bricks
<br>Animation of building/breaking apart
<br>Different materials for different brick types
<br>Teaching Point: "This 15-minute demo is the foundation for complex procedural systems used in AAA games"<br><br><br><br>
<br>
"What was procedural about this demo?"

<br>Point distribution algorithm, instancing rules, random variation


<br>
"What made this modular?"

<br>One brick design used everywhere, system works on any input object


<br>
"What was our pipeline?"

<br>Blender (procedural system) ‚Üí FBX export ‚Üí Unity (lighting and presentation)


<br>
"How is this like real game development?"

<br>Modular assets, performance considerations, artist-friendly parameters


<br><br><br>Real-World Applications:<br>
<br>Environment Art: Modular building systems, terrain details
<br>VFX: Debris systems, crowd duplication
<br>Technical Art: Asset optimization, automated content generation
<br>Game Design: Destructible environments, construction mechanics
<br>Industry Example: "Games like Minecraft, LEGO games, and even Fortnite's building system use these exact concepts at scale."<br><br><br><br>
<br>Too many bricks/slow performance: Lower density or use LOD systems
<br>Bricks not appearing: Check object picker connection in Instance node
<br>Export problems: Ensure modifier is applied before export
<br>Unity import issues: Verify FBX settings include geometry
<br><br>
<br>Running long: Skip color variation, focus on core concept
<br>Running short: Show different input objects (cube, sphere, text)
<br>Technical issues: Have backup FBX file ready
<br><br><br>Core Concepts Demonstrated:<br>
<br>Point cloud generation from any geometry
<br>Instancing for efficient duplication
<br>Procedural variation through controlled randomness
<br>Pipeline workflow from creation to implementation
<br>Scalable systems that work at any complexity level
<br>Most Important Insight: "Professional game development is about building systems, not individual assets."<br><br><br><br>
<br>Different input objects: Text, logos, complex models
<br>Brick variations: Different scales, shapes
<br>Smart placement: Align bricks to surface normals
<br><br>"Next week we'll expand procedural modeling to create complete modular environments and explore advanced lighting workflows."<br><br><br>Students should leave understanding:<br>
<br>Procedural modeling creates systems, not just objects
<br>Instancing is key to performance in game development
<br>Pipeline workflows connect creative tools to game engines
<br>Simple rules can generate complex, appealing results
<br>Technical art bridges creativity and technical implementation
<br>Energy Goal: Students excited to experiment with their own objects and see what they can "brickify"!]]></description><link>gmap-395\class-demos\demo-1-simple-blender-to-unity.html</link><guid isPermaLink="false">GMAP 395/Class Demos/Demo - 1 -Simple Blender to Unity.md</guid><pubDate>Tue, 24 Jun 2025 21:12:07 GMT</pubDate></item><item><title><![CDATA[Introduction and Overview]]></title><description><![CDATA[ 
 <br><br><br>This introductory module sets the stage for the quarter by exploring the core ideas of games, design, and play while introducing technical art and procedural workflows as key methodologies in modern game development.<br><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Introduction - A" data-href="GMAP 395 - Introduction - A" href="gmap-395\introduction\gmap-395-introduction-a.html" class="internal-link" target="_self" rel="noopener nofollow">Module IA: What is Technical Art?</a><br>
<a data-tooltip-position="top" aria-label="GAMP 395 - Introduction - B" data-href="GAMP 395 - Introduction - B" href="gmap-395\introduction\gamp-395-introduction-b.html" class="internal-link" target="_self" rel="noopener nofollow">Module IB: Procedural Thinking Basics</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - Introduction - C" data-href="GMAP 395 - Introduction - C" href="gmap-395\introduction\gmap-395-introduction-c.html" class="internal-link" target="_self" rel="noopener nofollow">Module IC: Node-Based Workflows Introduction</a><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Introduction - Blender GN Demo" data-href="GMAP 395 - Introduction - Blender GN Demo" href="gmap-395\introduction\gmap-395-introduction-blender-gn-demo.html" class="internal-link" target="_self" rel="noopener nofollow">In-Class Blender Demo - WK 1</a><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - SU25 - Theme" data-href="GMAP 395 - SU25 - Theme" href="gmap-395\gmap-395-su25-theme.html" class="internal-link" target="_self" rel="noopener nofollow">Course Theme</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - Weekly - 1" data-href="GMAP 395 - Weekly - 1" href="gmap-395\weeklies\gmap-395-weekly-1.html" class="internal-link" target="_self" rel="noopener nofollow">Weekly Critique - 1</a><br><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - WK 1 - Video Lecture" data-href="GMAP 395 - WK 1 - Video Lecture" href="gmap-395\introduction\gmap-395-wk-1-video-lecture.html" class="internal-link" target="_self" rel="noopener nofollow">Legacy - Week 1 Video</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - WK 1 - Slides" data-href="GMAP 395 - WK 1 - Slides" href="gmap-395\introduction\gmap-395-wk-1-slides.html" class="internal-link" target="_self" rel="noopener nofollow">Legacy - Week 1 Slides</a><br><br><br>
<br>The relationship between games, design, and play. (Lecture)
<br>Introduction to technical art for games.
<br>Fundamentals of procedural and modular workflows.
<br><br><br>By the end of this module, you will:<br>
<br>Define key concepts of games, design, and play.
<br>Understand the role of technical art in game development.
<br>Explore the benefits and principles of procedural workflows.
<br><br><br>n/a<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://www.riotgames.com/en/artedu/technical-art" rel="noopener nofollow" class="external-link" href="https://www.riotgames.com/en/artedu/technical-art" target="_blank">What is Technical Art?</a>
<br><a data-tooltip-position="top" aria-label="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" rel="noopener nofollow" class="external-link" href="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" target="_blank">What is Technical Artist?</a>
<br><a data-tooltip-position="top" aria-label="https://www.autodesk.com/solutions/proceduralism" rel="noopener nofollow" class="external-link" href="https://www.autodesk.com/solutions/proceduralism" target="_blank">Procedural Workflows Explained</a>
<br><a data-tooltip-position="top" aria-label="https://www.void1gaming.com/post/3-pillars-in-game-engineering-intro-to-modular-game-design" rel="noopener nofollow" class="external-link" href="https://www.void1gaming.com/post/3-pillars-in-game-engineering-intro-to-modular-game-design" target="_blank">Introduction to Modular Design</a>
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\introduction\gmap-395-introduction-and-overview.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - Introduction and Overview.md</guid><pubDate>Sun, 29 Jun 2025 19:44:10 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 2 - Slides]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><img alt="GMAP 395/Module 1/Media/gamefeelcover.webp" src="lib\media\gamefeelcover.webp" style="width: 320px; max-width: 100%;"><br>Game Feel
Real-time control of virtual objects in a simulated space, with interaction emphasized by polish.<br>
-- Steve Swink
<br><br><br><br>
<br>Definition: The visceral, tactile experience of interacting with a game, making it feel responsive and tangible.
<br>Components:

<br>Real-Time Control: Immediate response to player input.
<br>Simulated Space: Believable virtual environments with realistic or stylized physics.
<br>Polish: Visual, audio, and interactive feedback that enhances immersion.


<br>Examples:<br>
<br>Super Mario Bros: Precise platforming.
<br>Celeste: Forgiving yet challenging controls.
<br>DOOM (2016): Weighty, impactful combat.
<br><br><br>
<br>Momentum and Inertia (Physics):

<br>Creating a sense of weight and speed in character and object movement.
<br>Example: Rolling boulders in The Legend of Zelda: Breath of the Wild.


<br>Input Responsiveness:

<br>Reducing input lag to ensure tight controls.
<br>Example: Fighting games like Street Fighter prioritize frame-perfect inputs.


<br><br><br>
<br>What Are Procedural Workflows?

<br>Automating content creation using algorithms and rules.
<br>Efficiently producing scalable, dynamic assets and systems.


<br>Why It Matters:

<br>Reduces repetitive tasks.
<br>Enables scalability for vast game worlds.
<br>Facilitates rapid prototyping and iteration.


<br><br><br>
<br>Applications:

<br>Terrain and Landscapes: Dynamic natural environments (e.g., Minecraft).
<br>Characters and Creatures: Diverse entities (e.g., Spore).
<br>Loot Systems: Unique equipment and items (e.g., Borderlands).
<br>Buildings and Cities: Algorithmic urban designs. (e.g., Spiderman)


<br>Efficiency: Combines hand-crafted content with procedural systems for optimal results.<br><br><br>
<br>Over-Generation:

<br>Excessively random content can feel disjointed.
<br>Solution: Blend procedural elements with curated designs and a cehesive artistic vision.


<br>Player Fatigue:

<br>Repetitive patterns may reduce engagement.
<br>Solution: Introduce meaningful variability and uniqueness within procedural systems/design.


<br><br><br>
<br>What is Modularity?

<br>Reusable components for streamlined development.


<br>Benefits:

<br>Reusability: Assets can be used across levels/projects.
<br>Flexibility: Easier updates and maintenance.
<br>Performance: Reduces memory load by optimizing reusable assets.


<br>Synergy with Proceduralism:<br>
<br>Modular assets populated procedurally for diverse environments (e.g., No Man‚Äôs Sky).
<br><a data-tooltip-position="top" aria-label="https://www.beyondextent.com/articles/balancing-modularity-and-uniqueness-in-environment-art" rel="noopener nofollow" class="external-link" href="https://www.beyondextent.com/articles/balancing-modularity-and-uniqueness-in-environment-art" target="_blank">Balancing modularity and uniqueness in Environment Art</a><br><img alt="GMAP 395/Module 1/Media/modualassetpack.png" src="lib\media\modualassetpack.png" style="width: 640px; max-width: 100%;"><br><br><br>
<br>Asset Organization:

<br>Maintain a clean structure for quick access and scalability.


<br>Consistent Metrics:

<br>Standardize dimensions and pivot points.


<br>Interoperability:

<br>Ensure modular assets work seamlessly in various configurations.


<br><br><br>Book: <br> <a data-tooltip-position="top" aria-label="https://www.pcgbook.com/" rel="noopener nofollow" class="external-link" href="https://www.pcgbook.com/" target="_blank">Procedural Content Generation in Games</a><br><br><br><br><img alt="GMAP 395/Module 1/Media/pcgTaxonomy.png" src="lib\media\pcgtaxonomy.png"><br>
<br>Game Bits: Assets (textures, sounds, models).
<br>Game Space: Levels, terrains, maps.
<br>Game Systems: Rules and mechanics (e.g., weather systems).
<br>Game Scenarios: Events, narratives, quests.
<br>Examples:<br>
<br>Roguelikes: Procedurally generated levels (e.g., Hades).
<br>Survival Games: Dynamic environments (e.g., Subnautica).
<br><a data-tooltip-position="top" aria-label="https://dl.acm.org/doi/10.1145/2422956.2422957" rel="noopener nofollow" class="external-link" href="https://dl.acm.org/doi/10.1145/2422956.2422957" target="_blank">Procedural content generation for games:&nbsp;A survey</a><br><br><br>
<br>Hybrid Approaches:

<br>Combining procedural and hand-crafted elements.
<br>Example: Shadow of Mordor‚Äôs Nemesis system mixes procedural generation with predefined rules.<br>



<br>Adaptive PCG:

<br>Systems that adjust content based on player behavior.
<br>Example: Dynamic difficulty adjustment in Left 4 Dead.


<br><br><br>
<br>Definition: Visual scripting using nodes to represent operations and data flow.
<br>Advantages:

<br>Artist-friendly and intuitive.
<br>Clear visual representation of processes.
<br>Supports modularity and reusability.


<br>Tools:<br>
<br>Blender Geometry Nodes: Procedural modeling nodes.
<br>Houdini: Procedural modeling and VFX.
<br>Unreal Engine Blueprint: Gameplay logic.
<br>Unity Shader Graph: Material creation.
<br><br><br>
<br>Dynamic Dependencies:

<br>Create relationships between nodes for real-time updates.
<br>Example: Automatically updating materials when assets change.


<br>Optimizations:

<br>Collapse redundant nodes for streamlined performance.
<br>Example: Combining noise and displacement nodes in terrain shaders.


<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=Wmwe1fmR1SM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=Wmwe1fmR1SM" target="_blank">Geometry Fundamentals</a>:

<br>Vertices: Points in 3D space.
<br>Edges: Lines connecting vertices.
<br>Faces: Surfaces defined by edges.
<br>Normals: Perpendicular vectors to surfaces.


<br>Math Concepts:

<br><a data-tooltip-position="top" aria-label="https://www.khanacademy.org/math/algebra-home/alg-vectors/alg-vector-basics/v/introduction-to-vectors-and-scalars" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/math/algebra-home/alg-vectors/alg-vector-basics/v/introduction-to-vectors-and-scalars" target="_blank">Vectors</a>: Direction and magnitude.
<br><a data-tooltip-position="top" aria-label="https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:matrices/x9e81a4f98389efdf:mat-intro/v/introduction-to-the-matrix" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:matrices/x9e81a4f98389efdf:mat-intro/v/introduction-to-the-matrix" target="_blank">Matrices</a>: Transformations in space.
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=zjMuIxRvygQ" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=zjMuIxRvygQ" target="_blank">Quaternions</a>: Representing rotations.


<br>Applications:<br>
<br>Procedural transformations (e.g., proportional scaling).
<br><img alt="GMAP 395/Module 1/Media/3D-Shapes-01-01.png" src="lib\media\3d-shapes-01-01.png" style="width: 320px; max-width: 100%;"><br><br><br>
<br>Nodes and Data Flow: Organizing procedural steps.
<br>Scattering/Copying: Distributing objects procedurally (e.g., foliage).
<br>Splines: Creating paths and smooth curves.
<br>Parameter Manipulation: Dynamically adjusting properties.
<br>Attributes: Defining object-specific data.
<br>Randomization/Noise: Adding variation and realism.
<br>Boolean Operations: Combining or subtracting shapes.
<br>Instancing: Efficiently reusing objects.
<br>Deformations: Transforming shapes procedurally (e.g., terrain sculpting).
<br>Constraints: Guiding procedural behaviors.
<br>Looping: Repeating processes for consistency.
<br><br><br>
<br>Noise Patterns: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=erI7k3lt4UY" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=erI7k3lt4UY" target="_blank">The Art of Procedural Noise</a>

<br>Procedural textures for organic designs.
<br>Example: Voronoi patterns used for terrain generation or cellular structures.


<br>Fractals: <a data-tooltip-position="top" aria-label="https://www.wired.com/video/watch/5-levels-computer-scientist-explains-fractals-in-5-levels-of-difficulty" rel="noopener nofollow" class="external-link" href="https://www.wired.com/video/watch/5-levels-computer-scientist-explains-fractals-in-5-levels-of-difficulty" target="_blank">Explaining Fractals in 5 Levels</a>

<br>Recursive geometries for complex visuals.
<br>Example: Mandelbrot sets for landscapes or branching systems like lightning.


<br>Flow Fields: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=na7LuZsW2UM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=na7LuZsW2UM" target="_blank">The Beauty of Code: Flow Fields</a>

<br>Directing particle systems dynamically.
<br>Example: Simulating wind patterns or flocking behaviors in particle systems.


<br>L-Systems: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=egxBK_EGauM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=egxBK_EGauM" target="_blank">L-Systems Fundamentals</a>

<br>Rule-based systems for generating fractal-like structures.
<br>Example: Procedurally creating realistic trees, plants, or coral.


<br>Shape Grammars: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=zCeqBV0Amm0" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=zCeqBV0Amm0" target="_blank">Procedural Building: Shape Grammars</a>

<br>Rule-based approach for generating architectural or structured designs.
<br>Example: Creating procedurally generated buildings or city layouts.


<br><br><img alt="GMAP 395/Module 1/Media/fractals.png" src="lib\media\fractals.png" style="width: 320px; max-width: 100%;"><br>
<img alt="GMAP 395/Module 1/Media/noise.jpg" src="lib\media\noise.jpg"><br><br><br>
<br>Nodes: Visual representation of workflows.
<br>Attributes: Define unique object behaviors.
<br>Randomization: Add variation for realism.
<br>Scalability: Efficiently create vast, dynamic environments.
<br>Practical Example:<br>
<br>Generate a forest:

<br>Use splines for paths.
<br>Scatter trees procedurally.
<br>Add random noise for variation.


<br><br><br>
<br>Overview:

<br>Infinite universe generated procedurally.


<br>Key Techniques:

<br>Procedural Terrain: Dynamic landscapes with varied biomes.
<br>Modular Assets: Ships, flora, and fauna built from reusable parts.
<br>Node-Based Workflows: Data-driven algorithms for content generation.


<br>Impact: Demonstrates the synergy of proceduralism and modularity for immersive exploration.<br><a data-tooltip-position="top" aria-label="https://www.rambus.com/blogs/the-algorithms-of-no-mans-sky-2/" rel="noopener nofollow" class="external-link" href="https://www.rambus.com/blogs/the-algorithms-of-no-mans-sky-2/" target="_blank">The algorithms of No Man‚Äôs Sky</a><br><br><br><br>
<br>Procedural Workflows: Automate and enhance creativity.
<br>Modularity: Reuse and optimize assets.
<br>Game Feel: Ensure tactile and immersive experiences.
<br>Tools and Techniques: Build scalable, dynamic, and engaging game worlds.
<br>Reflection Questions: <br>
<br>How will you apply procedural and modular techniques in your projects?
<br>How do node-based workflows enhance creativity and efficiency in game design?
<br>What are the advantages and challenges of combining proceduralism and modularity in a game project?
<br>Can you identify a game you‚Äôve played that effectively uses procedural techniques? How did it enhance (or detract from) the gameplay experience?
<br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\legacy\gmap-395-wk-2-slides.html</link><guid isPermaLink="false">GMAP 395/Module 1/legacy/GMAP 395 - WK 2 - Slides.md</guid><pubDate>Mon, 20 Jan 2025 19:17:08 GMT</pubDate><enclosure url="lib\media\gamefeelcover.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\gamefeelcover.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 2 - Video Lecture]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="[gmap395_wk2.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_EnKYcs_oFzmZB0Sg?e=abV2gc)" rel="noopener nofollow" class="external-link" href=".\[gmap395_wk2.mp4](https:\\1drv.ms\v\s!AqQzGx8l4o2wk_EnKYcs_oFzmZB0Sg?e=abV2gc)" target="_blank">Video Link</a><br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\legacy\gmap-395-wk-2-video-lecture.html</link><guid isPermaLink="false">GMAP 395/Module 1/legacy/GMAP 395 - WK 2 - Video Lecture.md</guid><pubDate>Fri, 17 Jan 2025 19:49:10 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 3 - Slides]]></title><description><![CDATA[ 
 <br><br><br><br><a data-tooltip-position="top" aria-label="[gmap395_wk3.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_FWfbFNa6ud6HX0Eg?e=LHB4am)" rel="noopener nofollow" class="external-link" href=".\[gmap395_wk3.mp4](https:\\1drv.ms\v\s!AqQzGx8l4o2wk_FWfbFNa6ud6HX0Eg?e=LHB4am)" target="_blank">Week 3 Video Lecture Link</a>

<br><br><br>
<br>Purpose of Lighting:

<br>Enhance mood and atmosphere.
<br>Guide the player‚Äôs attention.
<br>Improve visual clarity and realism.
<br>Communicate gameplay mechanics and objectives.
<br>Balance aesthetics with performance.


<br><br><br>
<br>Quality: Determines how light interacts with surfaces.

<br>Example: Realistic shadows, soft light falloffs.


<br>Quantity: The intensity and coverage of light.

<br>Example: Brightness levels and area of influence.


<br>Direction: The angle and position of light.

<br>Example: Backlighting for dramatic silhouettes.


<br><br><br><br>
<br>Understanding Quality:

<br>High-quality lighting enhances immersion with realistic shadows and nuanced illumination.
<br>Balancing quality ensures performance optimization.


<br>Managing Quantity:

<br>Excessively bright or dim lighting can confuse players.
<br>Adjust light intensity to fit the scene‚Äôs tone and function.


<br>Using Direction Effectively:

<br>Side or top-down lighting can highlight textures or contours.
<br>Directional lighting aids in visual storytelling.


<br><br><br><br>
<br>Direct Lighting: Hits surfaces directly.
<br>Indirect Lighting: Bounces light off surfaces.
<br>Ambient Lighting: General illumination without a specific source.
<br>Emissive Lighting: Objects emit their own light.
<br>Global Illumination (GI): Simulates realistic light interactions through bounces.
<br><a data-tooltip-position="top" aria-label="https://www.adobe.com/products/substance3d/discover/what-is-global-illumination.html#:~:text=Global illumination is a feature,doesn't look very realistic." rel="noopener nofollow" class="external-link" href="https://www.adobe.com/products/substance3d/discover/what-is-global-illumination.html#:~:text=Global%20illumination%20is%20a%20feature,doesn't%20look%20very%20realistic." target="_blank">A guide to global illumination - ADOBE </a><br><br><br><br>
<br>General Principles:

<br>All game engines rely on similar principles for rendering lighting.
<br>Systems like lightmaps, probes, and dynamic adjustments are ubiquitous.


<br>Implementation Tips:

<br>Always profile lighting performance.
<br>Utilize modular workflows for scalability when needed/possible.


<br><br><br>
<br>Directional Light: Simulates sunlight, infinite reach.
<br>Point Light: Emits light uniformly in all directions.
<br>Spot Light: Creates a cone-shaped beam.
<br>Area Light: Illuminates a specific area (baked only).
<br><a data-tooltip-position="top" aria-label="https://book.leveldesignbook.com/process/lighting" rel="noopener nofollow" class="external-link" href="https://book.leveldesignbook.com/process/lighting" target="_blank">The Level Design Book - Lighting</a><br><br><br>
<br>Dynamic Lighting: Updates continuously, ideal for interactive or changing environments.
<br>Static Lighting: Pre-calculated for non-interactive elements to reduce processing.
<br>Hybrid Systems: Combine dynamic and static methods for optimized results.
<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/6000.0/Documentation/Manual/LightModes-introduction.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/6000.0/Documentation/Manual/LightModes-introduction.html" target="_blank">Unity Documentation on "Light Modes"</a><br><br><br>
<br>Limit Realtime Lights: Use baked lighting wherever possible.
<br>Leverage Mixed Lighting: Combine dynamic and static lighting.
<br>Light Probes: Optimize lighting for dynamic objects.
<br>Reflection Probes: Simulate realistic reflections.
<br>Profile Lighting Costs: Regularly monitor performance impact.
<br><a data-tooltip-position="top" aria-label="https://vintay.medium.com/difference-between-realtime-mixed-and-baked-lighting-in-unity-6bda1f24bfb" rel="noopener nofollow" class="external-link" href="https://vintay.medium.com/difference-between-realtime-mixed-and-baked-lighting-in-unity-6bda1f24bfb" target="_blank">Difference Between Realtime, Mixed, And Baked Lighting in Unity</a><br>See again (<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=04YUZ3bWAyg" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=04YUZ3bWAyg" target="_blank">Global Illumination in Tom Clancy's The Division</a>)<br><br><br>
<br>Baking Systems: Pre-render static lights for better performance.
<br>Volumetric Effects: Add atmospheric depth with fog and light scattering.
<br>Custom Shaders: Fine-tune light interactions for specific materials.
<br>Node-Based Workflows and Code: Use visual tools for procedural lighting systems.
<br><br><br>
<br>Day/Night Cycles: Transition lighting over time to match environmental storytelling.
<br>Interactive Lighting: Lights that respond to player actions or environmental triggers.
<br>Color and Intensity Shifts: Create mood transitions or dramatic effects.
<br><br><br>
<br>Guidance: Direct player attention to objectives.

<br>Example: Highlight interactable objects or paths.


<br>Atmosphere: Build tension or mood.

<br>Example: Dim, flickering lights in a horror game.


<br>Puzzle Elements: Use light as an integral component of gameplay challenges.

<br>Example: Reflective surfaces or light-activated mechanisms.


<br><br><br><br>
<br>Layered Lighting: Combine ambient, direct, and dynamic sources for depth.
<br>Color Theory in Lighting: Use color to evoke emotions or set the scene‚Äôs tone.
<br>Light-Based Storytelling: Subtle shifts in lighting to hint at narrative progression.
<br><br><br>
<br>LOD Systems: Adjust lighting details based on distance.
<br>Render Pipelines (Graphics Pipeline): Use advanced pipelines for better control.
<br>Post-Processing: Enhance visuals without additional light sources.
<br><a data-tooltip-position="top" aria-label="https://www.geeksforgeeks.org/opengl-rendering-pipeline-overview/" rel="noopener nofollow" class="external-link" href="https://www.geeksforgeeks.org/opengl-rendering-pipeline-overview/" target="_blank">OpenGL Rendering Pipeline | An Overview</a><br>
<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Graphics_pipeline" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Graphics_pipeline" target="_blank">Graphics Pipelines</a><br><br><br><br><br>
<br>Emotion and Atmosphere:

<br>Colors evoke specific emotions and set the tone of a scene.
<br>Example: Warm colors like orange and red convey energy or danger, while cool colors like blue and green suggest calm or mystery.


<br>Player Guidance:

<br>Bright or contrasting colors naturally draw attention to key gameplay elements.
<br>Example: A glowing blue portal in a dimly lit room.


<br><br><br>
<br>Hue, Saturation, and Value (HSV):

<br>Hue: The color itself (e.g., red, blue, yellow).
<br>Saturation: The intensity or purity of the color.
<br>Value: The brightness or darkness of the color.


<br>Color Harmony:

<br>Complementary Colors: Opposite on the color wheel (e.g., blue and orange) create contrast.
<br>Analogous Colors: Side-by-side on the wheel (e.g., red, orange, yellow) create harmony.
<br>Triadic Colors: Equally spaced around the wheel for balance (e.g., red, yellow, blue).


<br>Color Temperature:

<br>Warm Colors: Reds, yellows, and oranges evoke energy and warmth.
<br>Cool Colors: Blues and greens create calm or distance.


<br><br><br><br><br>
<br>A previsualization tool that maps out the emotional journey of a game using color.
<br>Often used in animated films and games to ensure consistency and coherence in visual storytelling.
<br><br>
<br>Break down the game or level into key moments or scenes.
<br>Assign a dominant color palette to each moment based on its mood or theme.

<br>Example: Use red hues for high-intensity battles and softer blues for reflective or quiet moments.


<br>Create thumbnail sketches or storyboards with approximate lighting and color.
<br><a data-tooltip-position="top" aria-label="https://photography.tutsplus.com/tutorials/how-to-colourscripts-animation--cms-38391" rel="noopener nofollow" class="external-link" href="https://photography.tutsplus.com/tutorials/how-to-colourscripts-animation--cms-38391" target="_blank">How to Make a Color Script</a><br>
<a data-tooltip-position="top" aria-label="https://www.khanacademy.org/computing/pixar/art-of-lighting/introduction-to-virtual-lighting/a/exercise-5-color-scripts" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/computing/pixar/art-of-lighting/introduction-to-virtual-lighting/a/exercise-5-color-scripts" target="_blank">Color Scripting - Khan Academy</a><br><br><br><br>
<br>Color Temperature in Lighting:

<br>Use warm light for natural, inviting environments (e.g., sunlight or firelight).
<br>Use cool light for sterile or eerie settings (e.g., moonlight or fluorescent light).


<br>Color Grading in Post-Processing:

<br>Adjust the overall tone of a scene to emphasize mood.
<br>Example: Desaturate colors for a bleak, dystopian setting or enhance vibrancy for fantastical worlds.


<br>Dynamic Color Shifts:

<br>Change lighting color dynamically to reflect gameplay events or mood shifts.
<br>Example: A room flooding with red light during an alarm.


<br><br><br><br>
<br>Platform: High-spec PC and consoles (PS4/PS5, Xbox One/Series).
<br>Lighting Techniques Used:

<br>Dynamic Lighting: Utilizes real-time ray tracing for accurate reflections, shadows, and indirect lighting. Light changes dynamically as the player interacts with the environment or moves through different spaces.
<br>Global Illumination: Achieved through ray tracing to simulate realistic light bounces, enhancing immersion in its moody, supernatural world.
<br>Volumetric Lighting: Used extensively to create atmospheric effects like light beams filtering through dust or fog, amplifying the game's eerie tone.


<br>Optimization Techniques:

<br>Ray tracing is scaled back on lower-end systems by using approximations or turning off certain effects while maintaining the overall mood.
<br>Selective use of baked lighting for static geometry.


<br><br><br><br>
<br>Platform: Mobile devices.
<br>Lighting Techniques Used:

<br>Baked Lighting: Pre-calculated lightmaps are used for all scenes, ensuring the game runs smoothly on low-power devices while maintaining visual appeal.
<br>Ambient Occlusion: Baked into textures to give depth and definition to the minimalist geometric environments.
<br>Color as Light: Simple, vibrant color palettes imply lighting and shadow, reducing computational overhead while creating an artistic, dreamlike aesthetic.


<br>Optimization Techniques:

<br>Fixed camera angles and static environments allow for efficient pre-rendering.
<br>Minimal reliance on dynamic lights, focusing instead on artistic use of gradients and shading.


<br><br><br><br><br><br>
<br>How does each game leverage its lighting strategy to create a distinct mood and enhance the player experience?
<br>What challenges might developers face when scaling the lighting approach for different platforms or performance tiers?
<br>How do the artistic and technical choices in each game reflect the limitations or opportunities of their respective platforms?
<br><br><br><br>
<br>Use baked lighting for static elements.
<br>Add light probes for dynamic objects.
<br>Profile scene with Unity‚Äôs Profiler.
<br><br>
<br>Add spotlights to key areas.
<br>Use color grading for mood.
<br>Implement dynamic light triggers for interactivity.
<br><br><br>
<br>Lighting Attributes: Quality, quantity, direction.
<br>Optimization Tools: Lightmaps, probes, and profiling.
<br>Dynamic Techniques: Time-of-day, animated lights, interactive systems.
<br>Gameplay Integration: Light as a mechanic for guidance and immersion.
<br><br><br><br>
<br>Lighting Principles Are Universal: The same concepts apply across all major engines and tools.
<br>Always Iterate: Refine lighting to balance performance and aesthetics.
<br>Stay Curious: Explore how other games use light to innovate.
<br><br><br>
<br>How does lighting influence player decision-making?
<br>What challenges arise when balancing performance with high-quality lighting?
<br>How can you apply these concepts across different game engines or tools?
<br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\legacy\gmap-395-wk-3-slides.html</link><guid isPermaLink="false">GMAP 395/Module 1/legacy/GMAP 395 - WK 3 - Slides.md</guid><pubDate>Mon, 20 Jan 2025 19:17:15 GMT</pubDate><enclosure url="lib\media\6492c4abf65d6e4dfffbb89e_control_worldtrailer_quarry_sky-p-500.avif" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\6492c4abf65d6e4dfffbb89e_control_worldtrailer_quarry_sky-p-500.avif"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[<strong><em>Procedural Eldritch Portal + Environment: A Tutorial for Blender</em></strong>]]></title><description><![CDATA[ 
 <br><br><img alt="GMAP 395/Module 1/Media/395tut1portal.png" src="lib\media\395tut1portal.png" style="width: 640px; max-width: 100%;"><br><br><br>In this tutorial, we will create a Procedural "Eldritch Portal" Environment Art, an ominous and glowing gateway surrounded by rocky terrain and organic tendrils. This project aims to integrates procedural modeling techniques and node-based workflows to craft a dynamic and mystical game-based environment artifact.<br><br>
<br>Understand the Geometry Nodes system in Blender.
<br>Apply procedural workflows to create modular and reusable assets.
<br>Explore node-based techniques for attributes like scattering, randomization, and deformation.
<br>Gain insight into exporting assets for game engines like Unity.
<br>Reminder: Documentation is your best friend!
<a rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/index.html" target="_blank">https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/index.html</a>
<br>Intro Video: <br>
[gmap395_tut1_intro.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_Ewtu7qaLOfP_oFTQ?e=Dfjfxw)<br><br><br><br><br>
<br>Open Blender and create a new project.
<br>Switch to the Geometry Nodes workspace.

<br>This can be found on the top toolbar.


<br>Add a Plane (Shift + A &gt; Mesh &gt; Plane) and assign a new Geometry Nodes modifier.
<br>Name your Geometry Nodes setup descriptively, e.g., Rocky_Base_Geo.<br><br><br>
<br>Adding Noise Deformation: Use a Noise Texture and Displacement Modifier to create an uneven, rocky surface.

<br>Let's start by subdividing our plan to allow for more detail when we apply a noise function. Create a Subdivide Mesh node and plug the Group Input's geometry output into the mesh input slot. Adjust the subdivision Level to 6. 
<br>Next let's scale our plane to make more room. Create a Transform Geometry node and plug the mesh output of the subdivide mesh not into geometry input. Adjust the Scale property(attribute) to a desired size; but keep int under 5 for now just to keep things speedy/snappy.
<br>Now we can work on applying some noise distortion so our plane look smore like a terrain. We will need the following nodes: Set Position, Position(Read) Combine XYZ, and a Noise Texture

<br>Plug the geometry out from the transform node into the geometry input of Set Position. The geometry output from this node will go into the Group Output geometry input.
<br>Plug the Position(Read) into the position input of Set Position. What this does is get the position of our plane and makes sure set position uses its current position.
<br>Now the vector output of the Combine XYZ node will go into the offset input of Set Position.
<br>Finally the color output of Noise Texture will go into the Z input of Combine XYZ.

<br>From here you can adjust the values of the parameters for the noise node to reach a desired look. For more on how this node works and what those parameters mean have a look the the <a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/texture/noise.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/texture/noise.html" target="_blank">noise texture node documentation</a>.




<br>For reference we are performing a noise deformation similar to this video: <a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=LmPhbfb2DH8" target="_blank">https://www.youtube.com/watch?v=LmPhbfb2DH8</a>


<br>Scattering Rocks: Now let's scatter some "rocks" by using Point Distribution to scatter stand-in geometry and vary the size by Randomizing Attributes.

<br>We'll add a Distribute Points on Faces node to the end of the chain. So, the geometry output from Set Position will go into the mesh input. This randomly scatters points onto the surface of our terrain geometry base. Use the Density and Seed values to adjust the amount of points.
<br>Next we will need an Instance on Points node and an Ico Sphere node. Take the points output of the distribute node and plug it into the points input of the Instance on Points node. This is assigning the points we generated as the points we will not copy(instance) more geometry onto.
<br>Now we need to adjust the size of our "rocks" so they look a bit more "natural" by randomizing the scale. You'll now need a Random Value(Float) and another Combine XYZ node. Plug the value output of the Random Value into the XYZ of the combine node. The vector output of this node will go into the scale input of the Instance Geometry node. 

<br>If you want you can duplicate this section and apply it to the rotation of the instance node to randomize the rotation too.


<br>Adjust the Min, Max, and Seed values to achieve a desired look.


<br>
Section Recap: Now you've got a basic terrain base and some rocks scattered along the surface. The scattering and rock scale are randomized to provide a more natural look. If you want to later, you can procedurally model some rocks and replate the basic primitive used as a stand-in.  
<br>
[gmap395_tut1_p1.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_Ev1DF4vxnCCHC5jw?e=fayUeZ)<br><br><br><br><br>
<br>Start with a Base Shape:

<br>Add a Bezier Circle (Shift + A &gt; Curve &gt; Circle) to represent the outer edge of your portal. Name it appropriately, like portal_base_geo. Now assign a new geometry node modifier to it in the Geometry Nodes context. This provides a smooth and flexible base for the portal geometry.
<br>Drop down and Curve to Points node and an Instance on Points node. Adjust the Count of the curve points node to a number you like, I started with default 10. Plug the points output into the points input of the instance node.
<br>Now we need some geometry to instance onto the points of our curve to start making the portals base structure. create Cube(Primitive) and a Transform Geometry node. the mesh output of the cube will go into the geometry input of the transform node.

<br>Adjust the Scale(XYZ) of the transform node to get cubes of a desired size/shape.


<br>As you may have noticed, the cubes are all around the circle but their rotation does not face the form of the curve, we will fix that now. Create an Align Rotation to Vector node. This node can read the Normals or Tangent of the vector direction of the points along the curve and we can then assign that rotation to another object, like the cubes.

<br>Take the Tangent output of the Curve to Points node and plug it into the Vector input of the align node.
<br>The parameter values on the Align Rotation to Vector node I found most helpful are to pick the X axis (below Rotation), and set the Pivot to Z.
<br>Now the Rotation output of the align nodes goes to the Rotation input of the  Instance on Points node.
<br>This process is similar to what is found in this video: <a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=J4RpyR3jN-U" target="_blank">https://www.youtube.com/watch?v=J4RpyR3jN-U</a>




<br><br>
<br>Creating additional portal stones:

<br>Now that we have some basic stones for the portal we can duplicate some nodes and run essentially the same/similar operations to create the second set of stones.
<br>Start by creating  a Transform Geometry node; we will use this to offset the rotation of our points later. 
<br>Now you can duplicate(copy and paste) the nodes and connections for all of the nodes we used in Part 2 - Step 1 from above. Connect the Geometry output of the transform node into the Curve input of the newly duplicated Curve to Points node.
<br>Now, keep all of the connections in tact from the nodes that were copied. We can now just go back into some of the nodes and adjust some parameters to get more of a stone portal look.

<br>Start with the Transform Geometry node and adjust the Rotation(Z)  offset the second set of cubes.
<br>Adjust the Scale(XYZ) of the cubes transform geometry node to make the smaller and a little longer in the second set.




<br>To See All Geometry
You will need to temporarily connect the Instances output from  both Instance to Points nodes into a Join Geometry node, then connect that to the Group Output.
<br><br>
<br>Apply Boolean Operations:

<br>Drop down a Mesh Boolean node. If you used a Join Geometry node to see all of the geometry together, you can delete that now.
<br>The Mesh Boolean node will allow us to perform a boolean operation using the two sets of cube/stones we made for the portal. In this case we will use Union as the operation type and tick on both Self Intersection and Hole Tolerant.
<br>Now plug the Instances outputs from both chains/trees Instance on Points into the Mesh input of the Mesh Boolean. This can now be plugged into the main Group Output node.


<br>Filling the Portal
If you with to have a circular plane to fill the void in the portal (maybe for doing a shader later on) you can use a Fill Curve node. Just connect a new edge from the geometry output of the main Group Input node to it and then connect the Mesh output to the Mesh input of the Mesh Boolean 
<br>
Section Recap: Boolean operations allow us to create complex shapes by combining or subtracting simpler ones. Here, we use the smaller set of geometry to combine with the larger set of geometry, forming the portal‚Äôs basic structure. Now, if you wish to later, you can model better stone using the cubes as a base to make the portal look better.
<br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_EuJDcode-o2D6LIA?e=rsBx7O" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_EuJDcode-o2D6LIA?e=rsBx7O" target="_blank">gmap395_tut1_p2.mp4</a><br><br><br><br><br><br>
<br>Define Tendril Paths:

<br>Add a Curve Line (Shift + A &gt; Curve &gt; Curve Line) and then add a Transform Geometry node to a new modifier context.
<br>Us the transform node to adjust the Rotation(X) to around -90 degrees. Now we will essentially be using nodes used earlier in this tutorial to construct the rest of the tendrils. Create a Curve to Points node and an Instance on Points node. Adjust the Count of the curve points node to a larger number number, like 30. Plug the points output into the points input of the instance node.
<br>We will need another Align Rotation to Vector node. Connect it like before, where the vector comes from the Curve to Points tangent output and the rotation output goes to the rotation input of the Instance to Points.
<br>Create another Mesh Boolean node and plug the Instances output from instance points into the Mesh input.

<br>You will need to set the boolean nodes parameters to Union and Exact respectively.


<br>


<br><br>
<br>Adding Tendrils to their place :

<br>We will use a Curve Circle node with a 0.5 Radius as a frame for the tendrils to be spawned on to. So, create this now.
<br>Then, use another Curve to Points node and Instance to Points node combo to create a 6 Count points and instance the tendrils onto those points. 

<br>Connect the Mesh output of the Mesh Boolean from earlier to the Instances input.


<br>You'll use another Align Rotation to Vector node to get the Tangent from the curve points to the vector input. Then the Rotation output from this node matches to the Rotation input of the Instance on Points.
<br>To create a more "natural" look we will add some random roatation so the tendrils are not all uniform. Grab a Random Value node set to Vector. Max value are 0.0, 0.1, and 1.90.

<br>The Value output goes to the Rotation input of a Rotate Instances node. This connects to the Instance on Points and the Group Output nodes. You can also use a Transform Geometry node to move all the tendrils into place.




<br>
[gmap395_tut1_p3.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_EtzgD0ilFKv0Moww?e=JO4ROa)<br><br><br>Optimization and Export
We will do the optimization and mesh export in week 3 before importing to Unity. Just be sure to have some procedural game art ready to go.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\tutorials\gmap-395-wk-2-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 1/tutorials/GMAP 395 - WK 2 - Tutorial.md</guid><pubDate>Mon, 20 Jan 2025 19:16:51 GMT</pubDate><enclosure url="lib\media\395tut1portal.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\395tut1portal.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Lab Exercise: Lighting, Post-Processing, and Dynamic Camera in Unity URP]]></title><description><![CDATA[ 
 <br><br><br>In this lab, you'll create a simple 3D scene using the Universal Render Pipeline (URP), apply basic lighting techniques and a dynamic day-night cycle that affects gameplay and mood. This scene will be incorporating you Procedural Game Art Asset from Module 1 - Part 1.<br><br>
<br>Unity 2022.3 LTS or later
<br>Basic familiarity with the Unity interface
<br>Basic familiarity with C# scripting in Unity
<br><br><br><br><br><br>We will need to do some very simple <a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/meshes/retopology.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/meshes/retopology.html" target="_blank">Retopology</a> in blender with out geometry then apply some simple <a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/meshes/uv/index.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/meshes/uv/index.html" target="_blank">UVs</a> before we export and import into Unity.<br><br>Modularity and Reuse
We will be doing the following operations to all of our procedural geometry. So just pick one object from Part 1 and and follow along (e.g. start with tendrals_base_geo).
<br>For this portion of the tutorial watch and follow along with the video from Entagma, on doing the Retopology and UV Unwrapping procedurally using geometry nodes. You will apply this same process to all sections of the procedural game art from Part 1. <br>Blender Tutorial: Procedural UV Unwrapping with Geometry Nodes

<a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=02XNGOVpSV4" target="_blank">https://www.youtube.com/watch?v=02XNGOVpSV4</a>
<br>Types of Retopology
It is important to note that we are aiming for a quick version of retopology that is rapid for our prototyping in this course. IF you were going to work on retopology for animation, it would be best to do a more traditional method like Quad Remeshing with some manual retopology. Like in this video: <a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=hQ8HvDuSWCQ" target="_blank">https://www.youtube.com/watch?v=hQ8HvDuSWCQ</a>
<br><br>
<br>
Create a new URP 3D Unity project.

<br>When creating a new project, select "3D (URP)" as the template.


<br>
In the Hierarchy window, right-click and select 3D Object &gt; Plane to create a ground plane. ONLY IF NEEDED.

<br><br>If using Blender Geometry Nodes, to properly export that geometry to a useful data format like FBX or glTF. You will need to first Realize Instances then Apply the geometry modifiers to make a static piece of geometry in Blender. You can see this is action in Part 2 from the Video Tutorials above.<br><br><br><a rel="noopener nofollow" class="external-link" href="https://blender.community/c/rightclickselect/G9Jy/?sorting=hot" target="_blank">https://blender.community/c/rightclickselect/G9Jy/?sorting=hot</a><br>Tip
Use different materials for each object to make them visually distinct. Select each object, create a new material (right-click in Project window &gt; Create &gt; Material), and set a unique color in the Inspector. Make sure to use the "Universal Render Pipeline/Lit" shader for these materials.
<br><br><br>
<br>
The default URP project comes with a Directional Light. Adjust its settings:

<br>Set the Directional Light rotation to (50, -30, 0) and reduce its Intensity to 0.5.


<br>
Create two additional lights:

<br>Create a Point Light (GameObject &gt; Light &gt; Point Light)
<br>Create a Spot Light (GameObject &gt; Light &gt; Spot Light)


<br>
Configure the lights:

<br>Position the Point Light at (0, 3, 0) and set its Range to 10. Set intensity to 5
<br>Position the Spot Light at (-5, 5, -5), rotate it to (45, 45, 0), and set its Range to 15 and Spot Angle to 30. Set intensity to 35
<br>Set all of the lights' Mode to Mixed in their Light component settings.<br>
<img alt="lightingMode.png" src="lib\media\lightingmode.png">


<br>Connection to Lecture
Each Light type serves a specific purpose in lighting your scene. The Directional Light acts as your main light source (like the sun), while Point and Spot Lights add depth and focus to specific areas.
<br>
<br>Experiment with light colors:

<br>Set the Directional Light to a warm color (e.g., FFF4E0).
<br>Set the Point Light to a cool blue color (e.g., ADD8E6).
<br>Set the Spot Light to a subtle purple (e.g., 8A2BE2).<br>
<img alt="colorHexCode.png" src="lib\media\colorhexcode.png">
Tip
Use color theory to create mood and depth in your scene. Warm colors tend to advance (appear closer), while cool colors recede (appear farther away).




<br><br><br>
<br>
Create a new empty GameObject and name it "DayNightController".

<br>
Add a new script to this object, also named "DayNightController".

<br>
Open the script and add the following code:

<br>using UnityEngine;

public class DayNightController : MonoBehaviour
{
    public Light sunLight;
    public float dayDuration = 60f; // One day every 60 seconds
    
    public float timeOfDay = 0.25f; // Start at 6:00 AM

    void Update()
    {
        timeOfDay += Time.deltaTime / dayDuration;
        if (timeOfDay &gt;= 1f) timeOfDay -= 1f;

        float sunRotation = timeOfDay * 360f;
        sunLight.transform.rotation = Quaternion.Euler(sunRotation, 230f, 0);
    }
}
<br>
<br>Create a Directional Light for the sun (only if one does not already exist) and assign it to the sunLight variable in the DayNightController component.
<br><img alt="sunLight.png" src="lib\media\sunlight.png"><br>Sun Position
The sun's starting rotation of (90, 230, 0) positions it in the east at the start of the day.
<br><br>
<br>Modify the DayNightController script to change the sun's color based on the time of day:
<br>public class DayNightController : MonoBehaviour
{
    // ... previous code ...

    public Gradient sunColor;

    void Update()
    {
        // ... previous update code ...

        sunLight.color = sunColor.Evaluate(timeOfDay);
    }
}
<br>
<br>In the Inspector, set up the color gradient for the sun:

<br>Morning: Soft orange
<br>Midday: Bright white
<br>Evening: Deep orange
<br>Night: Dark blue


<br><img alt="sunColor.png" src="lib\media\suncolor.png"><br>Color Selection
Use warm colors for sunrise/sunset and cool colors for night to create a more realistic atmosphere.
<br>
<br>Extend the DayNightController script to modify the sun's intensity:
<br>public class DayNightController : MonoBehaviour
{
    // ... previous code ...
    public AnimationCurve lightIntensityCurve;

    void Update()
    {
        // ... previous update code ...
        
        // Update sun intensity
        float intensityMultiplier = lightIntensityCurve.Evaluate(timeOfDay);
        sunLight.intensity = intensityMultiplier * 1.5f; // Base intensity of 1.5
    }
}
<br>
<br>In the Inspector, set up the Light Intensity Curve:

<br>Create an AnimationCurve with the following key points:

<br>Time 0.0 (Midnight): Value 0.1
<br>Time 0.25 (Sunrise): Value 0.8
<br>Time 0.5 (Noon): Value 1.0
<br>Time 0.75 (Sunset): Value 0.8
<br>Time 1.0 (Midnight): Value 0.1




<br><img alt="sunIntensity.png" src="lib\media\sunintensity.png"><br>Light Intensity
The intensity curve allows for smooth transitions between day and night, with peak brightness at noon and minimum at midnight.
<br>
<br>Adjust the base intensity (1.5f in the example) to fit your scene's lighting needs.
<br>Fine-tuning
Experiment with different intensity values and curve shapes to achieve the desired lighting effect for your specific environment.
<br><br><br>
<br>
Open the Lighting window:

<br>Go to Window &gt; Rendering &gt; Lighting


<br>
Familiarize yourself with the Lighting window:

<br>Scene: Contains general lighting settings for the current scene
<br>Environment: Controls skybox and ambient lighting and fog
<br>Realtime Lightmaps: Shows real-time lightmaps
<br>Baked Lightmaps: Shows baked lightmaps


<br>Connection to Lecture
The Lighting window is your central hub for controlling global lighting settings and baking lightmaps.
<br><img alt="lightingWindow.png" src="lib\media\lightingwindow.png"><br>
<br>
Create a Lighting Settings Asset:

<br>In the Lighting window, click "New" next to "Lighting Settings Asset"
<br>Save it as "MainLightingSettings" in your project's Settings folder


<br>
Configure Lighting Settings:

<br>In the Scene section

<br>Create a new Lighting Settings Asset

<br>Name it "LightSettings_" + your scene name 


<br>Turn on Realtime Global Illumination

<br>Adjust Indirect Resolution to 2 Texels Per Unit




<br>In the Environment section:

<br>Set Skybox Material to "Default-Skybox"
<br>Change Sun Source to your scene Directional Light


<br>In the Mixed Lighting section:

<br>Set Lighting Mode to "Baked Indirect"


<br>In the Lightmapping Settings section:

<br>Set Lightmapper to "Progressive GPU (Preview)"
<br>Leave the default settings for now. You can adjust with these later.




<br>
Open the Light Explorer:

<br>Go to Window &gt; Rendering &gt; Light Explorer
<br>The Light Explorer has taps to access quick settings changes for Lights, 2D Lights, Reflection Probes, Light Probes, and Static Emissives.


<br>
Use the Light Explorer to quickly adjust multiple lights:

<br>Review and adjust thing like the Mode, Intensity, and Range of your lights among other settings.


<br>Tip
The Light Explorer is excellent for getting an overview of all lights in your scene and making bulk adjustments.
<br><img alt="lightExplorer.png" src="lib\media\lightexplorer.png"><br>
<br>
Prepare for lightmap baking:

<br>Select all static objects in your scene (ground plane and any non-moving objects)
<br>In the Inspector, check "Static" at the top
<br>Expand the Static dropdown and ensure "Contribute Global Illumination (Contribute GI)" is checked


<br>
Generate lighting:

<br>In the Lighting window, scroll to the bottom
<br>Click "Generate Lighting"
<br>Wait for the baking process to complete


<br>Important
Lightmap baking can take some time, especially for complex scenes. Be patient!
<br>Warning
It is not recommended to tick on Auto Generate. This is because lighting will constantly cook anytime a change is made. For very large scene with Mixed or Baked lighting, this can take hours and slows down the Unity Editor.
<br>
<br>Review the results:

<br>Once baking is complete, examine your scene in both the Scene and Game views
<br>Look for any areas where the lighting seems off or could be improved


<br><br><br>
<br>
Create a new material:

<br>In the Project window, right-click &gt; Create &gt; Material
<br>Name it "EmissiveMaterial"


<br>
Configure the emissive material:

<br>Select the EmissiveMaterial in the Project window
<br>In the Inspector, ensure the Shader is set to "Universal Render Pipeline/Lit"
<br>Scroll down to the Emission section
<br>Check the "Emission" box to enable it
<br>Click the color picker next to Emission to choose a color (e.g., a bright blue 00FFFF)
<br>Set the Emission color Intensity to 2 (you can adjust this value to increase or decrease the glow intensity)


<br>
Apply the emissive material:

<br>Drag the EmissiveMaterial onto the Sphere in your scene.
<br>Place another primitive object close to the sphere with the emissive material applied.


<br>How Emissive Materials Work
Emissive materials simulate light-emitting surfaces. They don't actually emit light that affects other objects in real-time, but they appear to glow and can contribute to the overall lighting of the scene when lighting is generated.
<br><img alt="emissiveMat.png" src="lib\media\emissivemat.png"><br>
<br>
Observe the difference in Realtime vs Baked lighting: For Realtime:

<br>The emissive object will appear to glow.
<br>If the object is marked as "Static" in the Inspector, it can contribute to real-time Global Illumination (GI).
<br>Open the Light Explorer (Window &gt; Rendering &gt; Light Explorer) and ensure the emissive object has "Contribute Global Illumination" checked.
<br>Non-static (dynamic) emissive objects will not affect GI but will still glow.

For Baked:

<br>Make sure the Sphere is marked as "Static" in the Inspector.
<br>In the Lighting window, under Baked Lightmaps, ensure "Baked Global Illumination" is enabled.
<br>Click "Generate Lighting" to bake the lighting.


<br>Emissives and Global Illumination In both realtime and baked scenarios, static emissive materials can contribute to global illumination, subtly lighting nearby surfaces. This creates a more realistic and integrated lighting effect. However, moving (dynamic) emissive objects are not supported.<br>Performance Consideration Realtime GI from emissive materials can be performance-intensive. For mobile or performance-critical projects, consider using baked lighting or limiting the use of emissive materials that contribute to realtime GI.<br>
<br>
Experiment with static vs dynamic emissive objects:

<br>Create a copy of your emissive sphere and place it in the scene.
<br>Keep one sphere marked as "Static" and the other unmarked.
<br>Compare how they interact with the environment in both realtime and baked lighting scenarios.


<br>
Iterate and refine:

<br>Adjust light settings, object materials, or lightmapping settings as needed
<br>Regenerate lighting after making significant changes


<br>Connection to Lecture
Baked lighting is crucial for performance in many games, especially on mobile or VR platforms. It allows for complex lighting scenarios without the performance cost of real-time lights.
<br>Experiment
Try adjusting the light positions, intensities, and colors. See how these changes affect the mood of your scene. Also, experiment with different post-processing settings to achieve various visual styles.
<br><br><br>Post Processing Lesson
We will revisit Post Processing at a later time in the course in more detail, for now, we need it to comprehend Emissive Materials and how they affect lighting.
<br>
<br>
Set up the Post-Processing Volume:

<br>Create a Global Volume (GameObject &gt; Volume &gt; Global Volume)


<br>
Create a Post-Processing Profile:

<br>Create a Rendering folder in your Project window.
<br>In the Project window, right-click &gt; Create &gt; Volume Profile.
<br>Name it "Main Profile".
<br>Drag this profile into the Profile slot of your Global Volume component.


<br>
Add and configure effects:

<br>Select the "Main Profile" in the Project window.
<br>Click Add Override and add the following:

<br>Bloom
<br>Color Adjustments (URP uses this instead of Color Grading)
<br>Vignette




<br>
Configure the effects:

<br>Bloom: Set Intensity to 1 and Threshold to 0.9.
<br>Color Adjustments: Change Contrast to 10 and Saturation to 10. Give the Color Filter a slightly warmer or cooler tone using the color picker.
<br>Vignette: Set Intensity to 0.4 and Smoothness to 0.3.<br>
<img alt="globalVolume.png" src="lib\media\globalvolume.png">


<br>Connection to Lecture
Post-processing effects are applied after the scene is rendered, similar to filters in photo editing software. They can dramatically enhance the mood and style of your game.
<br>
<br>Enable post-processing on the camera:

<br>Select the Main Camera in the Hierarchy.
<br>Ensure it has a "Universal Additional Camera Data" component.
<br>Under the Rendering section tick on Post Processing
<br>In this component, set "Render Type" to "Base" if it isn't already.<br>
<img alt="cameraPP.png" src="lib\media\camerapp.png">


<br>Important
If you don't see any change, ensure that your Scene View is set to have Post-Processing turned on using the top right hotbar.
<br><br>
<br>
Create a Light Probe Group:

<br>In the Hierarchy, right-click &gt; Light &gt; Light Probe Group


<br>
Position Light Probes:

<br>With the Light Probe Group selected, you'll see spheres in the scene view
<br>Position these spheres around your scene, focusing on areas where dynamic objects will move. 
<br>Select the Light Probe Group in the Hierarchy. In the Inspector, click Edit Light probe Positions. You can now move the yellow spheres.
<br>Place probes near corners, under overhangs, and in open areas. Anywhere where moving objects or better lighting data is needed.
<br>Aim for a good coverage without overdoing it (start with about 8-10 probes for our small scene)


<br><img alt="editLightProbe.png" src="lib\media\editlightprobe.png"><br>Light Probe Placement
Think of light probes as sampling points for lighting. Place them where you want dynamic objects to pick up lighting information, especially in areas with significant lighting changes or dynamic objects.
<br>
<br>
Create a dynamic object:

<br>Add a new cube to your scene (GameObject &gt; 3D Object &gt; Cube)
<br>Position it slightly above the ground plane
<br>Ensure it's not marked as Static in the Inspector


<br>
Set up a simple movement script:

<br>Create a new script called "ObjectMover"
<br>Add this script to your new cube
<br>Open the script and replace its contents with:


<br>using UnityEngine;

public class ObjectMover : MonoBehaviour
{
    public float speed = 2f;
    public float distance = 4f;

    private Vector3 startPosition;

    void Start()
    {
        startPosition = transform.position;
    }

    void Update()
    {
        float newX = startPosition.x + Mathf.Sin(Time.time * speed) * distance;
        transform.position = new Vector3(newX, transform.position.y, transform.position.z);
    }
}
<br>
<br>
Bake lighting:

<br>Ensure your static objects are marked as Static
<br>Open the Lighting window (Window &gt; Rendering &gt; Lighting)
<br>Click "Generate Lighting" to bake your lightmaps and light probes


<br>
Observe the results:

<br>Play the scene and watch how the moving cube picks up lighting information from the probes
<br>The cube should show smooth lighting transitions as it moves through different areas of your scene


<br>Light Probes and URP
In URP, Light Probes work seamlessly with the scriptable render pipeline, providing efficient lighting for dynamic objects in both forward and deferred rendering paths.
<br>
<br>Experiment with probe placement:

<br>Try adding more probes or adjusting their positions
<br>Rebake lighting and observe how it affects the lighting on your moving cube


<br>Performance Consideration
While Light Probes are more performance-friendly than real-time lighting, too many probes can increase memory usage and baking times. Start with a minimal set and add more only where needed.
<br>
<br>Combine with emissive materials:

<br>Try placing some light probes near your emissive object from the previous sections
<br>Observe how the moving cube picks up the glow from the emissive object as it passes nearby


<br><br><br>
<br>
Add a Sphere your scene and ensure it is set to Static

<br>
Create a highly reflective material for the sphere. Something with full Metallic Map and Smoothness should work.<br>
<img alt="metalMaterial.png" src="lib\media\metalmaterial.png">

<br>
Add a reflection probe to your scene:

<br>Right-click &gt; Light &gt; Reflection Probe
<br>Generally, place probes in key areas of your environment (e.g., near water bodies, in the center of clearings) where accurate reflections are needed. 

<br>Place this probe around the sphere with the reflective material.




<br>
Configure the Reflection Probe:

<br>Set the Type to Realtime
<br>Set Refresh Mode to Every Frame
<br>Adjust the Box Size to cover the desired area


<br>Real-time Reflection Probes
Setting the Reflection Probe to update every frame ensures that it will always reflect the current state of your scene, including changes in lighting from the day/night cycle. However, be aware that this can be performance-intensive, especially for larger or more complex scenes.
<br>
<br>(Optional) For performance optimization, you can adjust the Time Slicing setting:

<br>Set Time Slicing to All Faces At Once for immediate updates (more performance-intensive)
<br>Or choose "Individual Faces" to spread the update over multiple frames (better performance, slight delay in reflections)


<br>Performance Considerations
If you notice performance issues, consider reducing the update frequency or using a mix of real-time and baked probes in your scene. You can also adjust the resolution of the probe to balance between quality and performance.
<br>Reflection Probes
Reflection probes will now update as the day-night cycle progresses, providing dynamic reflections that match the changing lighting conditions.
]]></description><link>gmap-395\module-1\tutorials\gmap-395-wk-3-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 1/tutorials/GMAP 395 - WK 3 - Tutorial.md</guid><pubDate>Wed, 22 Jan 2025 16:15:57 GMT</pubDate><enclosure url="lib\media\lightingmode.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="lib\media\lightingmode.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Course Theme: So What About Tomorrow?]]></title><description><![CDATA[ 
 <br><br>Theme Overview So What About Tomorrow? is an open-ended exploration of temporal concepts, technological evolution, and speculative futures. 
This theme invites students to consider relationships between past, present, and future through their art and technical work. 
Rather than prescriptive guidelines, this framework offers creative starting points that can be interpreted broadly across many visual styles and conceptual approaches.
<br><br><br><br>"So What About Tomorrow?" can be approached from multiple angles:<br>
<br>How does technology evolve and change over time?
<br>What stories do objects tell about their past and potential futures?
<br>How do we visualize concepts of progress, decay, hope, or uncertainty?
<br>What aesthetic choices communicate temporal relationships?
<br><br>Students may explore any aspect of "tomorrow" that interests them:<br>
<br>Technological Speculation: Future tools, interfaces, or environments
<br>Temporal Archaeology: Past technologies reimagined or rediscovered
<br>Evolution and Change: Transformation processes over time
<br>Utopian/Dystopian Visions: Optimistic or cautionary futures
<br>Cyclical Time: Recurring patterns or circular progression
<br>Personal Tomorrow: Individual hopes, fears, or expectations
<br><br><br>Visual Suggestions (Not Requirements) These are starting points for inspiration - students are encouraged to develop their own visual language that serves their interpretation of the theme.<br><br>One possible interpretation focusing on technological archaeology<br><br>
<br>Primary Colors: Deep blues (#0A1628), steel grays (#2C3E50), charcoal blacks (#1C1C1C)
<br>#0A1628#2C3E50#1C1C1C<br>
<br>Accent Colors: Electric cyan (#00D4FF), plasma purple (#8A2BE2), warning amber (#FF8C00)
<br>#00D4FF#8A2BE2#FF8C00<br>
<br>Organic Elements: Copper patina (#B87333), moss green (#228B22), rust orange (#CC5500)
<br>#B87333#228B22#CC5500<br><br>
<br>Temporal Layering: Showing multiple time periods in one object
<br>Wear and Evolution: How materials change and age over time
<br>Synthetic vs. Organic: Contrasting artificial and natural elements
<br>Information as Physical: Data visualization made tangible
<br><br>
<br>Contrast: Sharp differences between old and new elements
<br>Revelation: Lighting that discovers or uncovers hidden details
<br>Atmosphere: Environmental mood that suggests time passage
<br>Focus: Directing attention to key temporal relationships
<br><br><br><br>Core Question: How can "So What About Tomorrow?" guide the creation of a cohesive, interactive game art experience?<br><br>Scene Foundation: How do we create modular systems that tell temporal stories?<br>
<br>Procedural Systems: What rules can generate assets that show change or evolution over time?
<br>Modular Architecture: How can components be recombined to suggest different temporal states?
<br>Dynamic Lighting: What lighting changes could represent the passage of time or reveal hidden temporal layers?
<br>Environmental Storytelling: How do procedural elements and lighting work together to communicate your vision of "tomorrow"?
<br><br>Surface Narratives: How do materials express temporal concepts through interaction?<br>
<br>Dynamic Shaders: What material properties change to show time, use, or environmental response?
<br>Interactive Materials: How do surfaces respond to player interaction to reveal temporal stories?
<br>Visual Consistency: How do custom shaders maintain your interpretation of the theme across different objects?
<br>Performance Integration: How do shader effects enhance the scene without breaking real-time performance?
<br><br>Atmospheric Storytelling: How do effects systems bring temporal concepts to life?<br>
<br>Environmental Integration: What particle systems enhance your scene's temporal atmosphere?
<br>Reactive Systems: How do effects respond to player interaction or environmental changes?
<br>Modular Effects: How can particle systems be reused and recombined for efficiency?
<br>Narrative Support: How do effects reinforce your interpretation of "tomorrow" without overwhelming the scene?
<br><br>Experiential Presentation: How do camera systems guide the player through your temporal narrative?<br>
<br>Dynamic Perspective: What camera movements or transitions reveal different aspects of your "tomorrow"?
<br>Interactive Focus: How does the camera system respond to player interaction to highlight temporal elements?
<br>Post-Processing Integration: How do visual effects enhance the mood and readability of your temporal concept?
<br>Cohesive Experience: How do camera and post-processing unify all other technical elements into a single vision?
<br><br>Scene Cohesion: How do all technical elements work together to create a unified interactive experience?<br>
<br>Theme Unity: How do procedural assets, shaders, effects, and camera work together to express your vision of "tomorrow"?
<br>Interactive Flow: How does player interaction reveal different aspects of your temporal concept across all systems?
<br>Technical Harmony: How do performance considerations influence creative decisions while maintaining thematic integrity?
<br>Portfolio Presentation: How does your final scene demonstrate both technical competency and personal artistic vision?
<br><br><br><br>
<br>Technical Skills (60%): Competency in procedural workflows, regardless of aesthetic
<br>Creative Application (25%): Thoughtful interpretation of theme through personal lens
<br>Professional Practice (15%): Documentation, presentation, and critique participation
<br><br>
<br>Process Discussion: How did temporal concepts influence technical decisions?
<br>Conceptual Development: What aspects of "tomorrow" are you exploring?
<br>Peer Learning: How do different interpretations inspire new approaches?
<br>Technical Problem-Solving: How did theme requirements challenge or support skill development?
<br><br><br><br>This open-ended approach can be adapted to different concepts:<br>
<br>"What If...?" - Speculative design and alternative realities
<br>"Where We've Been" - Historical interpretation and archaeological imagination
<br>"In Between Spaces" - Liminal areas and transitional concepts
<br>"The Invisible Made Visible" - Revealing hidden systems and processes
<br><br>
<br>Core framework: Open question + suggested approaches + student freedom
<br>Technical integration: Theme serves skill development, not the reverse
<br>Assessment consistency: Evaluation focuses on competency and growth
<br>Cultural inclusivity: Themes accommodate diverse perspectives and interpretations
<br><br><br><br>
<br>Science Fiction: Literature, film, and games exploring future concepts
<br>Design Movements: Historical approaches to imagining tomorrow
<br>Cultural Futurism: Different cultural perspectives on time and progress
<br>Technology Evolution: How tools and interfaces have changed over time
<br>Personal Reflection: Individual hopes, fears, and expectations about change
<br><br><br>Return to Main Page: <a data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - Welcome</a>]]></description><link>gmap-395\gmap-395-su25-theme.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - SU25 - Theme.md</guid><pubDate>Tue, 01 Jul 2025 19:26:18 GMT</pubDate></item><item><title><![CDATA[Blender Tutorial for Complete Beginners - Part 1]]></title><description><![CDATA[ 
 <br>If you're completely new to Blender and geometry nodes, watch these two YouTube tutorials. They provide an excellent introduction to getting started with the software. Don't worry about mastering Blender immediately‚Äîyou'll become more comfortable as you use it more (this applies to any tool or software).<br><br>
https://www.youtube.com/watch?v=B0J27sf9N1Y<br><br>
https://www.youtube.com/watch?v=aO0eUnu0hO0<br><br>In this demo video (similar to the one given during our Week 1 class) we are trying to create a system of rules/algorithms/procedures for turning any mesh geometry into In this demo video (similar to the one shown in our Week 1 class), we're creating a system of rules, algorithms, and procedures for converting any mesh geometry into "Lego" bricks. The approach is based on this <a data-tooltip-position="top" aria-label="https://www.sidefx.com/tutorials/foundations-nodes-networks-assets/" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/tutorials/foundations-nodes-networks-assets/" target="_blank">Houdini FX Tutorial</a>. The logic behind this modular and procedural system uses common procedural modeling techniques like "copy to points" and node-based vertex manipulation. Some of these concepts are covered in <a data-href="GAMP 395 - Introduction - B" href="gmap-395\introduction\gamp-395-introduction-b.html" class="internal-link" target="_self" rel="noopener nofollow">GAMP 395 - Introduction - B</a>.<br><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/c/b08de2251f1b33a4/EZbAoCrnYH5Asb8vXSRHDuIBTicoVBNRYG9MqLdZayIxHw?e=fhG2wo" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/c/b08de2251f1b33a4/EZbAoCrnYH5Asb8vXSRHDuIBTicoVBNRYG9MqLdZayIxHw?e=fhG2wo" target="_blank">gmap_395_blendDemo_wk1.mp4</a><br><br><br>Module Navigation 
See: <a data-tooltip-position="top" aria-label="GMAP 395 - Introduction - B" data-href="GMAP 395 - Introduction - B" href="GMAP 395 - Introduction - B" class="internal-link" target="_self" rel="noopener nofollow">Module IB</a>  for similar topics<br>
Return to: <a data-tooltip-position="top" aria-label="GMAP 395 - Introduction and Overview" data-href="GMAP 395 - Introduction and Overview" href="gmap-395\introduction\gmap-395-introduction-and-overview.html" class="internal-link" target="_self" rel="noopener nofollow">Module Page</a>
]]></description><link>gmap-395\introduction\gmap-395-introduction-blender-gn-demo.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - Introduction - Blender GN Demo.md</guid><pubDate>Thu, 26 Jun 2025 17:46:08 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 1 - Slides]]></title><description><![CDATA[ 
 <br><br><br><br><br>
<br>Purpose: 

<br>Introduction to procedural real-time game systems and technical art production, exploring workflows in game engines w/ DCCs.


<br>Key Topics:

<br>Procedural and modular workflows.
<br>Real-time systems and node-based workflows.
<br>Shader development and VFX
<br>Lighting systems and camera effects.


<br><br><br>
<br>Definition: The process of designing interactive systems that facilitate structured play.
<br>Core Focus:

<br>Create rules and systems that encourage meaningful interaction.
<br>Design experiences that resonate emotionally and intellectually with players.


<br>--<br><br>
<br>Why Game Design Matters:

<br>Engage players through creativity and interactivity.
<br>Fulfill human needs for autonomy, relatedness, and competence.


<br>Player-Centric Motivations + Goals:

<br>Autonomy: The need to feel in control and make choices that align with your values and priorities.
<br>Relatedness: The need to feel connected to and supported by others.
<br>Competence: The need to feel capable and have the skills and resources to do something.


<br>Self-Determination Theory
<a rel="noopener nofollow" class="external-link" href="https://www.urmc.rochester.edu/community-health/patient-care/self-determination-theory" target="_blank">https://www.urmc.rochester.edu/community-health/patient-care/self-determination-theory</a><br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=3vct13OhIio" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=3vct13OhIio" target="_blank">"The Freedom Fallacy"</a>
<br>--<br><br>
<br>Rules:

<br>The boundaries that define what players can and cannot do.
<br>Examples: Movement rules, scoring systems, and constraints.


<br>Systems:

<br>Interconnected rules that shape gameplay experiences.
<br>Examples: Resource management, combat mechanics, or crafting systems.


<br>Player Experience:

<br>The overarching goal of game design is to evoke emotions and sustain player engagement.


<br>--<br><br>
<br>Conceptualize:

<br>Generate ideas and define the game‚Äôs objectives.
<br>Example Activities:

<br>Brainstorm themes and mechanics.
<br>Identify the target audience.




<br>Prototype:

<br>Create a basic, playable version of the game.
<br>Example Activities:

<br>Build a simple demo with placeholder assets.




<br>Playtest:

<br>Test with real players to observe how they interact with the game.
<br>Example Activities:

<br>Record player feedback.




<br>Evaluate:

<br>Analyze feedback and refine mechanics and systems.
<br>Example Activities:

<br>Identify areas of improvement.
<br>Implement changes and repeat the cycle.




<br>--<br><br>
<br>Continuous Improvement:

<br>Iteration allows designers to refine ideas based on real-world feedback.


<br>Learning from Failure:

<br>Unsuccessful elements provide insights for improvement.


<br>Key Takeaway: The best games are shaped through repeated cycles of creation, testing, and refinement.
<br>On Iteration:
"Iteration is the backbone of game design‚Äîit's where great games are born."
<br>
<br><a data-tooltip-position="top" aria-label="https://gamedesignskills.com/game-design/iterative-process/" rel="noopener nofollow" class="external-link" href="https://gamedesignskills.com/game-design/iterative-process/" target="_blank">How to Apply the Iterative Process in Game Design</a>
<br><a data-tooltip-position="top" aria-label="https://www.gamedeveloper.com/design/making-better-games-through-iteration" rel="noopener nofollow" class="external-link" href="https://www.gamedeveloper.com/design/making-better-games-through-iteration" target="_blank">Making Better Games Through Iteration</a>
<br><br>--<br><br>
<br>Games as Everyday Things:

<br>Video games are modern artifacts of daily interaction, much like physical tools or interfaces.
<br>Designing games requires the same care and consideration as designing everyday objects.


<br><img alt="GMAP 395/Introduction/media/design-everyday-things.jpg" src="gmap-395\introduction\media\design-everyday-things.jpg"><br>--<br><br>Key principles from The Design of Everyday Things<br>
<br>Affordances:

<br>Elements that suggest how they should be used.


<br>
<br>In games: A glowing door suggests it can be opened, or a bouncy surface implies jumping.
<br>
<br>Constraints:

<br>Limitations that guide user interaction.
<br>In games: Invisible walls, restricted areas, or locked abilities.


<br>Feedback:

<br>Immediate response to actions.
<br>In games: Sound effects, visual cues, or vibrations indicating success or failure.


<br>Signifiers:

<br>Visual or auditory cues that communicate functionality.
<br>In games: Icons, markers, or prompts that guide players.


<br>--<br><br>
<br>Clarity in Design:

<br>Clear affordances and signifiers reduce player frustration.


<br>Player Intuition:

<br>Well-designed constraints and feedback align with natural player expectations.


<br>Games as Interfaces:

<br>Like everyday tools, games rely on good design to be engaging and accessible.


<br>Further Reading:

<br><a data-tooltip-position="top" aria-label="https://ia902800.us.archive.org/3/items/thedesignofeverydaythingsbydonnorman/The Design of Everyday Things by Don Norman.pdf" rel="noopener nofollow" class="external-link" href="https://ia902800.us.archive.org/3/items/thedesignofeverydaythingsbydonnorman/The%20Design%20of%20Everyday%20Things%20by%20Don%20Norman.pdf" target="_blank">The Design of Everyday Things by Don Norman</a>
<br>



<br><br><br>
<br>Definition:

<br>Play is an activity undertaken for enjoyment, creativity, and engagement.


<br>Characteristics of Play:

<br>Voluntary: A self-chosen activity, not obligatory.
<br>Imaginative: Often involves creativity, make-believe, or exploration.
<br>Intrinsically Motivated: Done for its own sake, without external rewards.
<br>Bounded: Occurs within defined limits (rules, time, or space).


<br>Why Play Matters:

<br>Satisfies intrinsic human needs like autonomy, competence, and relatedness.


<br>Explore More:
<a data-tooltip-position="top" aria-label="https://nifplay.org/play-science/scientific-disciplines-researching-play/" rel="noopener nofollow" class="external-link" href="https://nifplay.org/play-science/scientific-disciplines-researching-play/" target="_blank">Play: How It Shapes the Brain</a><br>
<a data-tooltip-position="top" aria-label="https://mitpress.mit.edu/9780262534512/play-matters/" rel="noopener nofollow" class="external-link" href="https://mitpress.mit.edu/9780262534512/play-matters/" target="_blank">Play Matters</a><br>
<a data-tooltip-position="top" aria-label="https://www.sciencedirect.com/science/article/pii/S014976342300355X" rel="noopener nofollow" class="external-link" href="https://www.sciencedirect.com/science/article/pii/S014976342300355X" target="_blank">Play in video games</a>
<br>--<br><br>
<br>Play:

<br>A broad concept encompassing all enjoyable, engaging activities.
<br>Examples: Free-form exploration, role-playing, or sandbox experimentation.


<br>Gameplay:

<br>Play structured by the rules and systems of a game.
<br>Examples: Completing objectives, solving puzzles, or managing resources.


<br>Key Distinction:

<br>Play is the overarching activity, while gameplay is a specific form of play within a designed context.


<br>--<br><br>
<br>Key Design Elements:

<br>Meaningful Choices:

<br>Offer players impactful decisions that shape their experience.
<br>Example: Branching storylines or multiple gameplay approaches.


<br>Balanced Challenges:

<br>Create obstacles that are achievable yet rewarding.
<br>Example: Gradual difficulty curves to maintain player engagement.


<br>Social Connections:

<br>Enable interactions that foster collaboration or competition.
<br>Example: Multiplayer modes or shared goals.




<br>Encouraging Exploration:

<br>Design systems that allow players to experiment freely within rules.


<br><br>--<br><br>
<br>Game Spotlight: The Legend of Zelda: Breath of the Wild (2017)

<br>Meaningful Choices:

<br>Players can tackle challenges in various ways, from combat to stealth.


<br>Balanced Challenges:

<br>Flexible difficulty, allowing players to approach objectives at their own pace.


<br>Encouraged Exploration:

<br>A vast open world filled with secrets, puzzles, and rewards that encourage curiosity.




<br>An In-Depth Look at Conventions, Design, and Play:

<br><br><br>
<br>What are Frameworks?

<br>Conceptual tools that can help guide the game design process.
<br>Help designers organize ideas and evaluate design decisions.


<br>Why Use Frameworks?

<br>Provide clarity and focus during development.
<br>Facilitate collaboration and communication among teams.


<br>There are many different frameworks for all aspects of game design!
<br>--<br><br>
<br>Definition:

<br>A formalized approach to understanding and designing games.
<br>Introduced by Robin Hunicke, Marc LeBlanc, and Robert Zubek.


<br>
<br>--<br>Components: MDA<br>
<br>Mechanics: The rules and systems governing gameplay.

<br>Example: Jump mechanics in platformers.


<br>Dynamics: The emergent behavior arising from player interaction.

<br>Example: Strategic decisions in chess.


<br>Aesthetics: The emotional response evoked in players.

<br>Example: Tension in horror games.


<br>Learn More: MDA Framework
<a data-tooltip-position="top" aria-label="http://www.cs.northwestern.edu/~hunicke/MDA.pdf" rel="noopener nofollow" class="external-link" href="http://www.cs.northwestern.edu/~hunicke/MDA.pdf" target="_blank">Original MDA Paper (PDF)</a>

<br>--<br><br>
<br>Definition:

<br>A player-focused framework emphasizing iterative development.
<br>Introduced to complement MDA and focus on outcomes.


<br>Components:

<br>Design: The intentional creation of mechanics and systems.
<br>Dynamics: The real-time interactions and behaviors of players.
<br>Experience: The intended and emergent outcomes of gameplay.


<br>Learn More
<a data-tooltip-position="top" aria-label="https://www.researchgate.net/publication/315854140_Design_Dynamics_Experience_DDE_An_Advancement_of_the_MDA_Framework_for_Game_Design" rel="noopener nofollow" class="external-link" href="https://www.researchgate.net/publication/315854140_Design_Dynamics_Experience_DDE_An_Advancement_of_the_MDA_Framework_for_Game_Design" target="_blank">DDE Paper</a><br>
<a data-tooltip-position="top" aria-label="https://www.gamedeveloper.com/design/from-mda-to-dde" rel="noopener nofollow" class="external-link" href="https://www.gamedeveloper.com/design/from-mda-to-dde" target="_blank">From MDA to DDE</a><br>
<a data-tooltip-position="top" aria-label="https://maxlearn.com/blogs/dde-framework-for-game-design-in-microlearning/" rel="noopener nofollow" class="external-link" href="https://maxlearn.com/blogs/dde-framework-for-game-design-in-microlearning/" target="_blank">How to Apply DDE</a>
<br>--<br><br>
<br>MDA vs. DDE:

<br>MDA: Focuses on the relationship between mechanics, dynamics, and aesthetics from a system perspective.
<br>DDE: Centers on the player experience and iterative refinement.


<br>Use Cases:

<br>MDA: Best for understanding and planning complex systems.
<br>DDE: Ideal for refining player experiences through testing and iteration.


<br><br><br><br><br><br><br>
<br>
Definition:

<br>The bridge between art and technology in game development.
<br>Combines creative and technical skills to enhance workflows and visual quality.


<br>
Key Roles:

<br>Ensure the seamless integration of assets into game engines.
<br>Solve cross-disciplinary challenges between artists and programmers.



<br>--<br><br>
<br>Attention to Detail
<br>Communication and Collaboration
<br>Strong Art and Technical Knowledge
<br>Technical Proficiency
<br>Creative Problem-Solving
<br>Learn More: Tech Art
<a data-tooltip-position="top" aria-label="https://www.tech-artists.org/t/about-the-professional-category/9845" rel="noopener nofollow" class="external-link" href="https://www.tech-artists.org/t/about-the-professional-category/9845" target="_blank">Tech-Artists Site</a><br>
<a data-tooltip-position="top" aria-label="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" rel="noopener nofollow" class="external-link" href="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" target="_blank">Tech Artists in Games</a><br>
<a data-tooltip-position="top" aria-label="https://www.cgspectrum.com/career-pathways/technical-artist" rel="noopener nofollow" class="external-link" href="https://www.cgspectrum.com/career-pathways/technical-artist" target="_blank">Technical Artist Job</a>
<br>--<br><br>
<br>What is Procedural Thinking?

<br>Using algorithms and rules to automate content creation.


<br>Applications in Game Development:

<br>Terrain and foliage generation.
<br>Character customization systems.


<br>Benefits:

<br>Efficiency: Reduces time spent on repetitive tasks.
<br>Scalability: Enables the creation of vast, dynamic worlds.


<br><br>--<br><br>
<br>What is Modular Thinking?

<br>Designing assets and systems in reusable, interchangeable components.


<br>Applications in Game Development:

<br>Modular level design (e.g., room prefabs in a dungeon).
<br>Swappable character parts or weapons.


<br>Benefits:

<br>Reusability: Saves development time and resources.
<br>Flexibility: Allows easy updates and customization.


<br><br>--<br><br>
<br>How They Work Together:

<br>Procedural techniques generate modular components that can be reused across projects.


<br>Example Workflow:

<br>Procedurally create terrain using rules ‚Üí Populate with modular assets like trees and rocks.


<br>Key Benefits:

<br>Enhances both creativity and efficiency in asset creation.


<br><br><br>
<br>What is a DAG?

<br>A structure where nodes are connected in a one-way direction, forming a tree-like graph with no loops.


<br>Why DAGs?

<br>Support non-linear workflows, enabling iterative and modular development.


<br>Applications in Game Art and Development:

<br>Organizing and optimizing procedural pipelines.
<br>Managing dependencies between assets and systems.
<br>Building, modeling, or texturing assets
<br>Real-time gameplay systems


<br>DAGs
<a rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank">https://en.wikipedia.org/wiki/Directed_acyclic_graph</a><br>
<a rel="noopener nofollow" class="external-link" href="https://www.getdbt.com/blog/guide-to-dags" target="_blank">https://www.getdbt.com/blog/guide-to-dags</a>
<br>--<br><br>
<br>Definition:

<br>Visual scripting and data-driven approaches used to create procedural systems and assets.


<br>How It Works:

<br>Nodes represent specific tasks or operations.
<br>Connections between nodes define the flow of data or operations.


<br>Common Use Cases:

<br>Procedural content generation.
<br>Shader and material creation.
<br>Logic and gameplay systems in visual scripting tools.


<br><a data-href="GMAP395-DAGsNodes.excalidraw" href="gmap-395\introduction\media\gmap395-dagsnodes.excalidraw.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP395-DAGsNodes.excalidraw</a><br>--<br><br>
<br>Houdini:

<br>Procedural modeling, VFX, and simulations using node-based workflows.
<br>Example: Generating terrain or foliage with procedural rules.


<br>Unreal Engine:

<br>Blueprint visual scripting for game logic and interactive systems.
<br>Example: Creating interactive gameplay without traditional coding.


<br>Unity Shader Graph:

<br>Node-based tool for crafting complex shaders visually.
<br>Example: Building a dynamic water shader with transparency and reflections.


<br>--<br>Explore Further: Node-Based Workflows
<a data-tooltip-position="top" aria-label="https://www.sidefx.com/tutorials/intro-to-houdinis-node-based-workflow/" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/tutorials/intro-to-houdinis-node-based-workflow/" target="_blank">Introduction to Node-Based Workflows in Houdini</a><br>
<a data-tooltip-position="top" aria-label="https://www.sidefx.com/docs/houdini/nodes/index.html" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/docs/houdini/nodes/index.html" target="_blank">Houdini's Nodes</a><br>
<a data-tooltip-position="top" aria-label="https://spin.atomicobject.com/blender-node-based-workflows/" rel="noopener nofollow" class="external-link" href="https://spin.atomicobject.com/blender-node-based-workflows/" target="_blank">Blenders Node-Based Workflows</a>

<br>--<br><br>
<br>Modular Logic:

<br>Easily modify individual nodes without disrupting the entire system.


<br>Reusability:

<br>Nodes and node groups can be saved and reused across projects.


<br>Visualization:

<br>Provides a clear visual representation of processes and data flow.


<br>Flexibility:

<br>Supports rapid iteration and experimentation.


<br>--<br><br>
<br>Key Topics Covered:

<br>Game Design:

<br>Foundations, processes, and the importance of play.


<br>Frameworks:

<br>MDA and DDE as tools for understanding player experience.


<br>Technical Art:

<br>Bridging art and technology through procedural and modular workflows.


<br>Node-Based Workflows:

<br>Visual scripting for flexible and scalable game systems.




<br>--<br><br>
<br>Why Iteration Matters:

<br>Continuous Improvement:

<br>Allows for refinement of gameplay and visual quality.


<br>Adaptability:

<br>Respond to player feedback and emerging challenges.


<br>Polished Results:

<br>Iteration ensures systems, mechanics, and art are cohesive and engaging.




<br>Key Takeaway: Iteration isn‚Äôt just a step‚Äîit‚Äôs a philosophy.
<br>--<br><br>
<br>Emerging Technologies:

<br>AI and Machine Learning:

<br>Generative tools for textures, animations, and world-building.


<br>Real-Time Rendering:

<br>Advancements like ray tracing for hyper-realistic visuals.


<br>Procedural Workflows:

<br>Increasing reliance on algorithms to generate complex assets.




<br>The Next Frontier:

<br>Player-Created Content: Empowering users to design within games.
<br>Immersive Systems: Expanding XR (VR/AR/MR) experiences.


<br>Explore More:

<br><a data-tooltip-position="top" aria-label="https://www.gamasutra.com/" rel="noopener nofollow" class="external-link" href="https://www.gamasutra.com/" target="_blank">AI in Game Development</a>
<br><a data-tooltip-position="top" aria-label="https://www.unrealengine.com/" rel="noopener nofollow" class="external-link" href="https://www.unrealengine.com/" target="_blank">Real-Time Rendering Techniques</a>

<br><br><br><br>
<br>What excites (or scares) you most about modern game design and development tools?
<br>How do you think procedural or modular workflows influence the games we play today?
<br>--<br><br><br>
<br>Choose a game you‚Äôve played and enjoyed.
<br>Reflect on:

<br>What elements of the game stand out to you? (e.g., visuals, mechanics, world design)
<br>How do you think these elements were created? Consider tools or workflows like procedural generation, modular design, or shaders.


<br>Light Research:

<br>Look up the game‚Äôs development process or tools used by its studio.
<br>Example tools for research:

<br>The Legend of Zelda: Breath of the Wild (physics puzzles, procedural systems)
<br>No Man‚Äôs Sky (Procedural world-building)
<br>Celeste (Iteration for accessibility and challenge balance)




<br>--<br><br>
<br>Share your observations with a partner or small group.
<br>Discuss:

<br>Similarities and differences in the chosen games.
<br>How procedural or modular workflows might have influenced the design choices.
<br>Ideas for how you might apply these concepts in your own projects.


<br>--<br><br>
<br>Volunteers and/or groups present highlights of their discussions:

<br>A game they analyzed and how procedural/modular workflows contributed to its design.
<br>An insight or idea they found particularly interesting.


<br><br><br>Reflection Questions
How does understanding the development process help you approach game design or technical art critically?<br>
What trends or common tools did you notice across different games?<br>
How might these approaches inspire your work as a game designer or artist?
]]></description><link>gmap-395\introduction\gmap-395-wk-1-slides.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - WK 1 - Slides.md</guid><pubDate>Tue, 24 Jun 2025 20:47:59 GMT</pubDate><enclosure url="gmap-395\introduction\media\design-everyday-things.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\introduction\media\design-everyday-things.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 1 - Video Lecture]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_AsN9Rcq9MtNowLIQ?e=V4Sh1W" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_AsN9Rcq9MtNowLIQ?e=V4Sh1W" target="_blank">Video link if above does not play in browser</a>]]></description><link>gmap-395\introduction\gmap-395-wk-1-video-lecture.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - WK 1 - Video Lecture.md</guid><pubDate>Wed, 08 Jan 2025 23:44:40 GMT</pubDate></item><item><title><![CDATA[Media]]></title><description><![CDATA[ 
 ]]></description><link>gmap-395\module-1\media\media.html</link><guid isPermaLink="false">GMAP 395/Module 1/Media/Media.md</guid><pubDate>Mon, 20 Jan 2025 19:16:35 GMT</pubDate></item><item><title><![CDATA[media]]></title><description><![CDATA[ 
 ]]></description><link>gmap-395\module-2\media\media.html</link><guid isPermaLink="false">GMAP 395/Module 2/media/media.md</guid><pubDate>Mon, 27 Jan 2025 14:35:58 GMT</pubDate></item><item><title><![CDATA[Assignment 2: Dynamic Shaders and Materials]]></title><description><![CDATA[ 
 <br><br><br>Assignment Overview  
In this assignment, students will:

<br>Develop custom shaders and materials for the procedural game asset created in Assignment 1.
<br>Use Unity's Shader Graph or a similar node-based tool to create dynamic, real-time effects (must be displayed in Unity).
<br>Ensure shaders and materials enhance the asset‚Äôs presentation, aligning with the class theme: Something from the Void.
<br>Present the final shaders in a Unity scene and document the process in a README file.

<br><br><br>Assignment Breakdown

<br>Part 1: Shader Creation<br>
Design and implement dynamic shaders to achieve real-time visual effects for your asset.
<br>Part 2: Interactive Material Application<br>
Use the shaders and materials from Part 1, to create a real-time feedback based on a game event.

<br><br><br><br>Shader Inspiration from the Void  
Explore the theme by crafting shaders and materials that evoke mystery, emptiness, or cosmic energy. Examples include:

<br>A swirling galaxy effect on a portal or artifact.
<br>A glowing material with pulsating patterns and emissive highlights.
<br>Transparency effects to mimic glass-like or ethereal surfaces.

<br><br><br>Key Steps for Part 1

<br>Use Unity Shader Graph or a compatible node-based shader tool.
<br>Develop shaders that include at least two of the following techniques:

<br>Transparency or Opacity Masks: Create layered effects or partial visibility.
<br>Emissive Effects: Add glowing patterns or highlights.
<br>Procedural Textures: Use noise or gradients for dynamic surface details.
<br>Animation: Introduce movement, such as shifting patterns or pulsating effects.


<br>Apply the shaders to your procedural asset from Assignment 1.
<br>Test the shaders in Unity to ensure real-time performance.

<br><br>Key Steps for Part 2

<br>Use exposed shader parameters and C# in Unity to created real-time feedback.
<br>Further develop your shaders and materials for:

<br>Game-based Interaction: React to lighting, proximity, or player actions.


<br>Adjust material properties for optimal presentation:

<br>Set parameters for color, intensity, transparency, and more.


<br>Design the Unity scene to showcase the material effects:

<br>Add secondary lights, adjust post-processing (bloom), and environmental elements for context.



<br>Shader Design Tips

<br>Use color theory and emissive settings to emphasize the void theme.
<br>Combine procedural noise and gradient ramps to create abstract patterns.
<br>Test your shaders with different lighting conditions to ensure versatility.

<br><br><br>What to Submit

<br>README File:

<br>A Markdown, TXT, or PDF file that explains your work:

<br>Shader design techniques and inspirations.
<br>Material setup and Unity scene configuration.
<br>Challenges encountered and solutions implemented.




<br>Recorded Video (5‚Äì10 Minutes):

<br>A Screen Recorded video walkthrough showcasing:

<br>Record the Unity Scene and any other relevant DDC application used
<br>Shader effects and how they align with the theme.
<br>Material application in Unity and real-time demonstration of effects.
<br>Integration of lights and post-processing(optional) to complement the shaders.





<br>Screenrecording
Download OBS Studio or some other comparable software, record your screen and talk me through your design process and other requirements specified in the document.
<br>README Example Format
# Assignment 2: Dynamic Shaders and Materials

## Shader Design
- Tool Used: Unity Shader Graph  
- Techniques: Animated emissive glow, noise-based texture movement.  
- Theme Connection: Represents cosmic energy and the void‚Äôs ethereal nature.

## Unity Material Setup
- Material Design: Applied to a swirling portal with emissive highlights and transparency.  
- Lighting Design: Purple spotlights to enhance the glowing edges.

## Challenges
- Issue: Achieving smooth animation at runtime.  
- Solution: Adjusted shader parameters and optimized node setups.  

<br><br><br>By completing this assignment, you will:

<br>Gain hands-on experience in shader and material development using node-based tools.
<br>Enhance your procedural asset with dynamic, real-time effects.
<br>Understand the technical workflow for applying shaders in Unity.
<br>Align technical art skills with creative storytelling and thematic presentation.

<br><br>Submission Guidelines

<br>Submission Format: ZIP file uploaded to Drexel Learn.
<br>File Naming: abc123_Lastname_Firstname_A2.zip.
<br>Late submissions will incur a 10% penalty per day.

<br><br>]]></description><link>gmap-395\module-2\gmap-395-asn-2-brief.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - ASN 2 - Brief.md</guid><pubDate>Tue, 28 Jan 2025 20:44:35 GMT</pubDate></item><item><title><![CDATA[Module 2 - Shaders and Material Development]]></title><description><![CDATA[ 
 <br><br><br>This module deals with shader creation and material development, essential skills for adding dynamic visual behavior to assets. Students will explore both code-based and node-based shader workflows, focusing on enhancing procedural assets for real-time interactivity.<br><br><a data-href="GMAP 395 - WK 4 - Slides + Video" href="gmap-395\module-2\gmap-395-wk-4-slides-+-video.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 4 - Slides + Video</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395/Module 2/GMAP 395 - WK 4 - Tutorial" data-href="GMAP 395/Module 2/GMAP 395 - WK 4 - Tutorial" href="gmap-395\module-2\gmap-395-wk-4-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 4 - Tutorial</a><br>
<a data-href="GMAP 395 - WK 4 - In-Class Lab" href="gmap-395\module-2\gmap-395-wk-4-in-class-lab.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 4 - In-Class Lab</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - WK 5 - Slides + Video" data-href="GMAP 395 - WK 5 - Slides + Video" href="gmap-395\module-2\gmap-395-wk-5-slides-+-video.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 5 - Slides + Video</a><br>
<a data-href="GMAP 395 - WK 5 - Tutorial" href="gmap-395\module-2\gmap-395-wk-5-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 5 - Tutorial</a><br>
<a data-href="GMAP 395 - ASN 2 - Brief" href="gmap-395\module-2\gmap-395-asn-2-brief.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - ASN 2 - Brief</a><br><br><br>
<br>Introduction to Unity Shader Graph and custom shader creation.
<br>Exploring material properties and real-time interactions.
<br>Applying shaders to procedural assets developed in Module 1.
<br><br><br>By the end of this module, you will:<br>
<br>Gain foundational knowledge of shader and material workflows.
<br>Create custom shaders using Unity Shader Graph and scripting.
<br>Enhance procedural assets with dynamic visual behaviors.
<br>Understand the integration of shaders into real-time systems.
<br><br><br>
<br>Ensure Unity (2022.3 or higher) is installed and updated.
<br>Confirm your computer meets the recommended specifications for shader development.
<br>Helpful Resources

<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Manual/shader-graph.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Manual/shader-graph.html" target="_blank">Unity Shader Graph Documentation</a>
<br><a data-tooltip-position="top" aria-label="https://www.kodeco.com/5671826-introduction-to-shaders-in-unity" rel="noopener nofollow" class="external-link" href="https://www.kodeco.com/5671826-introduction-to-shaders-in-unity" target="_blank">Introduction to Shaders in Unity</a>

<br>If you are new to Shader Graph

<br><br><br><br><br>
<br>Unity 2022.3 SRP with Shader Graph: Included with Unity Editor.
<br>An IDE (w/ optional HLSL support): Examples include Visual Studio or Visual Studio Code.
<br><br><br><br>
<br>Objective: Develop shaders to enhance the visual behavior of assets created in Assignment 1.
<br>Key Deliverables:

<br>A shader with dynamic effects (e.g., glow, transparency).
<br>A material applied to a procedural asset demonstrating interactivity.


<br>Due Date: Week 5
<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.shadergraph@16.0/manual/Node-Library.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.shadergraph@16.0/manual/Node-Library.html" target="_blank">Shader Graph Node Library</a>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/mission/creative-core-shaders-and-materials?pathwayId=61a65568edbc2a00206076dd" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/mission/creative-core-shaders-and-materials?pathwayId=61a65568edbc2a00206076dd" target="_blank">Unity Learn - Shaders and Materials</a>
<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/2022.3/Documentation/Manual/class-GraphicsSettings.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-GraphicsSettings.html" target="_blank">Unity Graphics Settings Overview</a>
<br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\module-2\gmap-395-module-2.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - Module 2.md</guid><pubDate>Sun, 02 Feb 2025 20:30:40 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 4 - In-Class Lab]]></title><description><![CDATA[ 
 <br><br>Gain hands-on experience creating and modifying basic shaders using Unity's Shader Graph. <br><br>
<br>Unity 2022.3
<br>Basic understanding of Unity interface
<br>Universal Render Pipeline (URP) set up in your project
<br><br><br><br>
<br>In Unity, right-click in the Project window
<br>Select Create &gt; Shader &gt; Universal Render Pipeline &gt; Unlit Shader Graph
<br>Name it "MyFirstShaderGraph"
<br>Double-click to open it in the Shader Graph window
<br><br>
<br>In the Shader Graph window, locate the Blackboard (usually on the left side)
<br>In the Blackboard:

<br>Click the + button
<br>Choose Color from the dropdown
<br>Name it _Color (or any appropriate name)
<br>Set a default color if desired (found in the Graph Inspector &gt; Node Settings)


<br>In the graph area:

<br>Click and drag the _Color property from the Blackboard directly into the graph area


<br>Connect the Color property node's output to the Base Color input of the "Fragment" node
<br>Click "Save Asset" to save your shader graph
<br><br>
<br>In Unity, create a new 3D object (e.g., Sphere) in your scene
<br>Create a new material:

<br>Right-click in the Project window &gt; Create &gt; Material
<br>Name it appropriately


<br>In the new material's Inspector:

<br>Set the Shader to your "Shader Graph/MyFirstShaderGraph"
<br>Adjust the Color property to see changes on your 3D object


<br><br><br><br>
<br>
In the Blackboard, add the following properties:

<br>Texture2D named _MainTex
<br>Vector2 named _Tiling (set default to 1,1)
<br>Vector2 named _Offset (set default to 0,0)


<br>
In your Shader Graph, add the following nodes:

<br>Drag the _MainTex, _Tiling, and _Offset properties from the Blackboard into the graph
<br>Add a Tiling And Offsetnode
<br>Add a Sample Texture 2D node


<br>Hotkey
SPACEBAR is the hotkey shortcut to open the create node dialogue box.
<br>
<br>Connect the nodes:

<br>Connect the _Tiling and _Offset outputs to the respective inputs of the Tiling And Offset node
<br>Connect the UV output of Tiling And Offset to the UV input of Sample Texture 2D
<br>Connect the _MainTex property to the Texture input of Sample Texture 2D


<br><br>
<br>
Add a Multiply node

<br>
Connect:

<br>The RGBA output of Sample Texture 2D to one input of Multiply
<br>The _Color property to the other input of Multiply
<br>The output of Multiply to the Base Color of the Fragment node


<br>
Save the Shader Graph

<br><br>
<br>Select your 3D object in the scene
<br>In the Inspector, you should now see slots for Texture, Tiling, and Offset
<br>Assign a texture to the Texture slot
<br>Adjust Tiling and Offset values to see how they affect the texture
<br><br><br><br>
<br>
In the Blackboard, add these Float properties:

<br>_WaveAmount (default 1)
<br>_WaveSpeed (default 1)
<br>_WaveFrequency (default 1)


<br>
In your Shader Graph, add these nodes:

<br>Drag the new Float properties from the Blackboard into the graph
<br>Add Time node
<br>Add Position node (set to World)
<br>Add Sine node
<br>Add several Multiply (3) nodes
<br>Add Add node
<br>Add Split node


<br>
Connect the nodes to create the wave effect:

<br>Connect the output of the World Position node to the input of the Split node
<br>Connect the R output of the Split node (which represents the X component) to one input of a Multiply node
<br>Connect the _WaveFrequency to the other input of this Multiply node
<br>Multiply _WaveSpeed by Time
<br>Add the results of the above two operations using an Add node
<br>Feed the output of the Add node into the Sine node
<br>Multiply the Sine output by _WaveAmount


<br>
Add a Combine node:

<br>Connect the R (X) and B (Z) from the Split node to the corresponding inputs on the Combine
<br>For the G(Y) input of the Combine node, add the wave calculation to the G(Y) output of the Split node and connect it.


<br>
Connect the Combine node's output (RGBA or RGB) to the Position input of the Vertex node

<br><br>
<br>Save the Shader Graph
<br>Select your 3D object in the scene
<br>In the Inspector, you should now see Wave Amount, Wave Speed, and Wave Frequency properties
<br>Adjust these values to see how they affect the object's shape
<br><br><br><br>Modify your shader to blend between two colors based on a custom parameter.<br><br>
<br>In the Blackboard, add:

<br>Another Color property named _Color2
<br>A Float property named _BlendFactor (set range 0 to 1)


<br>Modes in Graph Inspector
You can change the Mode of a property in the Graph Inspector to something like Slider
<br>
<br>
In the graph area:

<br>Drag the new properties from the Blackboard
<br>Add a Lerp node


<br>
Connect the nodes:

<br>Connect _Color and _Color2 to the A and B inputs of the Lerp node respectively
<br>Connect _BlendFactor to the T input of the Lerp node


<br>
Use the output of the Lerp node in your final color calculation (e.g., multiply it with your texture sample)

<br>
Save the Shader Graph and adjust the Blend Factor in your material's Inspector to blend between the two colors.

<br><br>
<br>Try blending based on vertex position instead of a custom parameter
<br>Implement a smooth transition that cycles between the colors over time (Time or Sine)
<br>Add a third color and blend between all three
<br>Check
Remember to save your Shader Graph after each major change, and don't hesitate to experiment with different connections and values!
]]></description><link>gmap-395\module-2\gmap-395-wk-4-in-class-lab.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 4 - In-Class Lab.md</guid><pubDate>Mon, 27 Jan 2025 21:55:53 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 4 - Slides + Video]]></title><description><![CDATA[ 
 <br><br><br><br>Week 4 Video Lecture

<a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_F3vSAiT9rcAKv5Jw?e=HRmiMT" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_F3vSAiT9rcAKv5Jw?e=HRmiMT" target="_blank">gmap395_wk4.mp4</a>
<br><br><br>
<br>Definition: Shaders are small programs that run on the GPU, defining the visual appearance of objects in a scene.
<br>Purpose: Control how materials interact with light to achieve desired visual effects.
<br>Core Shader Types:

<br>Vertex Shaders: Modify geometry at the vertex level.
<br>Fragment Shaders (Pixel Shaders): Control pixel-level color and lighting.


<br><br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=ax1JLQABmOw" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=ax1JLQABmOw" target="_blank">What are shaders? - GDQuest</a><br><br><br>
<br>Customization: Allows unique material creation.
<br>Optimization: Efficient use of GPU resources for real-time rendering.
<br>Dynamic Effects: Enables interactive and changing visuals.
<br>Examples:

<br>"Stylized" water effects (Breath of the Wild).
<br>Holograms (Halo).
<br>Cel-shading (Borderlands).


<br><br><br>
<br>Bridging Art and Code:

<br>Shaders enable technical artists to bridge visual design and programming.


<br>Dynamic Visuals:

<br>Create interactive and adaptive visuals for game systems.


<br>Procedural Systems:

<br>Shaders are often used in procedural workflows for generating textures, patterns, and effects.


<br><br><br>
<br>Procedural Textures:

<br>Use math and logic to generate seamless textures.


<br>Modular Workflows:

<br>Reusable shader modules can streamline development.


<br>Examples:

<br>Procedural weathering effects.
<br>Adjustable material templates for diverse assets.


<br><br><br>
<br>Define Properties: Expose parameters like color or texture to customize materials.
<br>Create SubShaders: Specify rendering techniques for different hardware or conditions.
<br>Write Passes: Describe rendering steps (e.g., vertex and fragment programs).
<br><br><br>Shader "Custom/ExampleShader"
{
    Properties
    {
        _Color ("Main Color", Color) = (1,1,1,1)
    }
    SubShader
    {
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // Declare the _Color property as a uniform
            fixed4 _Color;
            struct appdata
            {
                float4 vertex : POSITION; // Vertex position
            };
            struct v2f
            {
                float4 pos : SV_POSITION; // Transformed position
            };
            v2f vert (appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                return o;
            }
            // Use _Color in the fragment shader
            fixed4 frag (v2f i) : SV_Target
            {
                return _Color; // Output the color
            }
            ENDCG
        }
    }
}

<br><br><br>
<br>Shader Properties:

<br>_Color: Exposed parameter for material customization.


<br>SubShader:

<br>Contains rendering passes for different GPU capabilities.


<br>Vertex Function:

<br>Processes vertex data (positions, normals, UVs).


<br>Fragment Function:

<br>Determines final pixel color using inputs from the vertex shader.


<br><br><br>
<br>Uniform Variables:

<br>Definition: Global variables that are constant during the rendering of a single draw call. These are set by the CPU and shared across all invocations of a shader program.
<br>Examples:

<br>Time values for animations.




<br>Attributes:

<br>Definition: Input data that is unique for each vertex and provided by the vertex buffer. Attributes are available only in the vertex shader.
<br>Examples:

<br>Texture coordinates (TEXCOORD).




<br>Varyings:

<br>Definition: Variables used to pass interpolated data from the vertex shader to the fragment shader.
<br>Examples:

<br>Lighting data like vertex colors or normals.




<br><a data-tooltip-position="top" aria-label="https://thebookofshaders.com/" rel="noopener nofollow" class="external-link" href="https://thebookofshaders.com/" target="_blank">The Book of Shaders</a><br><br><br>
<br>Inputs:

<br>Vertex Data: Positions, normals, UVs.
<br>Textures: Color or detail maps.
<br>Uniforms: Constants like time or transformations.


<br>Outputs:

<br>Final pixel colors rendered to the screen.


<br><br><br><br>
<br>Vertices: Define points in 3D space.
<br>Edges: Connect vertices to outline shapes.
<br>Faces: Form surfaces using connected edges.
<br>UVs: Map 2D textures to 3D surfaces.
<br>Normals: Vectors perpendicular to faces for lighting calculations.
<br><br>
<br>Vertex Data: Input for vertex shaders to transform 3D geometry.
<br>Normals: Used in lighting equations for shading effects.
<br>UV Mapping: Guides texture placement via fragment shaders.
<br>Shader Outputs: Define the final appearance of geometry on-screen.
<br><br><br><br><br>
<br>Small programs executed on the GPU.
<br>Control how light interacts with geometry.
<br>Types: Vertex, Fragment, Compute.
<br><br>
<br>Definition: A wrapper for shaders, combining textures and parameters.
<br>Role: Define the look of objects by associating shaders with visual properties.
<br>Example: A reflective material uses a custom shader for specular highlights.
<br><br>
<br>Definition: 2D images mapped to 3D geometry.
<br>Purpose: Add details like color, patterns, or surface irregularities.
<br>Common Types: Diffuse, Normal, Specular, Emissive.
<br><br><br><br><br>
<br>Physically Based Rendering (PBR): A method to simulate realistic lighting and material behavior.
<br>Key Concepts: Energy conservation, physically accurate shading.
<br>Benefits: Consistent results across lighting environments.
<br><br>
<br>Base Color: Defines the albedo (color) of the surface.
<br>Metallic: Specifies if the material is metal (affects reflection).
<br>Roughness/Smoothness: Controls surface reflectivity.
<br>Normal Map: Adds surface details without extra geometry.
<br>Ambient Occlusion (AO): Simulates soft shadows in crevices.
<br><a data-tooltip-position="top" aria-label="https://www.materialmaker.org/" rel="noopener nofollow" class="external-link" href="https://www.materialmaker.org/" target="_blank">Material Maker</a>
Material Maker is a procedural materials authoring tool based on the Godot Engine.
<br><br><br>
<br>Vector Operations:

<br>Dot Product: Lighting calculations.
<br>Cross Product: Surface normals.


<br>Matrix Transformations:

<br>Object to world space conversions.


<br>Color Operations:

<br>RGB blending and transitions.


<br>Noise Functions:

<br>Create procedural patterns for effects.


<br><br><br>
<br>Minimize Complexity:

<br>Use simple math operations where possible.


<br>Reuse Variables:

<br>Avoid redundant calculations.


<br>LOD Techniques:

<br>Reduce detail for distant objects.


<br><br><br>
<br>Dissolve Effects:

<br>Use noise textures to create fading effects.


<br>Holographic Shaders:

<br>Add transparency and scrolling UV animations.


<br>Water Shaders:

<br>Simulate refraction and wave movement.


<br><a data-tooltip-position="top" aria-label="https://realtimevfx.com/" rel="noopener nofollow" class="external-link" href="https://realtimevfx.com/" target="_blank">Real-Time VFX Website</a><br><br><br>
<br>What Is Shader Graph?

<br>A node-based interface for creating shaders visually.


<br>Benefits:

<br>No coding required.
<br>Rapid iteration and prototyping.


<br>Components:

<br>Blackboard, Nodes, Master Stack, Preview, etc.


<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.shadergraph@14.0/manual/Getting-Started.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.shadergraph@14.0/manual/Getting-Started.html" target="_blank">Shader Graph Docs</a>
<br>
![[blackboard_shadergraph_path.png]]
![[GraphSettings_Menu.png]]
![[MasterStack_Populated.png|320]]
<br><br><br><br>
<br>Write a basic color shader.
<br>Add texture support.
<br>Implement vertex manipulation for dynamic effects.
<br><br><br><br><br><a data-tooltip-position="top" aria-label="https://jettelly.com/store/the-unity-shaders-bible" rel="noopener nofollow" class="external-link" href="https://jettelly.com/store/the-unity-shaders-bible" target="_blank">The Unity Shader Bible</a><br><br><a data-tooltip-position="top" aria-label="https://www.shadertoy.com/" rel="noopener nofollow" class="external-link" href="https://www.shadertoy.com/" target="_blank">Shadertoy</a><br><br><br><br>
<br>How do shaders enhance visual storytelling?
<br>What challenges might arise in shader development?
<br>Where could you apply shaders in your current projects?
<br><br><br>
<br>Shaders are a powerful tool for creating immersive, visually striking experiences.
<br>Mastering shaders bridges a gap between art and technology in game development and beyond.
<br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-2\gmap-395-wk-4-slides-+-video.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 4 - Slides + Video.md</guid><pubDate>Mon, 03 Feb 2025 16:29:14 GMT</pubDate></item><item><title><![CDATA[Creating an Eldritch Portal Shader]]></title><description><![CDATA[ 
 <br><br><br>Create a swirling circular portal shader using Unity‚Äôs Shader Graph, complete with dynamic transparency and procedural motion effects.<br><img alt="portalShaderGrab.png" src="gmap-395\module-2\media\portalshadergrab.png" style="width: 640px; max-width: 100%;"><br><br><br>
[gmap395_tut3.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_F1UOYs8x0W2JbJRQ?e=JOQ7gp)<br><br><br>
<br>Unity 2022.3 with URP installed.
<br>Basic understanding of Shader Graph.
<br>Completion of previous shader lab (recommended).
<br><br><br><br>
<br>In Unity, navigate to the Project tab.
<br>Right-click and select Create &gt; Shader Graph &gt; URP/Lit Shader Graph.
<br>Name it "EldritchPortalShader".
<br>Important Graph Inspector Settings
Surface Type : Transparent<br>
Blending Mode: Multiply or Alpha<br>
Render Face: Both<br>
Alpha Clipping: ‚úÖ
<br>Swirl Pattern Texture

<br>Use a PNG with an alpha channel
<br>Find something with a lot of "texture" or noise<br>
What I used: <a data-tooltip-position="top" aria-label="https://1drv.ms/i/s!AqQzGx8l4o2wk_F0d_KPRwOyyq1jzg?e=mqpCpS" rel="noopener nofollow" class="external-link" href="https://1drv.ms/i/s!AqQzGx8l4o2wk_F0d_KPRwOyyq1jzg?e=mqpCpS" target="_blank">liquid_swirl_alpha.png</a>

<br><br>
<br>Open the Shader Graph and access the Blackboard.
<br>Add the following properties:

<br>Color: EdgeColor (default: Purple)
<br>Float: EdgeWidth (default: 0.5, range: 0 to 1)
<br>Texture2D: SwirlPattern (default: Procedural noise texture)
<br>Float: SwirlSpeed (default: 1)
<br>Float: Power (default: 2, range: 0.1 to 10)
<br>Vector2: CenterPosition (default: 0,0)


<br><br><br><br>
<br>Time-Based Swirl Rotation:

<br>Add a Time node and connect it to the A input of a Multiply node.
<br>Link SwirlSpeed to the B input of the Multiply node.

<br>the swirl speed can be set to a Slider (Mode) in the Graph Inspector (Node Settings)
<br>Set the desired Min and Max; e.g. 0.1 - 1.


<br>Connect the output to the Rotation input of a Rotate node.


<br>Swirl UV Transformation:

<br>Pass the output of the Rotate node to the UV input of a Tiling and Offset node.
<br>Connect the output of Tiling and Offset to  to the UV input of a Polar Coordinates node.
<br>Use CenterPosition as the Center input of the Polar Coordinates.
<br>In Polar Coordinates Radial Scale should be ~1.25 and Length Scale ~1


<br>Texture Sampling:

<br>Add a Sample Texture 2D node.
<br>Connect SwirlPattern to the Texture input and the output of Polar Coordinates to the UV input.

<br>An important note for the next section, change the Mip Sampling Mode of the Sample Texture 2D node to Gradient in the Graph Inspector (Node Settings)


<br>Use a DDX node, a DDY node, and the SamplerState to refine UV sampling.

<br>Drop down a UV node and connect it to both DDX and DDY
<br>Connect DDX to the DDX input of the Sample Texture 2D
<br>Connect DDY to the DDY input of the Sample Texture 2D


<br>Drop down a Sampler State node: set its Filter to Linear and its Warp to Mirror

<br>Connect this node to the Sampler input of Sample Texture 2D




<br>Swirl Blend:

<br>Add a Blend node.
<br>Connect the output of the Sample Texture 2D node to the Base input.
<br>Connect EdgeColor to the Blend input.

<br>The Mode should be set to Multiply (but feel free to experiment with looks)




<br><br><br>
<br>Noise Generation:

<br>Add a Time node and connect it to a Multiply node for animation.

<br>Multiply by ~.25


<br>Pass the output to the Offset a Tiling and Offset node.


<br>Noise Texture Sampling:

<br>Add a Voronoi noise node and use the output of Time as its Angle Offset.

<br>Experiment with Cell Density, but a good value is ~3.


<br>Add a Gradient Noise node, connecting the output of Tiling and Offset to its UV input.

<br>The Scale of the gradient node should be ~5.75.




<br>Noise Blending:

<br>Use a Blend node to combine the outputs of Voronoi and Gradient Noise.

<br>I think the Mode Negation works well here; but again, experiment with it.




<br><br><br>
<br>Radial Transparency:

<br>Add a Polar Coordinates node.

<br>Set the Length Scale to ~2.45


<br>Connect EdgeWidth as the Radial Scale input.


<br>Gradient Sampling:

<br>Pass the output of Polar Coordinates to the Time input of a Sample Gradient node.
<br>Set the Gradient so it goes from Black &gt;&gt; White with more black showing, about halfway point.


<br><br><br>
<br>Base Swirl and Noise Combination:

<br>Add a Multiply node.
<br>Connect the output of the Blend node from the Basic Swirl Nodes section to A.
<br>Connect the output of the Blend node from the Additional Noise section to B.


<br>Power Adjustment:

<br>Add a Power node and connect Power to its second input.
<br>Pass the output of the Multiply node to the A input of Power.


<br>Blend Blending:

<br>Add a Blend(1) node to combine the outputs of the Power (into Blend input) node and the Sample Gradient node (into Base input) from the  Radial Alpha section.

<br>Set the Opacity to ~1


<br>Now Copy and Paste this Blend(2) node (you should now have 2)

<br>Set this ones Opacity to ~0.5




<br>Final Blend

<br>Drop down a new Blend(Final) node.
<br>Connect Blend(1) to Base
<br>Connect Blend(2) to Base
<br>Set the Opacity to ~0.5


<br>Fragment Shader Stack:

<br>Connect the final blend output to the main Fragment Shader output:

<br>Base Color
<br>Emission
<br>Alpha
<br>Alpha Clip Threshold




<br><br><br><br>
<br>Create or import a circular plane in Unity (or use a cylinder primitive).
<br>Create a material from the Shader Graph (right-click &gt; create &gt; material)
<br>Assign the material using the Eldritch Portal Shader to this mesh.
<br><br>
<br>Adjust the properties (EdgeWidt, SwirlSpeed, CenterPosition, etc.) to fine-tune the effect.
<br>Experiment with different textures for SwirlPattern and different types of noise to create unique styles.
<br><br>
<br>Color Shifting: Use a Sample Gradient node linked to Time(Sine) for dynamic color transitions and pulsating effect.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-2\gmap-395-wk-4-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 4 - Tutorial.md</guid><pubDate>Mon, 03 Feb 2025 16:29:40 GMT</pubDate><enclosure url="gmap-395\module-2\media\portalshadergrab.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-2\media\portalshadergrab.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 5 - Slides + Video]]></title><description><![CDATA[ 
 <br><br><br><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_IPty_ck4XywUX00A?e=r8xsqz" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_IPty_ck4XywUX00A?e=r8xsqz" target="_blank">gmap395_wk5.mp4</a><br><br><br><br>
<br>Shader Structure

<br>Properties, Subshaders, Passes
<br>Vertex Shaders 
<br>Fragment Shaders


<br><br><br>
<br>Visual Shader Creation Tool in Unity
<br>Node-Based Interface

<br>No need for manual HLSL coding
<br>Drag-and-drop workflow


<br>Requires Scriptable Render Pipeline (SRP)

<br>URP (Universal Render Pipeline) is recommended for this course


<br><br><br>
<br>Blackboard: Define and expose parameters
<br>Graph Inspector: Contextual information about nodes
<br>Main Stack: Handles Vertex and Fragment logic
<br>Main Preview: Real-time shader preview (can be unreliable)
<br>Toolbar: Save, compile, and debug shaders
<br><br><br>
<br>Base Color Texturing

<br>Sample a Texture2D and apply UV coordinates


<br>Using Lerp for Blending

<br>Combine two textures using a Mask Texture


<br>Adding Detail Textures

<br>Multiply noise maps for realistic effects


<br><br><br><br>
<br>Normal Maps Enhance Perceived Depth

<br>Adds lighting-based details without extra geometry


<br>Implementation:

<br>Use a Sample Texture 2D Node
<br>Convert RGB values to Normal Data
<br>Blend Normal Maps for extra detail


<br><a data-tooltip-position="top" aria-label="https://www.artstation.com/blogs/typhen/GMyG/this-is-normal-1-what-normal-maps-are-and-how-they-work" rel="noopener nofollow" class="external-link" href="https://www.artstation.com/blogs/typhen/GMyG/this-is-normal-1-what-normal-maps-are-and-how-they-work" target="_blank">This is Normal - ArtStation</a><br>
<a data-tooltip-position="top" aria-label="https://www.adobe.com/products/substance3d/discover/normal-mapping.html" rel="noopener nofollow" class="external-link" href="https://www.adobe.com/products/substance3d/discover/normal-mapping.html" target="_blank">What is Normal Mapping? - Adobe</a><br><br><br>
<br>Color Adjustments

<br>Adjust color values dynamically


<br>UV Manipulation

<br>Tiling, Offset, and Rotation


<br>Vertex Displacement

<br>Animate geometry movement


<br>Time-Based Animations

<br>Scroll textures, pulse effects


<br><br><br><br><br>
<br>Use the Position Node
<br>Apply Sine Waves for Oscillating Movement
<br>Combine Noise for Organic Deformations
<br>Practical Use: Water ripples, grass swaying, liquid surfaces
<br><br><br><br>
<br>Types of Noise

<br>Perlin Noise: Soft organic patterns
<br>Voronoi Noise: Cellular structure
<br>Gradient Noise: Blending &amp; soft transitions
<br>Many more...


<br>Blending Techniques

<br>Combine noise with Lerp &amp; Multiply Nodes
<br>Adjust intensity via Remap Node


<br><br><br><br>
<br>Lighting Models

<br>PBR-based or Custom Light Calculations


<br>Creating Custom Rim Lighting

<br>Multiply View Direction and Normal
<br>Apply an Fresnel Node for edge glow


<br><br><br><br><br>
<br>Handles transformations of vertex positions and attributes.
<br>Adjusts geometry before rasterization.
<br>Key Operations:

<br>Model-View-Projection transformations.
<br>Vertex displacement (e.g., vertex animation for waves or procedural terrain).


<br><br>
<br>Groups vertices into triangles or other primitives.
<br>Prepares geometry for rasterization.
<br>Affects edge visibility and culling.
<br><br><br><br>
<br>Converts primitives (triangles) into pixel fragments.
<br>Determines which pixels will be rendered on the screen.
<br><br>
<br>Calculates the final color of each pixel.
<br>Executes texture mapping, lighting calculations, and shading effects.
<br><br>
<br>Combines rendered pixels into a final image.
<br>Handles blending, depth testing, and post-processing effects.
<br><a rel="noopener nofollow" class="external-link" href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview" target="_blank">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a><br><br><img alt="renderPipeline.jpg" src="gmap-395\module-2\media\renderpipeline.jpg" style="width: 640px; max-width: 100%;"><br><br><br><br><br>
<br>VFX Meshes

<br>Assign shaders to particle systems


<br>Custom VFX Shaders

<br>Modify shaders dynamically in real-time


<br>Particle Systems

<br>Practical Use: Fire, smoke, dissolving effects


<br><br><br>
<br>Manipulating Shader Properties via C#

<br>Expose shader parameters in Shader Graph (e.g., _Color, _Emission, _DistortionAmount)
<br>Use C# scripts to modify material properties dynamically


<br>Responding to Game Events

<br>Change material colors when taking damage
<br>Adjust transparency when cloaking
<br>Animate distortion or displacement over time


<br>Example: Modifying Shader Properties in C#
using UnityEngine;

public class MaterialController : MonoBehaviour
{
    public Material dynamicMaterial;
    public float pulseSpeed = 2f;

    void Update()
    {
        // Animate Emission Intensity Over Time
        float emission = Mathf.PingPong(Time.time * pulseSpeed, 1f);
        dynamicMaterial.SetFloat("_EmissionIntensity", emission);
    }

    public void SetDamageEffect()
    {
        // Flash red when hit
        dynamicMaterial.SetColor("_BaseColor", Color.red);
    }
}


<br>Real-World Uses

<br>Player Interaction: Change material properties based on proximity
<br>UI Feedback: Highlight objects when hovered over
<br>Environmental Effects: Shift colors based on time of day or weather conditions


<br><br><br>
<br>What is Tweening?

<br>Smooth interpolation of values over time


<br>Linking Animations to Shader Properties

<br>Change Emission Intensity, Transparency, Displacement


<br>Tweening Libraries in Unity

<br>DOTween, LeanTween


<br>Example: Glow pulse shader using a tweened float variable
<br>using DG.Tweening;
Material mat;
void Start() {
    mat = GetComponent&lt;Renderer&gt;().material;
    mat.DOColor(Color.blue, "_EmissionColor", 2f).SetLoops(-1, LoopType.Yoyo);
}
<br><br><br>
<br>Cel Shading in Borderlands

<br>Uses custom ramp shading
<br>Simplified shadows for comic book style


<br>Hologram Effects in Halo

<br>Vertex displacement for distortion
<br>Transparency with additive blending


<br>Water Simulation in Sea of Thieves

<br>Vertex waves via sine displacement
<br>Reflection and refraction shaders


<br><br><br>
<br>Procedural Modeling generates game assets dynamically‚ÄîShaders can complement this by adding:

<br>Procedural Textures: Generate surface detail without needing high-resolution textures
<br>Dynamic Surface Effects: Adapt material appearance based on model parameters
<br>Example: A procedural rock model can have a procedural shader that controls:

<br>Color variation based on world position
<br>Edge wear effects using curvature maps
<br>Moss or dirt accumulation in crevices




<br>Key Concept: Both Procedural Modeling &amp; Shaders use node-based workflows (Houdini, Blender Geometry Nodes, Unity Shader Graph)
<br><br><br>
<br>Lighting in Games defines how objects appear based on:

<br>Direct Lighting (sunlight, spotlights)
<br>Indirect Lighting (bounced light, reflections)
<br>Ambient Lighting (general scene illumination)


<br>Shaders Enhance Lighting by:

<br>Controlling how materials respond to light (diffuse, metallic, specular)
<br>Using custom lighting models to override Unity‚Äôs default lighting
<br>Adding real-time effects, like rim lighting, emissive glow, and reflections


<br>Example: A lava shader that uses emissive properties to glow in dark environments<br>

<br><br><br>
<br>Shader Graph

<br>Visual scripting for shaders
<br>No need for HLSL coding
<br>Best for rapid prototyping
<br>Limited in customization (but extendable with code)


<br>HLSL / Custom Shader Code

<br>More control over rendering logic
<br>Better for performance optimizations
<br>Required for advanced effects (custom lighting, procedural vertex animations)


<br>When to Use Each?

<br>Shader Graph: Prototyping, procedural textures, stylized effects
<br>Handwritten Code: Performance-critical shaders, advanced lighting, VFX shaders


<br><br><br>
<br>Performance Considerations

<br>Reduce Overdraw: Use Alpha Clipping instead of transparent materials when possible
<br>Shader Complexity: Limit the number of shader passes (each pass is an extra rendering step)
<br>Optimize Textures: Avoid high-res textures where procedural patterns can be used


<br>Debugging Shader Graph

<br>Use Frame Debugger (Window &gt; Analysis &gt; Frame Debugger) to see rendering steps
<br>Use Material Debugging Mode (Scene View &gt; Debug Shading Modes) to isolate issues
<br>Always test shaders under different lighting conditions


<br><br><br>
<br>Stylized Games

<br>Example: Hollow Knight uses hand-painted textures + simple shaders for a 2D lighting effect


<br>Realistic Games

<br>Example: The Last of Us 2 uses physically-based shaders for materials like leather and metal


<br>Procedural Effects

<br>Example: No Man‚Äôs Sky procedural planets use Shader Graph for terrain blending


<br>Interactive Environments

<br>Example: Control by Remedy uses dynamic shaders for real-time environment shifts


<br>Takeaway: Shaders are a core part of how modern games achieve immersion and responsiveness!
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-2\gmap-395-wk-5-slides-+-video.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 5 - Slides + Video.md</guid><pubDate>Mon, 03 Feb 2025 19:40:02 GMT</pubDate><enclosure url="gmap-395\module-2\media\renderpipeline.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-2\media\renderpipeline.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Game-Based Real-Time Shader Control w/ DOTween]]></title><description><![CDATA[ 
 <br><br><br>In this tutorial, students will control shader parameters in real-time using C# scripts and game-based events. The goal is to modify the Eldritch Portal Shader from Week 4 dynamically, based on game logic (e.g., an enemy spawning from the portal).<br><br><br><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_IOWxZ2Vcsusxzvng?e=ONBhuI" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_IOWxZ2Vcsusxzvng?e=ONBhuI" target="_blank">gmap395_tut4.mp4</a><br><br><br>‚úÖ Unity 2022.3 with URP<br>
‚úÖ <a data-tooltip-position="top" aria-label="https://dotween.demigiant.com/getstarted.php" rel="noopener nofollow" class="external-link" href="https://dotween.demigiant.com/getstarted.php" target="_blank">DOTween</a><br>
‚úÖ Completion of Week 4‚Äôs Eldritch Portal Shader<br>
‚úÖ Basic familiarity with Shader Graph &amp; C# Scripting<br><br><br><br>Before we start controlling shader parameters, we need to install and set up DOTween in Unity. DOTween is a tweening engine that allows us to animate values smoothly over time, including object positions, UI elements, and shader properties.<br><br><br>
<br>Open Unity and go to the Asset Store (Window &gt; Asset Store). The asset store can also be accesses from the Unity Hub (Community &gt; Asset Store)
<br>Search for DOTween (by Demigiant). The free version is fine for this course.
<br>Click Add to My Assets, then Open in Unity it into your project. Then Import it.
<br>After importing, go to Tools &gt; DOTween Utility Panel in the top menu bar.
<br>Click Setup DOTween (this generates the necessary setup files).
<br><img alt="dotween1.png" src="gmap-395\module-2\media\dotween1.png"><br>
‚úÖ DOTween is now ready to use in your project! üéâ
<br><br><br>Let‚Äôs create a quick cube animation to test DOTween.<br><br>
<br>In a new test scene, in the Hierarchy, right-click and select 3D Object &gt; Cube.
<br>Rename it "TweenCube".
<br>Reset its Transform (Right-click Transform &gt; Reset in the Inspector).
<br><br>
<br>In the Project Window, in your Scripts folder create a new C# script named DOTweenTest.cs.
<br>Attach it to TweenCube.
<br>Open the script and replace its contents with:
<br>using UnityEngine;
using DG.Tweening; // Import DOTween

public class DOTweenTest : MonoBehaviour
{
    void Start()
    {
        // Move the cube up and down repeatedly
        transform.DOMoveY(3f, 1f) // Move to Y = 3 in 1 second
            .SetLoops(-1, LoopType.Yoyo) // Infinite loop with Yoyo effect
            .SetEase(Ease.InOutSine); // Smooth transition
    }
}
<br><br>
<br>Click Play in Unity.
<br>The cube will move up and down smoothly forever.
<br>Try modifying values like:

<br>Changing DOMoveY(3f, 1f) to DOMoveX(5f, 2f) to move sideways instead.
<br>Adjusting .SetEase(Ease.InOutSine) to .SetEase(Ease.OutBounce) for a different effect.


<br><br><br>‚úÖ DOMoveY(3f, 1f) ‚Üí Moves the cube‚Äôs Y position to 3 over 1 second.<br>
‚úÖ .SetLoops(-1, LoopType.Yoyo) ‚Üí Makes it loop infinitely (up and down).<br>
‚úÖ .SetEase(Ease.InOutSine) ‚Üí Creates a smooth, natural motion.<br>DOTween Documentation
All of the possible functions/methods and concepts around the tweening engine can be learned from the <a data-tooltip-position="top" aria-label="https://dotween.demigiant.com/documentation.php" rel="noopener nofollow" class="external-link" href="https://dotween.demigiant.com/documentation.php" target="_blank">documentation</a>.
<br><br><br><br>
<br>Open the EldritchPortalShader in Shader Graph.
<br>Locate the EdgeWidth property in the Blackboard.
<br>Check its Reference Name is set to _EdgeWidth in the Graph Inspector &gt; Node Settings (for C# access).
<br>Check that Exposed is ticked on.
<br>Save and Apply changes.
<br><br><br>We will use DOTween to smoothly animate the portal‚Äôs EdgeWidth when an "enemy is about to spawn."<br><br>
<br>In Unity, create a new C# script named PortalShaderController.cs.
<br>Attach it to the Portal GameObject, the one with the shader and material applied to it.
<br>Replace its contents with the following:
<br>using UnityEngine;
using DG.Tweening; // Import DOTween

public class PortalShaderController : MonoBehaviour
{
    public Material portalMaterial;  // Assign the material in the Inspector
    private static readonly int EdgeWidthProperty = Shader.PropertyToID("_EdgeWidth");

    public float normalWidth = 0.2f;
    public float alertWidth = 0.6f;
    public float transitionDuration = 1.0f; // How long the animation takes

    void Start()
    {
        if (portalMaterial == null)
        {
            Debug.LogError("Portal material not assigned!");
            return;
        }

        // Ensure EdgeWidth starts at normal width
        portalMaterial.SetFloat(EdgeWidthProperty, normalWidth);
    }

    // Triggered when an enemy is about to spawn
    public void ActivateAlert()
    {
        Debug.Log("Portal activating.");
        
        // DOTween smoothly changes EdgeWidth over time
        portalMaterial.DOFloat(alertWidth, EdgeWidthProperty, transitionDuration)
            .SetEase(Ease.InOutQuad);
    }

    // Reset the effect after a delay
    public void DeactivateAlert()
    {
        Debug.Log("Portal deactivating.");
        
        // DOTween smoothly returns EdgeWidth to normal
        portalMaterial.DOFloat(normalWidth, EdgeWidthProperty, transitionDuration)
            .SetEase(Ease.InOutQuad);
    }
}
<br><br>‚úÖ DOFloat(): Smoothly transitions the shader property over time.<br>
‚úÖ SetEase(Ease.InOutQuad): Adds a smooth acceleration/deceleration.<br>
‚úÖ ActivateAlert(): Expands the portal effect.<br>
‚úÖ DeactivateAlert(): Resets the effect after a delay.<br>Inspector Values
Be sure to assign the correct POrtal Material and tweak the Normal Width and Alert Width values in the Inspector for this script. If not errors may arise, such as a "NullReferenceExcpetion"
<br><img alt="portalInspector.png" src="gmap-395\module-2\media\portalinspector.png"><br><br><br><br>
<br>Create an empty GameObject named "EnemySpawner".
<br>Create a new script called EnemySpawner.
<br>Attach the script to it and replace its contents:
<br>using UnityEngine;
using System.Collections;

public class EnemySpawner : MonoBehaviour
{
    public PortalShaderController portalShader;
    public float spawnDelay = 5f;  // Time before enemy spawns

    void Start()
    {
        StartCoroutine(TriggerPortalAlert());
    }

    IEnumerator TriggerPortalAlert()
    {
        while (true)
        {
            yield return new WaitForSeconds(spawnDelay);
            
            Debug.Log("Enemy spawning. Triggering portal effect.");
            portalShader.ActivateAlert();
            
            yield return new WaitForSeconds(3f);
            
            Debug.Log("Enemy spawned. Resetting portal.");
            portalShader.DeactivateAlert();
        }
    }
}
<br><br>
<br>Drag the Portal GameObject into the portalShader field in the EnemySpawner script.
<br>Play the scene‚Äîthe portal will expand and contract smoothly when an enemy is "about to spawn."
<br><img alt="enemySpawnerInspector.png" src="gmap-395\module-2\media\enemyspawnerinspector.png"><br><br><br>‚úÖ Test different EdgeWidth values to fine-tune the visual effect.<br>
‚úÖ Experiment with DOTween easing settings (Ease.OutBounce, Ease.InCirc, etc.).<br>
‚úÖ Try different game triggers instead of a timer (e.g., using OnTriggerEnter).<br><br><br>‚úÖ Connected a C# script to Shader Graph to modify EdgeWidth dynamically.<br>
‚úÖ Used DOTween for smooth, animated transitions.<br>
‚úÖ Triggered the effect using a simulated enemy spawn event.<br>
‚úÖ Enhanced the experience with sound and particles.<br><br>
<br>Try controlling other shader properties (like SwirlSpeed or EdgeColor).
<br>Replace the enemy timer with a real game event (e.g., player proximity).  
<br>Experiment with DOTween sequencing for more complex VFX.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-2\gmap-395-wk-5-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 5 - Tutorial.md</guid><pubDate>Mon, 03 Feb 2025 20:48:44 GMT</pubDate><enclosure url="gmap-395\module-2\media\dotween1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-2\media\dotween1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[media]]></title><description><![CDATA[ 
 ]]></description><link>gmap-395\module-3\media\media.html</link><guid isPermaLink="false">GMAP 395/Module 3/media/media.md</guid><pubDate>Fri, 07 Feb 2025 19:44:31 GMT</pubDate></item><item><title><![CDATA[Assignment 3: Effects and Particle Systems]]></title><description><![CDATA[ 
 <br><br><br>Assignment Overview  
In this assignment, students will:

<br>Implement particle systems and/or visual effects into their procedural game asset created in Assignment 1.
<br>Use Unity‚Äôs Particle System (Shuriken) or VFX Graph to generate interactive and dynamic visual effects.
<br>Ensure the effects align with the class theme: Something from the Void.
<br>Integrate basic C# scripting to trigger or control the effects dynamically.
<br>Present their work with a README file documenting their process and a recorded video walkthrough.

<br><br><br>Assignment Breakdown

<br>Part 1: Creating Particle Effects<br>
Design and implement a particle system that enhances the visual presentation of your procedural asset.
<br>Part 2: Adding Interactivity<br>
Use C# scripting to dynamically control or trigger effects based on in-game interactions.

<br><br><br><br>How to Approach the Theme  
The theme Something from the Void should guide the design of your effects. Consider:

<br>Cosmic and Abstract: Floating mist, swirling void energy, or ethereal particles.
<br>Horror and Mystery: Dark fog, flickering embers, spectral trails.
<br>Otherworldly Technology: Electric sparks, pulsing energy bursts, mechanical steam vents.

<br><br><br>Key Steps for Part 1

<br>Choose a particle system type:

<br>Shuriken Particle System (Unity's Standard System)
<br>VFX Graph (for more advanced GPU-based effects)


<br>Design particle effects that complement your procedural asset.
<br>Implement at least two of the following particle behaviors:

<br>Emission Control (e.g., burst-based, looping, randomized rates)
<br>Lifetime Modulation (e.g., fading particles, size variation over time)
<br>Force Interaction (e.g., gravity, wind, turbulence fields)
<br>Material Shaders (e.g., glowing effects, transparency, additively blended particles)


<br>Integrate the particle system into your existing Unity scene.

<br>Example Effects

<br>Wisps of mist rising from the procedural artifact.
<br>A void portal with swirling energy particles.
<br>Sparks and dust emitted when an object is interacted with.

<br><br><br>Key Steps for Part 2

<br>Use C# scripting to add dynamic behavior to your particle system.
<br>Implement at least one of the following interactive mechanics:

<br>Trigger-based Activation: Particles appear when the player approaches.
<br>Scripted Changes: Adjust particle properties over time using C# (e.g., color shifts, intensity increases).
<br>Physics Integration: Particles that react to objects (collisions, forces).


<br>Ensure that your effect is optimized and does not negatively impact performance.

<br><br><br>What to Submit

<br>README File

<br>A text or markdown file describing:

<br>The design and inspiration for your particle system.
<br>How interactivity was implemented with C#.
<br>Any challenges faced and solutions applied.




<br>Recorded Video (5‚Äì10 Minutes)

<br>A screen-recorded walkthrough showcasing:

<br>The Unity scene with particle effects.
<br>Demonstration of the interactivity in action.
<br>Explanation of the design choices and implementation process.





<br>README Example Format
# Assignment 3: Effects and Particle Systems

## Particle System Overview
- Tool Used: Unity VFX Graph  
- Effect: A swirling energy vortex emitting sparks and mist.  
- Theme Connection: Represents a void artifact emitting unstable energy.

## Interactive Elements
- C# Script: Particles intensify when the player is near.  
- Additional Behavior: Fog particles follow the player slightly for atmospheric immersion.

## Challenges and Solutions
- Issue: Particles were too performance-heavy.
- Solution: Reduced spawn rate, optimized textures, and added LOD control.

<br><br><br>By completing this assignment, you will:

<br>Learn how to design and implement real-time visual effects.
<br>Develop skills in Unity‚Äôs Particle System and VFX Graph.
<br>Understand how to script dynamic interactions for game effects.
<br>Explore performance optimizations for real-time systems.

<br><br>Submission Guidelines

<br>Format: ZIP file uploaded to Drexel Learn.
<br>File Naming: abc123_Lastname_Firstname_A3.zip.
<br>Late Policy: 10% penalty per day.

<br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Module 3" data-href="GMAP 395 - Module 3" href="gmap-395\module-3\gmap-395-module-3.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-3\gmap-395-asn-3-brief.html</link><guid isPermaLink="false">GMAP 395/Module 3/GMAP 395 - ASN 3 - Brief.md</guid><pubDate>Mon, 17 Feb 2025 23:04:12 GMT</pubDate></item><item><title><![CDATA[Module 3 - Effects and Particle Systems]]></title><description><![CDATA[ 
 <br><br><br>This module focuses on particle systems and their role in game art and interactive experiences. Students will explore procedural and modular approaches to designing particle effects, learning how to implement them effectively within a game engine.<br><br><a data-href="GMAP 395 - ASN 3 - Brief" href="gmap-395\module-3\gmap-395-asn-3-brief.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - ASN 3 - Brief</a><br>
<a data-href="GMAP 395 - WK 6 - Slides + Video" href="gmap-395\module-3\gmap-395-wk-6-slides-+-video.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 6 - Slides + Video</a><br>
<a data-href="GMAP 395 - WK 6 - Tutorial" href="gmap-395\module-3\gmap-395-wk-6-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 6 - Tutorial</a><br>
<a data-href="GMAP 395 - WK 6 - In-Class Lab" href="gmap-395\module-3\gmap-395-wk-6-in-class-lab.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 6 - In-Class Lab</a><br><br><br>
<br>Introduction to particle systems in Unity.
<br>Fundamentals of procedural particle design.
<br>Implementing modular and reusable effects.
<br>Feedback and real-time interactivity with particle-driven events.
<br><br><br>By the end of this module, you will:<br>
<br>Gain foundational knowledge in particle-based effects.
<br>Understand procedural approaches to designing dynamic and modular effects.
<br>Learn to create particle-driven interactions using Unity's Particle System and VFX Graph.
<br>Implement event-driven effects to enhance gameplay feedback.
<br><br><br>
<br>Install Unity 2022.3 LTS.
<br>Review previous module work to integrate effects into existing assets.
<br>Explore Unity‚Äôs built-in Particle System and VFX Graph.
<br>If you have never used Unity‚Äôs Particle System  
Check out <a data-tooltip-position="top" aria-label="https://learn.unity.com/project/creative-core-vfx" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/project/creative-core-vfx" target="_blank">Unity Learn Creative Core: VFX</a>
<br><br><br><br><br><br>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/tutorial/introduction-to-particle-systems" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/tutorial/introduction-to-particle-systems" target="_blank">Unity Particle System Tutorials</a>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=TwWL5IY4Lqs&amp;list=PLQMQNmwN3FvySzk-SdqJeRa6hpH6FYKji" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=TwWL5IY4Lqs&amp;list=PLQMQNmwN3FvySzk-SdqJeRa6hpH6FYKji" target="_blank">Unity VFX Graph Essentials</a>
<br><a data-tooltip-position="top" aria-label="https://realtimevfx.com/" rel="noopener nofollow" class="external-link" href="https://realtimevfx.com/" target="_blank">Real-time VFX Community</a>
<br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\module-3\gmap-395-module-3.html</link><guid isPermaLink="false">GMAP 395/Module 3/GMAP 395 - Module 3.md</guid><pubDate>Mon, 10 Feb 2025 16:48:04 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 6 - In-Class Lab]]></title><description><![CDATA[ 
 <br>]]></description><link>gmap-395\module-3\gmap-395-wk-6-in-class-lab.html</link><guid isPermaLink="false">GMAP 395/Module 3/GMAP 395 - WK 6 - In-Class Lab.md</guid><pubDate>Mon, 10 Feb 2025 16:36:09 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 6 - Slides + Video]]></title><description><![CDATA[ 
 <br><br><br><br><br><br>
<br>Definition: Visual effects (VFX) generated and rendered in real-time during gameplay.
<br>Examples:

<br>Explosions
<br>Magic spells
<br>Environmental effects (rain, fog)
<br>UI enhancements (damage indicators, hit effects)


<br><br><a data-tooltip-position="top" aria-label="https://polydin.com/vfx-in-video-games/" rel="noopener nofollow" class="external-link" href="https://polydin.com/vfx-in-video-games/" target="_blank">VFX in Video Games | From History to Future</a><br>
<a data-tooltip-position="top" aria-label="https://magicmedia.studio/news-insights/guide-to-vfx-for-gaming/#:~:text=VFX in games are the computer-generated effects,realism%2C impact%2C and excitement in the game." rel="noopener nofollow" class="external-link" href="https://magicmedia.studio/news-insights/guide-to-vfx-for-gaming/#:~:text=VFX%20in%20games%20are%20the%20computer%2Dgenerated%20effects,realism%2C%20impact%2C%20and%20excitement%20in%20the%20game." target="_blank">The Ultimate Guide to VFX for Gaming: From Explosions to Environments</a><br><br><br>
<br>Enhance Visual Feedback

<br>Instant response to player actions.


<br>Reinforce Game Mechanics

<br>Visual cues for interaction and gameplay.


<br>Create Atmosphere and Mood

<br>Set tone and immersion.


<br>Guide Player Attention

<br>Highlight important elements dynamically.


<br><img alt="vfxingamestypes.webp" src="gmap-395\module-3\media\vfxingamestypes.webp" style="width: 720px; max-width: 100%;"><br><br><br>
<br>Player Control: VFX enhance the feeling of control.
<br>Actions and Events: VFX reinforce gameplay actions visually.
<br>User Feedback: Immediate, clear responses to inputs.
<br><img alt="gamefeelcover.webp" src="lib\media\gamefeelcover.webp"><br><br><br>
<br>Input: Player action (button press, movement).
<br>Response: Immediate visual feedback.
<br>Context: Game state, environment.
<br>Polish: Added visual elements for clarity.
<br>Metaphor: Visual representation of actions.
<br>Rules: Logic governing interactions.
<br>Juiciness: Visually satisfying effects.
<br><br><br>
<br>Definition: Algorithm-driven (rules-driven) VFX.
<br>Benefits:

<br>Efficient content creation.
<br>Runtime variety.
<br>Adaptability to dynamic scenarios.


<br><br><br>
<br>Definition: Using reusable, interchangeable VFX components ("layering meaningful stuff").
<br>Advantages:

<br>Consistency across effects.
<br>Easier iteration and updates.
<br>Performance optimization.


<br><br><br><br>
<br>Breakdown of stylized VFX in League of Legends.
<br>Use of lighting, particles, and shaders to enhance character identity.
<br>Blog: <a data-tooltip-position="top" aria-label="https://leagueoflegends.com/en-us/news/dev/dev-a-storm-is-brewing/" rel="noopener nofollow" class="external-link" href="https://leagueoflegends.com/en-us/news/dev/dev-a-storm-is-brewing/" target="_blank">A Storm is Brewing</a>
<br><img alt="volibear.jpg" src="gmap-395\module-3\media\volibear.jpg" style="width: 720px; max-width: 100%;"><br><br><br>
<br>Built-in VFX tool with CPU-based simulation.
<br>Efficient for many effects, but has limitations for complex scenes.
<br>Trusted by developers, used for particles like:

<br>Smoke
<br>Fire
<br>Sparks


<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/ParticleSystem.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/ParticleSystem.html" target="_blank">Unity ParticleSystem Doc</a><br><br><br>
<br>Emitter: Spawns particles in the scene.
<br>Particles: Individual units of the effect.
<br>Modules: Control particle behavior over time.

<br>Emission: When and how particles are generated.
<br>Shape: The emission area (sphere, cone, box, mesh).
<br>Over Lifetime: Changes in particle size, speed, color, etc.


<br><img alt="unityParticleSystsem.png" src="gmap-395\module-3\media\unityparticlesystsem.png" style="width: 320px; max-width: 100%;"><br><br><br><br>
<br>Controls emission rate (particles per second).
<br>Emission Type:

<br>Continuous
<br>Burst (one-time)
<br>Periodic


<br><br>
<br>Sphere: Emission from a spherical area.
<br>Cone: Directional emission.
<br>Box: Emission within a rectangular volume.
<br>Mesh: Emission from a custom mesh.
<br><br><br>
<br>Color Changes: Transitions particle colors over time.

<br>Example: Fire transitions from red ‚Üí yellow ‚Üí orange.


<br>Gradient Use: Defines smooth color changes.
<br><br><br>
<br>Node-Based Tool: Visual effect creation without scripting.
<br>GPU-Accelerated: Handles millions of particles efficiently.
<br>SRP Required: Requires Scriptable Render Pipeline for optimal performance.
<br><img alt="vfxg1.png" src="gmap-395\module-3\media\vfxg1.png"><br><br><br>
<br>Nodes and Blocks: Define particle behavior.
<br>Contexts: Stages of effect processing (spawn, initialize, update, output).
<br>Properties: Global values affecting multiple nodes.
<br>Attributes: Per-particle data like position, velocity, color.
<br>Operators: Perform calculations and logic in the effect.
<br>Events: Control effect timing and triggering.
<br>Systems: Grouped VFX elements working together.
<br><br><br><br><br><br>
<br>Animation Curves: Define smooth transformations.
<br>Noise-Based Movement: Create natural, organic motion.
<br>GPU Events: React to game logic dynamically.
<br><br><br>
<br>Particle Count: Higher counts impact FPS.
<br>Texture Size: Large textures increase memory load.
<br>Overdraw: Too many overlapping transparent particles = wasted draw calls.
<br>CPU vs. GPU Load: Minimize CPU dependency for smoother performance.
<br><br><br>
<br>Color Palettes: Match game aesthetics.
<br>Particle Shapes: Custom visuals for a unique look.
<br>Style Guide: Ensures consistent VFX appearance across the game.
<br><br><br><br>
<br>A documented set of rules that defines the visual and design principles of a game‚Äôs VFX, materials, and assets.
<br>Helps artists, designers, and developers create consistent and cohesive effects across the game.
<br>Ensures readability and player experience remain clear, even in complex gameplay.
<br> Ensuring Visual Consistency &amp; Player Readability in Games<br><br><br>‚úÖ Consistency ‚Äì All effects maintain a unified artistic vision.<br>
‚úÖ Readability ‚Äì Ensures visual effects clearly communicate gameplay mechanics.<br>
‚úÖ Efficiency ‚Äì Streamlines asset production and iteration.<br>
‚úÖ Performance ‚Äì Prevents excessive visual clutter and optimizes resources.<br><br><br>
<br>How League of Legends creates clear, readable, and stylized VFX.
<br>Read more: <a data-tooltip-position="top" aria-label="https://nexus.leagueoflegends.com/en-us/2017/10/dev-leagues-vfx-style-guide/" rel="noopener nofollow" class="external-link" href="https://nexus.leagueoflegends.com/en-us/2017/10/dev-leagues-vfx-style-guide/" target="_blank">League‚Äôs VFX Style Guide</a>
<br>
Example: League of Legends' VFX style guide ensures every champion‚Äôs effects are instantly recognizable across different skins and themes.
<br><a rel="noopener nofollow" class="external-link" href="https://realtimevfx.com/t/official-league-of-legends-vfx-style-guide/3392" target="_blank">https://realtimevfx.com/t/official-league-of-legends-vfx-style-guide/3392</a><br><br><br><br>
<br>Charge-Up: Initial build-up of energy.
<br>Release: Effect execution (e.g., spell cast, explosion).
<br>Impact: The moment of interaction.
<br>Lingering Effects: Residual visuals post-action.
<br><br><br><br>
<br>Design Effect: Sketch and concept.
<br>Emitter System: Implement using Particle System.
<br>Enhance with VFX Graph: Add procedural details.
<br>Game Integration: Attach effects to game objects.
<br><br><br>
<br>Tied to Player Actions

<br>Example: Sword swings ‚Üí Motion trails
<br>Example: Magic casting ‚Üí Particle buildup


<br>Feedback and Clarity

<br>Example: Enemy damage hit sparks
<br>Example: Low-health warning effects


<br><br><br>
<br>Unity VFX Documentation: <a data-tooltip-position="top" aria-label="https://docs.unity3d.com/" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/" target="_blank">Unity Docs</a>
<br>VFX Artist Communities: <a data-tooltip-position="top" aria-label="https://realtimevfx.com/" rel="noopener nofollow" class="external-link" href="https://realtimevfx.com/" target="_blank">Real-Time VFX</a>
<br>Tutorials &amp; Guides: on YouTube, Etc.
<br><br><br>
<br>Create a VFX sequence for a simple game mechanic using:

<br>Unity‚Äôs Particle System
<br>VFX Graph
<br>Game Feel principles


<br><br><br>
<br>Real-Time VFX improves game feedback, immersion, and polish.
<br>Unity‚Äôs Particle System and VFX Graph both serve different needs.
<br>Balance performance and aesthetics to optimize gameplay experience.
<br><br><br>
<br>Implement a basic real-time VFX system in Unity.
<br>Focus on timing, response, and feedback.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 3" data-href="GMAP 395 - Module 3" href="gmap-395\module-3\gmap-395-module-3.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-3\gmap-395-wk-6-slides-+-video.html</link><guid isPermaLink="false">GMAP 395/Module 3/GMAP 395 - WK 6 - Slides + Video.md</guid><pubDate>Mon, 17 Feb 2025 17:08:08 GMT</pubDate><enclosure url="gmap-395\module-3\media\vfxingamestypes.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-3\media\vfxingamestypes.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Enhancing the Eldritch Portal with VFX]]></title><description><![CDATA[ 
 <br><br><br>In this tutorial, we will enhance the Eldritch Portal Shader (from Week 4 &amp; 5) by creating a particle-based anticipatory effect in Unity‚Äôs VFX Graph. This effect will foreshadow the portal‚Äôs opening using an ever-present particle ring that intensifies and converges before triggering a vertical energy beam just before the portal activates.  This first tutorial will focus ion just setting up the particle systems that will be animated later.<br><img alt="portalVFXSplash.png" src="gmap-395\module-3\media\portalvfxsplash.png"><br><br>‚úÖ Unity 2022.3 with URP and VFX Graph Installed<br>
Ensure Visual Effect Graph is installed and updated via Unity Package Manager.<br>
Go to the Unity Registry tab and search for "Visual Effect Graph"<br>
‚úÖ Completion of the Eldritch Portal Shader tutorial<br>
‚úÖ Basic understanding of Unity‚Äôs VFX Graph &amp; Shader Graph<br>Disclaimer: Video Tutorial
You will likely need to follow this written tutorial AND watch the companion video tutorial (below) in order to grasp all of the steps and concepts of the complete tutorial.
<br><br><br><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_IrSYR-9QRFCYz4JA?e=fqUvll" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_IrSYR-9QRFCYz4JA?e=fqUvll" target="_blank">gmap395_wk6.mp4</a><br><br><br>In this section, we will create the particle ring effect that surrounds the portal, acting as a constant, pulsing energy field. As the portal prepares to open, the particles will intensify, swirl, and shimmer to build anticipation. This effect establishes a visual anchor around the portal, reinforcing its mystical energy and foreshadowing the activation sequence.<br><br>
<br>Right-click in the Project window and create a "VFX" folder to organize all VFX assets.
<br>Inside the VFX folder, select Create &gt; Visual Effects &gt; Visual Effect Graph.
<br>Name it PortalRingVFX.
<br>Drag the VFX Graph into the Scene and position it near the portal asset's center.
<br>Open the VFX Graph by double-clicking PortalRingVFX.
<br>In the Spawn context, increase the Rate from 16 to 100 or more (experiment for desired effect).
<br><br>
<br>Inside the VFX Graph, locate the Initialize Particle block.
<br>Set the Capacity to 500 (Adjust for performance needs).
<br>Add a Set Position (Arc Circle) block:

<br>Radius: Create a float parameter in the Blackboard named PortalRingRadius and connect it.
<br>Arc Max: 6.28 (Full circle).
<br>Position Mode: Surface.
<br>Spawn Mode: Random (Feel free to experiment).
<br>Set Angles X position to 90¬∞ in the Circle &gt; Transform &gt; Angles dropdown.


<br>Remove the default Set Velocity block.
<br>Add a Set Velocity from Direction and Speed (Tangent) block:

<br>Create a float parameter RingRotationSpeed and connect it to Max Speed.


<br>Set color by Speed (Gradient):

<br>Create a Gradient parameter (PortalRingColor) in the Blackboard.
<br>Adjust gradient Intensity for each color selected to ensure strong Bloom interaction.
<br>Use RingRotationSpeed to set max speed in the Speed Range.


<br>Use the default Set Lifetime (Random Uniform) block already present:

<br>Create a Vector2 parameter (RingLifetimeMinMax) via the Blackboard.
<br>Connect X (Min) and Y (Max) to the Set Lifetime block.


<br>To see color take effect:

<br>Change the main texture of the particles (Default-Particle (a B/W gradient) works well).
<br>Delete the Set Color Over Life block in the Output Particle Quad context.


<br><br>
<br>Use the Update Particle context to enhance visual interest:
<br>Add a Conform to Sphere block:

<br>Set Sphere Radius using PortalRingRadius parameter.


<br>Add a Turbulence block:

<br>Mode: Relative
<br>Noise Type: Perlin (Feel free to experiment).


<br>Adjust force parameters for desired motion.
<br><br>
<br>Experiment with Blend Modes:

<br>Suggested: Additive for glowing effects.


<br>Adjust Set Size (Random from Curve):

<br>Click the curve and set linear increase from (0,0) to (1,0.1).
<br>Set a random seed value or leave it at 0.


<br>Ensure there is an Orient: Face Camera Plane.
<br>Use a custom particle shape:

<br>Set the Main Texture to Default-Particle or create a custom texture with an alpha mask in an external program.


<br><br><br>In this section, we will create the vertical energy beam effect that erupts from the center of the portal just before it opens. This effect will consist of a core beam and trailing energy ribbons to enhance the feeling of the activation sequence, give it more visual "punch".<br><br>
<br>Create a new VFX Graph (Right-click &gt; Visual Effects &gt; Visual Effect Graph), name it PortalBeamVFX.
<br>Drag the VFX Graph into the Scene and position it at the center of the portal, aligned with the swirling portal effect.
<br>Increase the Spawn Rate:

<br>In the Spawn context, set Rate (Over Time) to 250 to match the ring effect.


<br>Define the Beam‚Äôs Shape:

<br>Add a Set Position (Line) block.
<br>Set Start Position to (X: 0, Y: 0, Z: 0).
<br>Set End Position to (X: 0, Y: 1, Z: 0).
<br>Create a float parameter BeamLineEnd in the Blackboard (default 1) and connect it to End Y.


<br>Apply Velocity Randomization:

<br>Add a Set Velocity Random block. Delete the old set velocity if needed.
<br>Set X &amp; Z Ranges: -0.01 to 0.01 (slight horizontal drift).
<br>Set Y Range: 0 to 1 (upward motion).


<br>Control Particle Lifetime:

<br>Add a Set Lifetime Random (Uniform) block.
<br>Create a Vector2 parameter BeamLifetimeMinMax in the Blackboard.
<br>Set X = 5 and Y = 10, then connect to A and B inputs.


<br>Set Beam Color Based on Speed:

<br>Add a Set Color by Speed (Gradient) block.
<br>Create a Gradient parameter BeamColor.

<br>Reverse the gradient values so that darker colors are on the left and brighter colors are on the right.
<br>Increase alpha from 0% (left) to 100% (right) to make the beam fade in over its lifespan.




<br><br><br>Now, we will create GPU Events to be used later when we expand the beam effect.<br>
<br>Add GPU Event Blocks:

<br>Create a Trigger Event Always block and set the count to 250.
<br>Create a Trigger Event Rate (Over Time) block and set the Rate to 250.


<br><br><br>To add visual complexity, we will duplicate the particle system and create a trailing energy effect.<br><br>
<br>Remove the Output Particle Quad (it is not needed for this effect).
<br>Duplicate the entire particle network (Drag Select &gt; Right-click &gt; Duplicate).
<br>Modify the Duplicate:

<br>Remove the Trigger Event Always from the duplicate.
<br>Create a GPU Event in an empty area.
<br>Connect the Trigger Event Always from the first network to this GPU Event.
<br>Connect this GPU Event to the Initialize Particle block of the duplicate network.


<br><br>
<br>Reverse the Direction of the Second Beam:

<br>Add a Multiply by (-1) node.
<br>Connect BeamLineEnd to this node and then to the Shape: Line End (Y) of the duplicate.


<br>Ensure Both Beams Share Parameters:

<br>Connect BeamLifetimeMinMax and BeamColor to the duplicate network.


<br><br><br>To create trailing effects, we will use Unity's built-in Example Heads and Trails system network.<br>
<br>Add an Example Heads and Trails node.
<br>Delete the Heads Network section (we only need the Trail Bodies).
<br>Connect the First Beam‚Äôs Trigger Event Rate:

<br>Connect Trigger Event Rate from the first network to the GPU Event of Trail Bodies.


<br>Refine the Trail Behavior:

<br>Remove Set Lifetime and replace it with Inherit Source Lifetime (Set).
<br>Remove Turbulence from Update Particle Strip.
<br>Change Blend Mode in Output Particle Strip Quad to Additive.
<br>Replace Set Size Over Life with Set Size Random (Uniform).

<br>Create a Vector2 parameter BeamSize (X = 0.01, Y = 0.05) to connect to the Set Size inputs.




<br><br>
<br>Duplicate the Trail Bodies network.
<br>Connect the Second Beam‚Äôs Trigger Event Rate to the GPU Event of the duplicate.
<br><br><br>‚úÖ Two beams should now be shooting both upwards and downwards from the portal‚Äôs center.<br>
‚úÖ No need to animate exposed values yet; we‚Äôll handle this next week.<br>
‚úÖ You should now have a visually busy portal effect with swirling particles and beams.<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 3" data-href="GMAP 395 - Module 3" href="gmap-395\module-3\gmap-395-module-3.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-3\gmap-395-wk-6-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 3/GMAP 395 - WK 6 - Tutorial.md</guid><pubDate>Wed, 12 Feb 2025 17:07:10 GMT</pubDate><enclosure url="gmap-395\module-3\media\portalvfxsplash.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-3\media\portalvfxsplash.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 7 - In-Class Lab]]></title><description><![CDATA[ 
 <br><br><br>Create a modular, procedural beam/stream effect that follows a path(spline), and collides with surfaces.<br><br>
<br>Create a new VFX Graph:

<br>Right-click in the Project window
<br>Select Create &gt; Visual Effects &gt; Visual Effect Graph
<br>Name it BeamEffect


<br>Set up the basic structure:

<br>Add a Spawn context
<br>Add an Initialize Particle context
<br>Add an Update Particle context
<br>Add an Output Particle Quad context


<br>In the Spawn context:<br>
- Set the spawn rate to Constant with a value of 5000+
Spawn Rate/Count  
A high spawn rate creates a dense, continuous stream effect.


<br>In the Initialize Particle context:

<br>Delete all default nodes except Capacity
<br>Add a Set Position block
<br>Add a Set Velocity Random form Curve block<br>
<img alt="lab_vfx2_init.png" src="gmap-395\module-3\media\lab_vfx2_init.png">


<br>In the Update Particle context:

<br>Add a Set Lifetime node

<br>Set the lifetime to a value of 5 seconds (adjustable based on desired effect duration)


<br>Add a Set Size over Lifetime node

<br>Create a size curve that stays consistent over the particle lifetime<br>
<img alt="Pasted image 20240729215838.png" src="gmap-395\module-3\media\pasted-image-20240729215838.png">




<br>In the Output Particle Quad context:

<br>Set the particle rendering to Quad (which it should be by default)
<br>Set the Blend Mode to Addative
<br>Assign a gradient to the Set Color over Life block


<br>Blend Mode  
Ensure the Blend Mode set to an Additive shader to create a glowing beam effect with Post Processing.
<br><br>
<br>
Create a Block Sub-graph for Path Following:

<br>Right-click in the Project window
<br>Select Create &gt; Visual Effects &gt; Visual Effect Sub-graph Block
<br>Name it PathFollow


<br>Sub-graphs  
Sub-graphs allow you to create reusable components for your VFX, making your graph more modular and easier to manage.
<br>
<br>In the Block Sub-graph:

<br>Set the Suitable Contexts to Update
<br>Add a Set Position node/block
<br>Outside of the Bock Subgraph: 

<br>Create a Sample Bezier node
<br>Create am Age Over Lifetime node and connect it to the T input of the Sample Bezier
<br>Create a Get Attribute: Particle ID node
<br>Create an Add node and add the Position output of the Sample Bezier with the Particle ID output of the Get Attribute nodes
<br>Create a Perlin Curl Noise 3D node and plug the output of the Add node to the Coordinate input
<br>Create a Multiply node and plug the Noise output to the A input
<br>Create another Add node add the Multiply output with the Position output of the Sample Bezier 
<br>Plug the Add output into the Position input of the Block Subgraph Set Position block
<br><img alt="lab_vfx2_baseSubgraph.png" src="gmap-395\module-3\media\lab_vfx2_basesubgraph.png">




<br>Expose parameters in the Block Sub-graph:

<br>Add Positon (x4) parameters for the path and name them 1 - 4

<br>Plug these position parameters into the A - D inputs of the Sample Bezier
<br><img alt="lab_vfx2_sampleBez.png" src="gmap-395\module-3\media\lab_vfx2_samplebez.png">


<br>Add a Float parameter named Spread and default to 0.25

<br>Plug the Spread parameter into the B input of the Multiply node
<br><img alt="lab_vfx2_multiplySubg.png" src="gmap-395\module-3\media\lab_vfx2_multiplysubg.png">


<br>Save you VFX Subgraph<br>
<img alt="lab_vx2_fullSubg.png" src="gmap-395\module-3\media\lab_vx2_fullsubg.png">


<br>In your main VFX Graph, add your new Block Sub-graph node to the Update Particle context:

<br>You will need to create new exposed parameters for the Spread - Float and 1-4 - Position parameters in the main graph Blackboard.
<br>When this is done go into the Unity Editor and put your VFXG in the scene (if not done so already)
<br>In the Unity Hierarchy add 4 empty game objects and name them p1-p4 to represent the transform position of the spline

<br><img alt="lab_vfx2_posSetup.png" src="gmap-395\module-3\media\lab_vfx2_possetup.png">


<br>In the Inspector, on your VFXG game object add a VFX Property Binder component
<br>Add (x4) Position properties to the Property Bindings section

<br>+ &gt; Transform &gt; Position (x4)
<br>Click on one the top property binding set the Target to p1 and set the Property name to 1_position

<br>Repeat this step for the remaining 3 properties, making sure the Property name is #_position<br>
<img alt="lab_vfx2_propBinders.png" src="gmap-395\module-3\media\lab_vfx2_propbinders.png">






<br>Naming Convention
In the property binder the Property name should be the name of the property from the main graph Blackboard followed by an underscore and property type PropertyName_TypeOfBinder. So in this case it is #_position
<br>Modular Approach  
This modular approach allows you to easily change the path of the beam, enabling dynamic and flexible visual effects.
<br>
<br>In the main VFX Graph your Path Follow node should have the 1-4 Position Properties and the Spread property plugged in to their respective inputs<br>
<img alt="lab_vfx2_followPath.png" src="gmap-395\module-3\media\lab_vfx2_followpath.png">
<br><br>
<br>In the Update Particle context, add a Turbulence node:

<br>Connect it to various exposed properties to control later in C# (if desired)


<br>In the Update Particle context, add a Collision node:<br>
- There are a few collision types so pick one like Collide with Sphere<br>
- Set the Transform&gt;Position of block/node to the end of the spline (the 4 position property)<br>
<img alt="lab_vfx2_4Pos.png" src="gmap-395\module-3\media\lab_vfx2_4pos.png">
<br><br>
<br>Create a GPU Event (On Die)<br>
1. In the new Initialize Particle context section:<br>
1. Set Lifetime Random using desired values<br>
2. Set Velocity Random sing desired values<br>
3. Create a Set Position (Mesh) block<br>
1. Set the position to the last position (4) of the spline using the 4 position property as the input for Transform&gt;Position input
First VFX Lab
This is very similar in style to the GPU Event form the first VFX Graph Lab


<br>In the Blackboard:

<br>Create an exposed Mesh property called Spawn Mesh

<br>Plug this property into the Mesh input of the Set Position (Mesh) block


<br>Create a Vector 3 Called Mesh Scale

<br>Plug this into the Transform&gt;Scale input of the Set Position (Mesh) block<img alt="lab_vfx2_gpuInit.png" src="gmap-395\module-3\media\lab_vfx2_gpuinit.png">




<br>In the Update Particle context:

<br>Add nodes to create a desired On Die particle effect
<br>For example:

<br>Add Set Size Random
<br>Add Turbulence
<br>Add Gravity



<img alt="lab_vfx2_gpuUpdate.png" src="gmap-395\module-3\media\lab_vfx2_gpuupdate.png">
<br>In the Output Particle Quad context:
<br>
<br>Add a Set Color over Life block and use a gradient, like before<br>
<img alt="lab_vfx2_gpuOut.png" src="gmap-395\module-3\media\lab_vfx2_gpuout.png">
<br>
<br>In your main beam VFX Graph, add a Trigger Event node:<br>
- Trigger this event on particle death Trigger Event on Die<br>
- Use this event to spawn your impact effect for the VFX Graph<br>
<img alt="lab_vfx2_gpuTrigger 2.png" src="gmap-395\module-3\media\lab_vfx2_gputrigger-2.png">
Note
Combining multiple VFX Graphs/Subgraphs/GPU Events allows for more complex, layered effects.



<br><br><br>
<br>Make the beam reactive to player input, allowing real-time control of the path. (C# Scripting)
<br>Implement a more complex impact response, like surface scorching or deformation. (Shader on Mesh)
<br>Use ta shader to create a more complex procedural animation for the beam particles.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 3" data-href="GMAP 395 - Module 3" href="gmap-395\module-3\gmap-395-module-3.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-3\gmap-395-wk-7-in-class-lab.html</link><guid isPermaLink="false">GMAP 395/Module 3/GMAP 395 - WK 7 - In-Class Lab.md</guid><pubDate>Mon, 17 Feb 2025 23:16:40 GMT</pubDate><enclosure url="gmap-395\module-3\media\lab_vfx2_init.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-3\media\lab_vfx2_init.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 7 - Slides + Video]]></title><description><![CDATA[ 
 <br><br><br><br><br><br>
<br>What are real-time VFX?
<br>Why are they crucial for game development?
<br>How do they integrate into modern game engines?
<br>Where do shaders fit in?
<br><br><br><br>
<br>Enhancing Game Feel: Player immersion through visual impact
<br>Providing Visual Feedback: Representing gameplay mechanics
<br>Creating Atmosphere: Setting the mood and tone of a game world
<br>Guiding Player Attention: Directing the eye using motion and color
<br><br><br><br>
<br>What is VFX Graph?

<br>A GPU-powered, node-based tool for creating real-time VFX


<br>Why use VFX Graph instead of a traditional particle system?

<br>Performance: Uses GPU acceleration
<br>Flexibility: Can handle complex simulations
<br>Scalability: Works with procedural effects


<br><a data-tooltip-position="top" aria-label="https://unity.com/features/visual-effect-graph" rel="noopener nofollow" class="external-link" href="https://unity.com/features/visual-effect-graph" target="_blank">VFX Graph</a><br><img alt="vfxgSplash.png" src="gmap-395\module-3\media\vfxgsplash.png" style="width: 720px; max-width: 100%;"><br><br><br>
<br>Initialize, Update, and Output Stages

<br>Each stage controls different aspects of an effect


<br>Using Contexts to Structure Effects

<br>Emit, spawn, evolve, and output visual data


<br>Key Properties and Attributes

<br>Controlling speed, lifespan, and rendering of particles


<br><img alt="VFXGraph_3-5_ComplexNetwork.png" src="gmap-395\module-3\media\vfxgraph_3-5_complexnetwork.png" style="width: 720px; max-width: 100%;"><br><br><br>
<br>Definition: Designing reusable, interchangeable VFX components
<br>Why Modular?

<br>Consistency: Keeps effects visually unified
<br>Efficiency: Reduces redundant work
<br>Flexibility: Enables rapid iteration and customization


<br><br><br>
<br>Sub-graphs: Reusable VFX components
<br>Prefab Systems: Assigning VFX to game assets dynamically
<br>Scriptable Objects: Storing reusable effect parameters
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=DRi2bRDB-x0" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=DRi2bRDB-x0" target="_blank">Proceduralism as a catalyst for creativity feat. Julie Lottering from SideFX</a><br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=lb4yVPeWuwY" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=lb4yVPeWuwY" target="_blank">Proceduralism for Games? Short answer is YES. | Christos Stavridis | GDC HIVE 2023</a><br><br><br>
<br>Definition: Using algorithms to generate VFX dynamically
<br>Applications in Games:

<br>Particle behavior (e.g., wind-driven dust, randomized explosions)
<br>Procedural shape generation (e.g., smoke, fire)
<br>Color schemes that evolve over time


<br><a data-tooltip-position="top" aria-label="https://www.autodesk.com/solutions/procedural-generation" rel="noopener nofollow" class="external-link" href="https://www.autodesk.com/solutions/procedural-generation" target="_blank">Procedural generation: Creating infinite algorithmic realities</a><br><br><br><br>
<br>Noise in Motion:

<br>Integrating Perlin noise for fluid, organic movement


<br>Shaping Effects with Noise:

<br>Creating naturalistic smoke, fire, and energy patterns


<br><a data-tooltip-position="top" aria-label="https://adrianb.io/2014/08/09/perlinnoise.html" rel="noopener nofollow" class="external-link" href="https://adrianb.io/2014/08/09/perlinnoise.html" target="_blank">Understanding Perlin Noise</a><br>
[Perlin Noise: A Procedural Generation Algorithm](# Perlin Noise: A Procedural Generation Algorithm)<br><img alt="perlin-noise-terrain-mesh1.png" src="gmap-395\module-3\media\perlin-noise-terrain-mesh1.png" style="width: 720px; max-width: 100%;"><br><br><br>
<br>What is Mesh Emission?

<br>Using 3D models as particle emitters instead of simple point sources


<br>Why Use Meshes?

<br>Enables complex particle behaviors
<br>Aligns particles with character movements
<br>Creates detailed environmental effects


<br><br><br>
<br>Import a mesh asset
<br>Set it as the emitter in the VFX Graph
<br>Control particle emission based on mesh attributes
<br>Adjust parameters for density and speed
<br><br><br><br>
<br>What are Decals?

<br>2D images projected onto 3D surfaces


<br>Use Cases:

<br>Blood splatters, bullet holes, footprints
<br>Magic circles, surface-based energy effects


<br>Performance Benefits:

<br>Add detail without modifying geometry
<br>Can be animated dynamically in VFX Graph


<br>
[URP Decals in Unity](https://www.youtube.com/watch?v=zSMjTK8d7GQ)<br><br><br>
<br>Animating Decals: Simulating movement on surfaces
<br>Reactive Decals: Creating effects like scorch marks that fade over time
<br>Optimizing Performance: Using GPU-friendly decal projection
<br><br><br>
<br>Why Interaction Matters in VFX

<br>Makes environments feel alive and reactive
<br>Enhances player feedback in gameplay


<br>Examples of Interactive VFX

<br>Splashes in water when a character lands
<br>Dust kicking up as a player runs
<br>Particles colliding with objects (rain hitting surfaces)


<br><img alt="Block-CollideWithDepthBufferMain.png" src="gmap-395\module-3\media\block-collidewithdepthbuffermain.png"><br><br><br>
<br>Activate collision detection in VFX Graph
<br>Define collision surfaces (plane, sphere, or mesh)
<br>Apply force or change particle behavior upon impact
<br><br><br>
<br>Why Use Shaders in VFX?

<br>Shaders modify particle visuals dynamically
<br>Add advanced effects like refraction, emissive glow, and distortion


<br>How It Works:

<br>Use Shader Graph as an output material in VFX Graph
<br>Modify shader parameters in real-time based on particle properties


<br><br><br>
<br>Examples of Shader-Controlled VFX

<br>Heat distortions for explosions
<br>Energy-based auras that pulse dynamically
<br>Water ripples that react to collisions


<br>Using Shader Graph to Adjust Particle Appearance

<br>Connect VFX Graph outputs to shader inputs
<br>Modify properties like opacity, glow, and texture movement


<br><br><br>
<br>Example Workflow:

<br>Create a VFX Graph system for an explosion
<br>Apply Shader Graph to control particle visuals
<br>Use real-time parameters (e.g., intensity, color) to adjust shader properties


<br>Benefit: More integrated, seamless visual effects
<br><br><br>
<br>Modifying Shader Properties via Gameplay

<br>Connecting game events to VFX shader parameters
<br>Examples:

<br>Fire effect that intensifies when a player is near
<br>Magic aura that fades when a spell ends




<br><br><br>
<br>Expose shader parameters to Unity‚Äôs inspector
<br>Modify them in real-time using scripts
<br>Link parameters to gameplay events
<br>Optimize for performance
<br><a rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/VFX.VisualEffect.html" target="_blank">https://docs.unity3d.com/6000.0/Documentation/ScriptReference/VFX.VisualEffect.html</a><br><br><br>
<br>Balancing visual fidelity and frame rate

<br>Avoiding overdraw in transparent particle effects
<br>Reducing unnecessary GPU calculations
<br>Using GPU instancing for efficient rendering


<br><br><br>
<br>Limit Simultaneous effects: Fewer complex effect splaying at one time
<br>Reduce Particle Lifetime: Shorter effects reduce CPU/GPU load
<br>Use "LODs" for Effects: Lower detail for distance effects
<br><br><br>
<br>Example:

<br>How Control (Remedy Entertainment) handles interactive lighting &amp; destruction effects
<br>How Destiny 2 (Bungie) uses shader-driven energy effects to create responsive player abilities


<br><br><br>
<br>AI-Assisted VFX Creation
<br>Ray-Traced Particle Systems for ultra-realistic lighting
<br>Procedural VFX Workflows for generative effects in games
<br>VFX in XR (VR/AR/MR) for immersive real-time experiences
<br><br><br>
<br>Modular and procedural workflows enable flexible VFX
<br>Shaders + VFX Graph create advanced, real-time visual effects
<br>Performance optimization is crucial for real-time rendering
<br>Interactive VFX enhances immersion and gameplay feedback
<br><br><br>
<br>How do shaders enhance VFX in gameplay?
<br>What are some real-world examples of modular VFX?
<br>Where do you see VFX heading in the next five years?
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 3" data-href="GMAP 395 - Module 3" href="gmap-395\module-3\gmap-395-module-3.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-3\gmap-395-wk-7-slides-+-video.html</link><guid isPermaLink="false">GMAP 395/Module 3/GMAP 395 - WK 7 - Slides + Video.md</guid><pubDate>Mon, 17 Feb 2025 21:07:24 GMT</pubDate><enclosure url="gmap-395\module-3\media\vfxgsplash.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-3\media\vfxgsplash.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - Week 7 Tutorial]]></title><description><![CDATA[ 
 <br><br><br><br><br>This tutorial refines the timing and sequencing of the portal-based visual effects in Unity. Using C# scripting and DOTween, we will:<br>
<br>Animate the Portal Ring VFX to pulse before the portal opens.
<br>Trigger the Energy Beam VFX after the portal closes.
<br>Align these effects with gameplay logic (enhancing game feel).
<br>By the end, students will understand how sequencing and timing-based VFX create stronger player anticipation and response.<br><img alt="portalBeamVFX.png" src="gmap-395\module-3\media\portalbeamvfx.png"><br><br><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_JLePfLQVEQnJr33w?e=dFmT9U" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_JLePfLQVEQnJr33w?e=dFmT9U" target="_blank">gmap395_wk7.mp4</a><br><br><br><br>‚úÖ Unity 2022.3 with URP and VFX Graph Installed<br>
‚úÖ Completion of Week 5‚Äôs "Game-Based Real-Time Shader Control w/ DOTween"<br>
‚úÖ Completion of Week 6‚Äôs "Enhancing the Eldritch Portal with VFX"<br>
‚úÖ Basic understanding of C# scripting, DOTween, and Unity Events<br>Unity VFX Scripting API
The scripts from todays class will be using Unity's <a data-tooltip-position="top" aria-label="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/VFX.VisualEffect.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/6000.0/Documentation/ScriptReference/VFX.VisualEffect.html" target="_blank">VFX Scripting API</a> for VFX graph. Particle System has a separate API.
<br><br><br>
VFX are not just visuals‚Äîthey are part of gameplay feedback.<br>
Players subconsciously react to anticipation and payoff sequences before major in-game events.
<br>In this case:<br>
<br>The portal doesn‚Äôt just "pop open," it builds anticipation with a pulsing particle ring.
<br>After the portal closes, the energy beam fires, creating a dramatic "release" effect.
<br>Why?

<br>Anticipation (Ring) = Builds tension before the event.
<br>Payoff (Beam) = Reinforces impact and finality after the event.


<br>This creates a stronger connection between VFX, game feel, and gameplay metaphor/mechanics.<br><br><br><br>In this section, we will create the PortalEffectsController from scratch.<br>
This script will control the portal ring effect, animating its exposed VFX properties from Week 6 using DOTween.<br>The Portal Ring Effect serves as an anticipatory visual cue before the portal opens.<br>
By animating its properties over time, we create a build-up sequence that enhances game feel.<br><br>In Week 6, we created a portal ring effect using Unity's VFX Graph.<br>
The following exposed properties were created in the VFX Graph Blackboard:<br><br>Animated Parameter
We will primarily focus on animating the Radius parameter with DOTween, but the same steps and principle apply for animating other properties.
<br><br>Now, let's create the PortalEffectsController script to control the Portal Ring Effect.<br><br>
<br>In Unity, go to the Project Window.
<br>Navigate to the Scripts folder (or create one if needed).
<br>Right-click &gt; Create &gt; C# Script and name it PortalEffectsController.
<br>Open the script in Visual Studio or VS Code.
<br><br>Replace the default code with the following:<br>using UnityEngine;
using UnityEngine.VFX;
using DG.Tweening;
using System.Collections;

public class PortalEffectsController : MonoBehaviour
{
    // Reference to the VFX Graph for the ring effect (assign in the Inspector)
    [SerializeField] private VisualEffect portalVFX;

    /// &lt;summary&gt;
    /// Plays the portal ring burst effect.
    /// Animates PortalRingRadius from 1.0 -&gt; 1.35 -&gt; 0.0, then stops the VFX.
    /// &lt;/summary
    public IEnumerator PlayPortalEffect()
    {
        if (portalVFX == null)
        {
            Debug.LogError("Portal VFX reference not set!");
            yield break;
        }

        // Set the starting value.
        portalVFX.SetFloat("PortalRingRadius", 1.0f);
        // Create a DOTween sequence to animate the ring.
        Sequence ringSequence = DOTween.Sequence();
        ringSequence.Append(
            DOTween.To(
                () =&gt; portalVFX.GetFloat("PortalRingRadius"),
                x =&gt; portalVFX.SetFloat("PortalRingRadius", x),
                1.35f,
                1f
            )
        );

        ringSequence.Append(
            DOTween.To(
                () =&gt; portalVFX.GetFloat("PortalRingRadius"),
                x =&gt; portalVFX.SetFloat("PortalRingRadius", x),
                0.0f,
                1f
            )
        );

        // When complete, stop the VFX.
        ringSequence.OnComplete(() =&gt; portalVFX.Stop());

        // Wait until the sequence is finished.
        yield return ringSequence.WaitForCompletion();

    }

    /// &lt;summary&gt;
    /// Restarts the portal ring effect (e.g. after the sequence finishes).
    /// &lt;/summary&gt;

    public void RestartRingEffect()
    {
        if (portalVFX != null)
        {
            // Reset initial values required for the portal ring effect.
            portalVFX.SetFloat("PortalRingRadius", 1.0f);
            // Restart the VFX.
            portalVFX.Play();
        }
    }

}
<br><br>
<br>Attach the Script to a GameObject

<br>In Unity, create an empty GameObject in the Hierarchy.
<br>Rename it "VFX Controller".
<br>Drag and attach the PortalEffectsController.cs script to this GameObject.


<br>Assign the VFX Graph

<br>Select the GameObject.
<br>In the Inspector, locate the Portal VFX field.
<br>Drag the Portal Ring VFX Graph from the Hierarchy into this field.


<br><br><br><br>In this section, we will implement the PortalBeamEffect script using the provided code.<br>
This script controls the portal beam effect, which fires after the portal closes as a visual payoff for the event.<br>The Beam Effect enhances game feel, reinforcing the impact of the portal cycle completion.<br>
By properly sequencing this after the portal closes, we strengthen player response and timing in gameplay.<br><br>The PortalBeamEffect script is set up to start and stop the Energy Beam Effect.<br><br>using UnityEngine;
using UnityEngine.VFX;
using System.Collections;

public class PortalBeamEffect : MonoBehaviour
{
    // Reference to the beam VFX Graph (assign in the Inspector)
    public VisualEffect beamVFX;
    // Duration for which the beam effect remains active.
    public float beamDuration = 2.0f;

    private void Start()
    {
        // Ensure the beam doesn't play automatically on scene start.
        if (beamVFX != null)
        {
            beamVFX.Stop();
        }
    }

    /// &lt;summary&gt;
    /// Plays the beam effect by starting the VFX, waits for the duration, then stops it.
    /// &lt;/summary&gt;
    public IEnumerator PlayBeamEffect()
    {
        if (beamVFX == null)
        {
            Debug.LogError("Beam VFX reference not set!");
            yield break;
        }
        
        beamVFX.Play();
        yield return new WaitForSeconds(beamDuration);
        beamVFX.Stop();
    }
}
<br><br>
<br>References the Beam VFX Graph (must be assigned in Unity).
<br>Ensures the beam does NOT play automatically on scene start.
<br>Provides a coroutine to play the beam, wait, then stop it.
<br><br>
<br>Attach the Script to a GameObject

<br>In Unity, in the Hierarchy, locate the GameObject from Part 1.
<br>Drag and attach the PortalBeamEffect.cs script to this GameObject.


<br>Assign the VFX Graph

<br>Select the GameObject.
<br>In the Inspector, locate the Beam VFX field.
<br>Drag the Energy Beam VFX Graph from the Hierarchy into this field.


<br><br><br><br>In this section, we will recreate the EnemySpawner script from its original version to match the intended tutorial sequence design.  Additionally, we will review and verify the PortalShaderController to ensure it functions correctly within this sequence.<br>The EnemySpawner is responsible for orchestrating the VFX timing, enemy spawning logic, and game feel elements. An argument could be made that the sequencing should be a separate script from enemy spawning logic, but I wanted to keep it a bit simpler for now.<br><br>Before we proceed with EnemySpawner, we need to verify that PortalShaderController is correct for the tutorial.<br><br>using UnityEngine;
using DG.Tweening; // Import DOTween

public class PortalShaderController : MonoBehaviour
{
    public Material portalMaterial;  // Assign the material in the Inspector
    private static readonly int EdgeWidthProperty = Shader.PropertyToID("_EdgeWidth");

    public float normalWidth = 0.2f;
    public float alertWidth = 0.6f;
    public float transitionDuration = 1.0f; // How long the animation takes

    void Start()
    {
        if (portalMaterial == null)
        {
            Debug.LogError("Portal material not assigned!");
            return;
        }

        // Ensure EdgeWidth starts at normal width
        portalMaterial.SetFloat(EdgeWidthProperty, normalWidth);
    }

    // Triggered when an enemy is about to spawn
    public void ActivateAlert()
    {
        Debug.Log("Portal activating.");
        
        // DOTween smoothly changes EdgeWidth over time
        portalMaterial.DOFloat(alertWidth, EdgeWidthProperty, transitionDuration)
            .SetEase(Ease.InOutQuad);
    }

    // Reset the effect after a delay
    public void DeactivateAlert()
    {
        Debug.Log("Portal deactivating.");
        
        // DOTween smoothly returns EdgeWidth to normal
        portalMaterial.DOFloat(normalWidth, EdgeWidthProperty, transitionDuration)
            .SetEase(Ease.InOutQuad);
    }
}
<br><br>‚úîÔ∏è Uses DOTween to animate the shader property _EdgeWidth, expanding when activated and resetting when closed.<br>
‚úîÔ∏è The ActivateAlert() function properly transitions the effect when the portal is "opening."<br>
‚úîÔ∏è The DeactivateAlert() function ensures it returns to normal after closing.<br>
‚úîÔ∏è The transitionDuration parameter can be adjusted to fine-tune timing.<br>No modifications should be needed. The PortalShaderController functions correctly for the purposes of our tutorial. It is jus a good habit to check code you will be referencing/interacting with in the editor.<br><br>Now, we will REBUILD the EnemySpawner script from its original version, incorporating the full game feel sequence.<br><br>
<br>In Unity, go to the Project Window.
<br>Navigate to the Scripts folder (or create one if needed).
<br>Right-click &gt; Create &gt; C# Script and name it EnemySpawner (or open the original script if you have one).
<br>Open the script in your IDE.
<br><br>Replace the code with the following:<br>using UnityEngine;
using System.Collections;
using DG.Tweening;

public class EnemySpawner : MonoBehaviour
{
    [Header("Portal Settings")]
    public PortalEffectsController portalEffects; // Controls the ring effect
    public PortalShaderController portalShader;   // Controls the shader opening/closing
    public PortalBeamEffect portalBeamEffect;     // Controls the beam effect

    [Tooltip("Delay after shader opens before spawning the enemy.")]
    public float enemyInstantiationDelay = 1.0f; 

    [Tooltip("Delay after beam effect stops before restarting the portal ring effect.")]
    public float ringRestartDelay = 0.5f;

    [Header("Enemy Settings")]
    public GameObject enemyPrefab;         // Enemy prefab to spawn
    public Transform releasePoint;         // Target position on the ground
    public float dropDuration = 3f;        // Duration of the enemy falling

    void Update()
    {
        // For testing: trigger the full sequence with the Space key.
        if (Input.GetKeyDown(KeyCode.Space))
        {
            StartCoroutine(TriggerFullSequence());
        }
    }

    IEnumerator TriggerFullSequence()
    {
        Debug.Log("Starting enemy spawn sequence...");

        // --- STEP 1: Portal Ring Effect (Anticipation) ---
        yield return portalEffects.PlayPortalEffect();

        // --- STEP 2: Portal Shader Opens (Portal Begins to Activate) ---
        portalShader.ActivateAlert();
        yield return new WaitForSeconds(portalShader.transitionDuration);

        // --- STEP 3: Enemy Spawning (Gameplay Event) ---
        yield return new WaitForSeconds(enemyInstantiationDelay);
        GameObject enemyInstance = Instantiate(enemyPrefab, transform.position, Quaternion.identity);
        enemyInstance.transform.DOMove(releasePoint.position, dropDuration)
            .SetEase(Ease.Linear)
            .OnComplete(() =&gt;
            {
                // Unparent the enemy so it moves freely in the scene
                enemyInstance.transform.parent = null;
            });
        yield return new WaitForSeconds(dropDuration);

        // --- STEP 4: Portal Shader Closes (Portal Powers Down) ---
        portalShader.DeactivateAlert();
        yield return new WaitForSeconds(portalShader.transitionDuration);

        // --- STEP 5: Portal Beam Effect (Powerful Release) ---
        yield return StartCoroutine(portalBeamEffect.PlayBeamEffect());

        // --- STEP 6: Restart Portal Ring Effect (Loop Back to Idle State) ---
        yield return new WaitForSeconds(ringRestartDelay);
        portalEffects.RestartRingEffect();

        Debug.Log("Enemy spawn sequence complete.");
    }
}
<br><br>The updated script ensures proper sequencing and game feel through timing considerations:<br><br><br>‚úÖ Now, the entire sequence works as a fully structured event.<br><br>
<br>Click Play in Unity.
<br>Press Space to trigger the full sequence.
<br>Observe the correct ordering of effects:

<br>Portal Ring pulses
<br>Portal Shader expands
<br>Enemy spawns
<br>Portal Shader closes
<br>Energy Beam fires
<br>Portal Ring resets


<br>Adjust timing variables in the Inspector to fine-tune the pacing.
<br><br><br>The tutorial is now complete! üéâ<br>
The full portal cycle now functions as an engaging game-based metaphor!<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 3" data-href="GMAP 395 - Module 3" href="gmap-395\module-3\gmap-395-module-3.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-3\gmap-395-wk-7-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 3/GMAP 395 - WK 7 - Tutorial.md</guid><pubDate>Mon, 17 Feb 2025 23:09:37 GMT</pubDate><enclosure url="gmap-395\module-3\media\portalbeamvfx.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-3\media\portalbeamvfx.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[media]]></title><description><![CDATA[ 
 ]]></description><link>gmap-395\module-4\media\media.html</link><guid isPermaLink="false">GMAP 395/Module 4/media/media.md</guid><pubDate>Sun, 02 Mar 2025 20:42:02 GMT</pubDate></item><item><title><![CDATA[Assignment 4: Cinemachine and Post-Processing Integration]]></title><description><![CDATA[ 
 <br><br><br>Assignment Overview  
In this final module assignment, students will:

<br>Integrate at least two (2) post-processing effects into their project using Unity's URP Post-Processing system.
<br>Control one post-processing effect dynamically through C# scripting (such as adjusting bloom intensity, vignette strength, or depth of field focus).
<br>Implement Cinemachine to create dynamic camera movements and transitions.
<br>Present their work within their ongoing project scene and document the process in a README file.

<br><br><br>Assignment Breakdown

<br>Part 1: Post-Processing Effects

<br>Apply a minimum of two (2) post-processing effects (examples: Bloom, Depth of Field, Color Adjustments, Vignette, Chromatic Aberration).
<br>Ensure these effects contribute to the overall atmosphere and mood of your environment.


<br>Part 2: Scripted Post-Processing Control

<br>Write a C# script to dynamically adjust at least one of your post-processing parameters during runtime (e.g., change vignette intensity when the player approaches the artifact).


<br>Part 3: Cinemachine Camera System

<br>Use Cinemachine to set up dynamic camera(s).
<br>Essentially, install cinemachine and setup in your project to apply camera position.



<br><br><br>What to Submit
1.README File (Markdown or TXT) that explains:<br>
- Which post-processing effects you used and why.<br>
- How your C# script controls a post-processing effect in real-time.<br>
- How Cinemachine is used in your scene.<br>
- Any challenges you faced and how you resolved them.<br>
2. Recorded Video (5‚Äì10 Minutes):<br>
- Screen-record your scene.<br>
- Walk through the post-processing effects, scripted control, and Cinemachine setup.<br>
- Reflect on how these elements contribute to the overall polish of your environment.
<br><br><br># Assignment 4: Cinemachine and Post-Processing Integration

## Post-Processing Effects
- Bloom: Applied to enhance artifact glow.
- Depth of Field: Used to focus attention on the artifact when nearby.
- Vignette: Added subtle dark edges for atmospheric tension.

## Scripted Control
- I created a script that increases vignette intensity as the player gets closer to the artifact, creating a sense of pressure and immersion.

## Cinemachine Setup
- I implemented a free-look camera that orbits around the artifact.
- Added a triggered dolly camera that activates during a key interaction.

## Challenges
- Ensuring smooth transitions between Cinemachine cameras.
- Managing post-processing volume blending across different zones.
<br><br>Submission Guidelines

<br>Submission Format: ZIP file uploaded to Drexel Learn.
<br>File Naming: abc123_Lastname_Firstname_A4.zip.
<br>Late submissions will incur a 10% penalty per day.

<br><br><br>By completing this assignment, you will:

<br>Understand how to implement and customize post-processing effects.
<br>Gain experience scripting real-time control over visual effects.
<br>Design and refine camera systems with Cinemachine.
<br>Polish your procedural game environment with cinematic and atmospheric enhancements.

<br><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Module 4" data-href="GMAP 395 - Module 4" href="gmap-395\module-4\gmap-395-module-4.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-4\gmap-395-asn-4-brief.html</link><guid isPermaLink="false">GMAP 395/Module 4/GMAP 395 - ASN 4 - Brief.md</guid><pubDate>Tue, 04 Mar 2025 01:01:23 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - Guides - Custom Post-Processing Effects]]></title><description><![CDATA[ 
 <br><br><br><br>]]></description><link>gmap-395\module-4\gmap-395-guides-custom-post-processing-effects.html</link><guid isPermaLink="false">GMAP 395/Module 4/GMAP 395 - Guides - Custom Post-Processing Effects.md</guid><pubDate>Mon, 03 Mar 2025 20:03:45 GMT</pubDate></item><item><title><![CDATA[In-Class Lab: Introduction to Cinemachine in Unity URP]]></title><description><![CDATA[ 
 <br><br><br>This lab aims to guide you through setting up Cinemachine in Unity's Universal Render Pipeline (URP), understanding its core components, and implementing dynamic camera controls<br><br>
<br>Unity 2022.3 LTS or late 
<br>Basic familiarity with the Unity interface
<br><br><br><br>
<br>Open Unity Hub: Launch the Unity Hub application
<br>Create a New Project: Click on the "New Project" button
<br>Select URP Template: Choose the "3D (URP)" template
<br>Name and Location: Enter a project name (e.g., "CinemachineIntro") 

<br>Select a location to save the project


<br>Create: - Click "Create Project"
<br><br><br><br>
<br>Access Package Manager: 

<br>In Unity, navigate to Window &gt; Package Manager


<br><br>
<br>Find Cinemachine: 

<br>In the Package Manager, ensure "Unity Registry" is selected in the dropdown 
<br>Scroll to locate "Cinemachine" or use the search bar


<br>Install:

<br>Select "Cinemachine" and click the "Install" button


<br><br><br><br>Cinemachine is a powerful Unity package that simplifies camera control, allowing for dynamic and complex camera behaviors without extensive coding<br><br>
<br>Cinemachine Brain:

<br>Function: Acts as the link between Unity's main camera and Cinemachine's virtual cameras. It interprets and blends the instructions from virtual cameras to control the main camera's behavior
<br>Usage: Attached to the Main Camera


<br>Cinemachine Virtual Camera:

<br>Function: Defines specific camera behaviors, such as position, rotation, and follow targets. Unlike the main camera, virtual cameras don't render scenes but provide instructions to the Cinemachine Brain
<br>Usage: Multiple virtual cameras can be created to achieve various cinematic effects, like cutscenes or dynamic following


<br><br><br><br>
<br>Select Main Camera: In the Hierarchy window, click on the "Main Camera"
<br>Add Cinemachine Brain: In the Inspector window, click "Add Component" - Search for "Cinemachine Brain" and select it
<br>Note: If you star by just creating a Virtual Camera (Right-Click -&gt; Cinemachine -&gt; Virtual Camera) a brain will automatically be added to the scene Main Camera.<br><br>
<br>Add Virtual Camera: In the Menu Bar, navigate to Cinemachine &gt; Create Virtual Camera
<br>Configure Virtual Camera: A new GameObject named "Virtual Camera" appears in the Hierarchy 

<br>Select it
<br>In the Inspector window, you'll see the CinemachineVirtualCamera component


<br><br><br><br>
<br>Create a Target Object:

<br>In the Hierarchy, create a Cube (Right- click &gt; 3D Object &gt; Cube)
<br>Position it at (0, 0.5, 0)


<br><br>
<br>Assign Follow and Look At Targets: 

<br>Select your "Virtual Camera" 
<br>In the Inspector, set the "Follow" and "Look At" fields to the Cube (drag the Cube from the Hierarchy to these fields)


<br>Adjust Camera Settings: 
<br>Modify the "Lens" settings, such as Field of View, to achieve the desired framing 

<br>Under "Aim", explore options like Composer to fine-tune how the camera tracks the target


<br><br><br>
<br>Play the Scene:

<br>Click the "Play" button to enter Play Mode
<br>Observe how the virtual camera follows and looks at the Cube


<br>Move the Target:
<br>While in Play Mode, select the Cube and move it around (or create a script to animate it)

<br>Notice how the camera dynamically adjusts to keep the Cube in view


<br><br><br>Cinemachine allows seamless transitions between multiple virtual cameras, enabling dynamic and cinematic camera movements in your scene.<br><br>
<br>Add a Second Virtual Camera:

<br>Navigate to Cinemachine &gt; Create Virtual Camera.
<br>A new GameObject named "Virtual Camera (1)" will appear in the Hierarchy.


<br>Configure the Second Virtual Camera:

<br>Select "Virtual Camera (1)".
<br>In the Inspector, set the "Follow" and "Look At" fields to a different target or adjust its Transform to a new position.
<br>For example, create another Cube at a different location and assign it as the target.


<br><br>Cinemachine manages transitions between virtual cameras based on their Priority and Activation.<br>
<br>Set Camera Priorities:

<br>Each virtual camera has a Priority property. The camera with the highest priority becomes active.
<br>To switch cameras, adjust their priorities accordingly.


<br>Activate/Deactivate Cameras via Script:<br>
-  You can enable or disable virtual cameras through C# scripts to control transitions.<br>
-  For example, to switch to "Virtual Camera (1)" when pressing a number key:
```csharp

using UnityEngine;<br>
using Cinemachine;
<br>public class CameraSwitcher : MonoBehaviour<br>
{<br>
public CinemachineVirtualCamera vcam1;<br>
public CinemachineVirtualCamera vcam2;<br>&nbsp; &nbsp; void Start()<br>
{<br>
ActivateCamera(vcam1); // Start with vcam1 active by default<br>
}<br>&nbsp; &nbsp; void Update()<br>
{<br>
if (Input.GetKeyDown(KeyCode.Alpha1))<br>
{<br>
ActivateCamera(vcam1);<br>
}<br>&nbsp; &nbsp; &nbsp; &nbsp; if (Input.GetKeyDown(KeyCode.Alpha2))<br>
{<br>
ActivateCamera(vcam2);<br>
}<br>
}<br>&nbsp; &nbsp; void ActivateCamera(CinemachineVirtualCamera activeCam)<br>
{<br>
vcam1.gameObject.SetActive(activeCam == vcam1);<br>
vcam2.gameObject.SetActive(activeCam == vcam2);<br>
}<br>
}<br>
```<br>-  Attach this script to an empty GameObject and assign **Virtual Camera1** and **Virtual Camera2** in the **Inspector**.
<br><br>
<br>Press 1 ‚Üí activates Virtual Camera1.
<br>Press 2 ‚Üí activates Virtual Camera2.
<br>Deactivates the other camera automatically.
<br>Starts with Virtual Camera1 active by default in Start().
<br>
<br>Customize Transition Blends:

<br>Cinemachine allows customization of the blending between cameras.
<br>Select the Main Camera and, in the Cinemachine Brain component, adjust the Default Blend settings to control the transition style and duration.


<br><br><br>Cinemachine offers advanced functionalities to enhance camera behavior.<br><br>
<br>Add Noise to a Virtual Camera:

<br>Select a virtual camera (e.g., "Virtual Camera").
<br>In the Inspector, expand the "Noise" section.
<br>Choose a Noise Profile (e.g., Basic Multi Perlin) to add procedural camera shake.


<br>Adjust Noise Parameters:

<br>Modify the Amplitude Gain and Frequency Gain to control the intensity and speed of the shake effect.


<br><br><br>
<br>Play the Scene:

<br>Click the "Play" button to enter Play Mode.
<br>Interact with your scene and observe the camera behaviors, transitions, and effects implemented.


<br>Refine Camera Settings:

<br>Based on the playtest, tweak virtual camera settings, noise profiles, and transition blends to achieve the desired cinematic experience.


<br>Info
By following this comprehensive tutorial, you've learned how to set up and utilize Cinemachine in Unity to create dynamic and professional camera systems for your projects.
<br>For a visual walkthrough and more advanced techniques, consider watching the following tutorial:<br><br>Video: How to use Cameras in Unity: Cinemachine Virtual Cameras<br><br><br><br><br>This lab aims to introduce you to post- processing in Unity's Universal Render Pipeline (URP), enabling you to enhance your game's visual quality by applying various effects<br><br>URP integrates post- processing effects using the Volume framework. Follow these steps to set it up<br><br>
<br>Select the Main Camera:

<br>In the Hierarchy, click on "Main Camera"


<br>Enable Post- Processing:<br>
2. In the Inspector under Rendering, check the Post Processing box
<br><br>
<br>Add a Global Volume: 

<br>In the Hierarchy, right- click and select Volume &gt; Global Volume


<br>Create a Volume Profile:<br>
2. With the Global Volume selected, click "Add Component" in the Inspector<br>
3. Choose "Volume" - Click "New" next to the Profile field to create a new Volume Profile
<br><br><br>Now that the Volume is set up, let's add some common post- processing effects<br><br>
<br>Add Bloom: 

<br>In the Inspector of the Global Volume, click "Add Override"
<br>Select "Post- processing" &gt; "Bloom"


<br>Configure Bloom: 

<br>Enable the Intensity property by checking its box and set it to 0.5 
<br>Adjust the Threshold to control the brightness level at which Bloom starts


<br><br>
<br>Add Vignette: 

<br>Click "Add Override" again 
<br>Select "Post- processing" &gt; "Vignette"


<br>Configure Vignette: 

<br>Enable the Intensity property and set it to 0.3
<br>Adjust the Smoothness to 0.5 for a subtle darkening around the edges


<br><br>
<br>Add Color Adjustments: 

<br>Click "Add Override" 
<br>Select "Post- processing" &gt; "Color Adjustments"


<br>Configure Color Adjustments: 

<br>Enable the Post Exposure property and set it to 0.5 to brighten the scene 
<br>Adjust the Contrast to 10 for more depth 
<br>Modify the Saturation to - 10 for a slight desaturation effect


<br><br><br>After adding these effects, you should notice changes in your scene<br>
<br>
Bloom: Bright areas emit a soft glow

<br>
Vignette: Edges of the screen are subtly darkened, focusing attention toward the center

<br>
Color Adjustments: Overall brightness, contrast, and color saturation are modified To see the effects in action

<br>
Ensure you're in Scene or Game view 

<br>If effects aren't visible in the Scene view, click the "Gizmos" dropdown and ensure "Post- Processing" is enabled
<br>Also ensure it is enabled on the Main Camera and in the URP Settings Asset


<br><br><br>Feel free to explore other post- processing effects<br>
<br>
Depth of Field: Blurs objects based on their distance from the camera

<br>
Film Grain: Adds a cinematic grainy texture

<br>
Lens Distortion: Simulates lens imperfections for creative effects To add these

<br>
Click "Add Override" in the Global Volume - Select the desired effect

]]></description><link>gmap-395\module-4\gmap-395-in-class-lab.html</link><guid isPermaLink="false">GMAP 395/Module 4/GMAP 395 - In-Class Lab.md</guid><pubDate>Sun, 02 Mar 2025 21:12:12 GMT</pubDate></item><item><title><![CDATA[Module 4 ‚Äì Camera Effects and Post-Processing]]></title><description><![CDATA[ 
 <br><br><br>In this module, you'll learn how to enhance your game environments using advanced camera systems and post-processing techniques. These tools allow you to craft cinematic experiences, dynamic gameplay feedback, and a polished visual style that responds to player actions.<br><br><br>
<br>Full-Screen Effects and Post-Processing:

<br>Bloom, depth of field, color grading, vignette, and more using Unity‚Äôs Post-Processing stack.
<br>Creating mood and atmosphere through visual filtering.


<br>Modular Camera Systems:

<br>Cinemachine for dynamic, reusable camera rigs.
<br>Triggered camera transitions and guided player focus.


<br>Camera Effects and Real-Time Feedback:

<br>Screen shake, zooms, and motion blur tied to gameplay events.
<br>Using camera motion and effects to reinforce player actions.


<br><br><br>By the end of this module, you will:<br>
<br>Implement a modular camera system using Cinemachine.
<br>Apply post-processing profiles to enhance scene visuals.
<br>Trigger real-time camera effects based on player interactions.
<br>Understand the connection between camera design and player experience.
<br><br><br>
<br>Ensure your Unity project is using the Universal Render Pipeline (URP).
<br>Install Cinemachine via the Unity Package Manager.
<br>Review your previous modules to integrate existing assets and shaders into a cohesive scene.
<br>If you‚Äôve never used Cinemachine:
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=P_ibDJhFVMU" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=P_ibDJhFVMU" target="_blank">Cinemachine in Action</a>
<br><br><br>
<br>Unity 2022.3 or higher (URP setup).
<br>Cinemachine for camera systems.
<br>Post-Processing stack (integrated into URP).
<br><br><br><br>
<br>Implement post-processing to polish your procedural artifact scene.
<br>Create a dynamic camera system that responds to player proximity and movement.
<br>Apply real-time feedback effects such as camera shake or focus shifts.
<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/6000.0/Documentation/Manual/urp/integration-with-post-processing.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/6000.0/Documentation/Manual/urp/integration-with-post-processing.html" target="_blank">Unity Post-Processing Documentation</a>
<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.cinemachine@3.1/manual/index.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.cinemachine@3.1/manual/index.html" target="_blank">Unity Cinemachine Documentation</a>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/project/creative-core-post-processing" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/project/creative-core-post-processing" target="_blank">How to Use Post-Processing in URP</a>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/tutorial/cinemachine-cameras-2018#" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/tutorial/cinemachine-cameras-2018#" target="_blank">How to Use Camera in Unity</a>
<br><br><br>
<br>A cinematic zoom when the player approaches your artifact.
<br>A post-processing profile that shifts the mood of your scene from day to night.
<br>A camera shake effect when interacting with your procedural object.
<br><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\module-4\gmap-395-module-4.html</link><guid isPermaLink="false">GMAP 395/Module 4/GMAP 395 - Module 4.md</guid><pubDate>Sun, 02 Mar 2025 17:17:07 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - Advanced Game art and Production]]></title><description><![CDATA[ 
 <br><br><br><br><br><br>
<br>We've already covered Lighting in depth.
<br>This presentation focuses on:

<br>Post-processing
<br>Full-screen shader effects
<br>Camera behaviors and interactions


<br><br><br>
<br>Enhance atmosphere and mood
<br>Refine visual storytelling
<br>Create player focus through lenses, effects, and transitions
<br>Optimize and stylize your scenes
<br><br><br>
<br>Lighting sets mood and clarity
<br>Guides players and reinforces theme
<br>Direct interaction with post-processing and camera effects
<br><br><br>
<br>Post-processing filters amplify lighting setups

<br>Bloom enhances emissive
<br>Color grading adjusts overall tone
<br>Vignette focuses attention


<br><br><br>
<br>Combine dynamic lighting with shaders:

<br>Day/Night Cycles
<br>Color Shifts
<br>Fog and Atmospherics


<br><br><br><br><br>
<br>Visual effects applied after rendering
<br>Runs over the full screen, like photo filters in real-time
<br>Handles mood, style, and polish
<br><br><br><br>
<br>Bloom
<br>Color Grading
<br>Vignette
<br>Depth of Field
<br>Motion Blur
<br>Chromatic Aberration
<br><br><br><br>
<br>Create a Global Volume
<br>Assign a Post-Processing Profile
<br>Add overrides (Bloom, Vignette, etc.)
<br>Enable post-processing on the camera
<br><br><br>
<br>Bloom + Emissives = Glow
<br>Vignette = Cinematic framing
<br>Color Adjustments = Visual mood shifts
<br><img alt="home-before.png" src="gmap-395\module-4\media\home-before.png" style="width: 720px; max-width: 100%;"><br>
<img alt="home-after.png" src="gmap-395\module-4\media\home-after.png" style="width: 720px; max-width: 100%;"><br><br><br>
<br>Subtlety &gt; Overload
<br>Profile performance costs
<br>Stack effects logically (Color Grading ‚Üí Bloom ‚Üí Vignette)
<br><br><br>
<br>Implement correct "using statements"
<br>Reference the Volume and the Override needed for control
<br>using UnityEngine.Rendering;  
using UnityEngine.Rendering.Universal;  
  
public class VignetteController : MonoBehaviour  
{  
    public Volume postProcessVolume;  
    private Vignette vignette;
}
<br><br><br><br><br>
<br>Shaders that modify the entire frame
<br>Applied through a render pass or post-process pipeline
<br>Example uses:

<br>Pixelation
<br>Screen distortion
<br>Color filters


<br><br><br>
<br>Custom artistic control
<br>Real-time dynamic adjustments
<br>Performance-efficient stylization
<br><br><br>
<br>UV manipulation
<br>Noise overlays
<br>Color blending
<br>Depth-based effects
<br><br><br>
<br>Use DOTween or C# to change shader parameters
<br>Example: Expand portal effect on enemy spawn
<br>Sync shader animations with player actions
<br><br><br>
<br>Swirls, ripples, and patterns
<br>Masking and blending
<br>Dynamic reactions to game state
<br><br><br><br><br>
<br>Player perspective = player experience
<br>Cinematic movement builds immersion
<br>Connects gameplay to visual storytelling
<br><br><br><br>
<br>Follow Cameras
<br>Dolly Tracks
<br>Target Groups
<br>Blend Transitions
<br><img alt="capsule_616x353.jpg" src="gmap-395\module-4\media\capsule_616x353.jpg"><br><br><br>
<br>Shake on impact
<br>Zoom on focus
<br>Rotate for drama
<br>Depth of Field on object proximity
<br><img alt="421988f6-a827-428b-86d4-9b815f15cdce.jpg" src="gmap-395\module-4\media\421988f6-a827-428b-86d4-9b815f15cdce.jpg" style="width: 720px; max-width: 100%;"><br><br><br>
<br>Match camera behavior with post-process states
<br>Example:

<br>Zoom ‚Üí Increase Depth of Field
<br>Rotate ‚Üí Add Motion Blur


<br><br><br>
<br>Trigger shaders during camera moves
<br>Layer transitions and fade-ins
<br>Match action with visual flow
<br><br><br><br>Layer multiple cameras together, with cameras that focus on specific layers or objects in a scene.<br><br><br><br><br><br>
<br>Procedural asset with dynamic shader
<br>Lighting supports mood
<br>Post-processing adds polish
<br>Camera movements guide focus
<br><br><br>
<br>How can you combine these systems?
<br>Where can shaders and post-processing amplify your procedural assets?
<br>How does the camera‚Äôs perspective shape the player‚Äôs experience?
<br><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Module 4" data-href="GMAP 395 - Module 4" href="gmap-395\module-4\gmap-395-module-4.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-4\gmap-395-wk-9-slides-+-video.html</link><guid isPermaLink="false">GMAP 395/Module 4/GMAP 395 - WK 9 - Slides + Video.md</guid><pubDate>Mon, 03 Mar 2025 22:55:29 GMT</pubDate><enclosure url="gmap-395\module-4\media\home-before.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-4\media\home-before.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 9 Tutorial]]></title><description><![CDATA[ 
 <br><br><br><img alt="tutWk9Splash.png" src="gmap-395\module-4\media\tutwk9splash.png"><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_NKaj-oxfZpUrjR7Q?e=4frRJP" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_NKaj-oxfZpUrjR7Q?e=4frRJP" target="_blank">gmap395_wk9.mp4</a><br><br><br><br>In this tutorial, we will add two key interactive systems to our enemy spawn sequence:<br>
<br>A Post-Processing Vignette Effect that uses DOTween to pulse the screen green, reinforcing the anticipation of enemy arrival.
<br>A Cinemachine Zoom Control, allowing the player to zoom in with a button press to get a closer look at the action.
<br>Scripting APIs for this Tutroial
<a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/Volumes.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.universal@7.1/manual/Volumes.html" target="_blank">Unity Doc on Volumes</a><br>
<a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@12.0/manual/Volumes-API.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.render-pipelines.high-definition@12.0/manual/Volumes-API.html" target="_blank">Editing Volumes at Runtime</a><br>
<a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/index.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.3/manual/index.html" target="_blank">Unity Doc on Cinemachine</a><br>
<a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/api/Cinemachine.CinemachineVirtualCamera.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.cinemachine@2.1/api/Cinemachine.CinemachineVirtualCamera.html" target="_blank">CinemachineVirtualCamera Class</a>
<br><br>Design Reasoning: Visual feedback and real-time control are critical parts to guiding the player's emotions and attention. A subtle green vignette can signal danger and build tension, while player-controlled zoom provides agency, allowing players to focus on dramatic events like an enemy spawning.<br><br><br>
<br>Unity 2022.3 LTS with URP
<br>DOTween installed and set up
<br>Cinemachine installed
<br>Completion of the Week 7 sequence (Portal, Shader, EnemySpawner, etc.)
<br><br><br><br>Post-processing effects are a final layer of polish that add emotional weight.<br>
For example:<br>
<br>Vignette = Focus and tension
<br>Green Tint = Danger, sickness, or otherworldly energy
<br><br>Pulse a green vignette during the enemy spawn sequence.<br><br><br>
<br>Locate your Global Volume in the Hierarchy.
<br>In the Inspector, find the attached Volume Profile.
<br>Click Add Override ‚Üí Post-processing ‚Üí Vignette.
<br>Enable these settings:

<br>Color: Black (for now)
<br>Intensity: 0.3
<br>Smoothness: 0.5


<br>üìù Design Note:<br>
We start subtle so the change to green is noticeable and feels meaningful during the event.<br><br><br>
Scripts (Folder) ‚Üí Create ‚Üí C# Script ‚Üí Name it VignetteController
<br>Paste this code:<br>using UnityEngine;
using DG.Tweening;
using UnityEngine.Rendering;
using UnityEngine.Rendering.Universal;

public class VignetteController : MonoBehaviour
{
    public Volume postProcessVolume;
    private Vignette vignette;

    public Color normalColor = Color.black;
    public Color alertColor = Color.green;
    public float alertIntensity = 0.6f;
    public float transitionDuration = 1.0f;

    void Start()
    {
        postProcessVolume.profile.TryGet(out vignette);
        vignette.color.value = normalColor;
        vignette.intensity.value = 0.3f;
    }

	public void ActivateAlert()
	{
	    DOTween.To(() =&gt; vignette.color.value, x =&gt; vignette.color.value = x, alertColor, transitionDuration);
	    DOTween.To(() =&gt; vignette.intensity.value, x =&gt; vignette.intensity.value = x, alertIntensity, transitionDuration);
	}

	public void DeactivateAlert()
	{
	    DOTween.To(() =&gt; vignette.color.value, x =&gt; vignette.color.value = x, normalColor, transitionDuration);
	    DOTween.To(() =&gt; vignette.intensity.value, x =&gt; vignette.intensity.value = x, 0.3f, transitionDuration);
	}

}
<br><br><br>
<br>Create an empty GameObject in the Hierarchy ‚Üí Name it VignetteController.
<br>Add the VignetteController.cs script.
<br>Drag the Global Volume into the Post Process Volume field.
<br><br><br>
<br>In EnemySpawner.cs, (at the top with the other variables) add:
<br>public VignetteController vignetteController;
<br>
<br>Before the portal ring effect starts, activate the vignette (inside TriggerFullSequence()):
<br>vignetteController.ActivateAlert();
<br>
<br>After the enemy has spawned and the sequence ends, reset it  (inside TriggerFullSequence()):
<br>vignetteController.DeactivateAlert();
<br>üìù Design Note:<br>
Players need signals when big events happen. This pulse grabs attention without needing UI text.<br><br><br>
<br>One all scripts have been made/modified.
<br>Ensure that the Vignette Controller game object is created as has the VingetteController.cs attached.
<br>Ensure the EnemySpawner.cs has the Vignette Controller game object assigned.
<br>Play the scene and activate the sequence with the assigned key press.

<br>You should now see the edges of teh screen skrink in and turn green.
<br>Note: if your scene has little light, the effect will not be as noticeable, as Vignette uses alpha transparency. 


<br><br>By adding one private variable and updating the ActivateAlert() and DeactivareAlert() methods to use DOTween sequencing, we can have the vignete color or intensity pusle while the alert is active.<br>private Tween pulseTween; //add this new variable

public void ActivateAlert() //update this function call
{
    // Transition to the alert color
    DOTween.To(() =&gt; vignette.color.value, x =&gt; vignette.color.value = x, alertColor, transitionDuration);

    // Start pulsing the intensity
    pulseTween = DOTween.To(() =&gt; vignette.intensity.value, x =&gt; vignette.intensity.value = x, alertIntensity, transitionDuration)
        .SetLoops(-1, LoopType.Yoyo)
        .SetEase(Ease.InOutSine);
}

public void DeactivateAlert() //update this function call
{
    // Stop pulsing
    if (pulseTween != null)
    {
        pulseTween.Kill();
    }

    // Reset to normal color and intensity
    DOTween.To(() =&gt; vignette.color.value, x =&gt; vignette.color.value = x, normalColor, transitionDuration);
    DOTween.To(() =&gt; vignette.intensity.value, x =&gt; vignette.intensity.value = x, 0.3f, transitionDuration);
}

<br>
<br>Make the above code changes and play the scene again. You should now see the effect pulse.
<br><br><br><br><br>Zoom gives the player agency to focus on something important. It's also a dramatic tool‚Äîgetting close to the action increases intensity and makes the experience feel more "personal."<br><br><br>
<br>Go to Package Manager ‚Üí Cinemachine (install if not done).
<br>In the Hierarchy, Cinemachine ‚Üí Create Virtual Camera.
<br>Set the Virtual Camera‚Äôs Field of View (FOV) to 60.
<br><br><br>Note: The following steps will reset the transform of the Main Camera. So take note of its transforms!<br>
<br>Right-Click in the Hierarchy --&gt; Cinemachine --&gt; Virtual Camera.
<br>You will now a Virtua Camera in the scene and your Main Camera will have a Cinemachine Brain attached to it.

<br>Note: Changing the Main Cameras transforms will do nothing. The Virtual Camera not controls the Main Camera.


<br>In the Virtual Camera, set Transition -&gt; Body to Do Nothing.
<br>In the Virtual Camera, set Aim to POV.
<br>To reposition your camera, use the Virtual Camera -&gt; Transform -&gt; Position to move it. 
<br>To rotate use the Virtual Camera -&gt; Aim -&gt; Vertical Axis Value) and Horizontal Axis (Value).
<br>Reposition your camera to a desired location.
<br><br><br>
Scripts ‚Üí Create ‚Üí C# Script ‚Üí Name it CameraZoomController
<br>Paste this code:<br>using UnityEngine;
using DG.Tweening;
using Cinemachine;

public class CameraZoomController : MonoBehaviour
{
    public CinemachineVirtualCamera virtualCamera;
    public float normalFOV = 60f;
    public float zoomedFOV = 30f;
    public float zoomDuration = 0.5f;

    private bool isZoomed = false;

    void Update()
    {
        if (Input.GetKeyDown(KeyCode.Z))
        {
            ToggleZoom();
        }
    }

	void ToggleZoom()
	{
	    float targetFOV = isZoomed ? normalFOV : zoomedFOV;
	    DOTween.To(
	        () =&gt; virtualCamera.m_Lens.FieldOfView,
	        x =&gt; {
	            var lens = virtualCamera.m_Lens;
	            lens.FieldOfView = x;
	            virtualCamera.m_Lens = lens;
	        },
	        targetFOV,
	        zoomDuration
	    );
	    isZoomed = !isZoomed;
	}

}
<br><br><br>
<br>Create an empty GameObject ‚Üí Name it CameraController.
<br>Add the CameraZoomController.cs script.
<br>Drag your Virtual Camera into the script‚Äôs Virtual Camera field.
<br><br><br>‚úÖ Press Z to zoom in/out during gameplay.<br>
‚úÖ Trigger the enemy sequence and see how zoom + vignette work together.<br><br><br>If you would like to have the ability to click into the game window and remove the cursor (or called playing in focus) add the following code to CameraZoomController.cs.<br>	private bool cursorLocked = true;
	
	void Start()
	{
	    LockCursor();
	}
	
	void Update()
	{
	    if (Input.GetKeyDown(KeyCode.Z))
	    {
	        ToggleZoom();
	    }
	    if (Input.GetKeyDown(KeyCode.Escape))
	    {
	        UnlockCursor();
	    }
	    // Click to re-lock when unlocked
	    if (!cursorLocked &amp;&amp; Input.GetMouseButtonDown(0))
	    {
	        LockCursor();
	    }
	}
	
	void LockCursor()
	{
	    Cursor.lockState = CursorLockMode.Locked;
	    Cursor.visible = false;
	    cursorLocked = true;
	}
	
	void UnlockCursor()
	{
	    Cursor.lockState = CursorLockMode.None;
	    Cursor.visible = true;
	    cursorLocked = false;
	}
<br><br>
<br>Press Escape ‚Üí unlocks cursor, makes it visible.
<br>Click anywhere (left mouse click) ‚Üí re-locks cursor.
<br>Keeps track of whether the cursor is locked with the cursorLocked flag so it doesn't keep trying to lock it when it's already locked.
<br>Works in Play Mode and builds.
<br><br><br>
<br>The vignette builds subconscious tension‚Äîdanger is coming!
<br>The zoom gives the player control to witness the danger up close.
<br>Together, they turn a simple spawn event into a cinematic-esq, dramatic moment.
<br><br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Module 4" data-href="GMAP 395 - Module 4" href="gmap-395\module-4\gmap-395-module-4.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-4\gmap-395-wk-9-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 4/GMAP 395 - WK 9 - Tutorial.md</guid><pubDate>Mon, 03 Mar 2025 21:08:53 GMT</pubDate><enclosure url="gmap-395\module-4\media\tutwk9splash.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-4\media\tutwk9splash.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[üïπÔ∏è <strong>*GMAP 395: Final Project Guide</strong>]]></title><description><![CDATA[ 
 <br><br><br>Students will create a polished, interactive game art piece by focusing on one module of their choice from the course to do the Additional Requirements for. This final deliverable will showcase their technical and artistic skills while demonstrating mastery of the selected module.<br>Requirements vs Additional Requirements
The "Requirements" for all four modules are required for all projects. You will choose one module to complete the "Additional Requirement" for to complete the final project.
The "polished game art piece" you will make for the final is the same work you have been doing for the whole quarter. You are not required to make new work, just polish your existing assets.
<br>DUE DATE
Saturday, March 22nd @ 11:59 PM
<br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_NJLPK-nqm7VbyChQ?e=PbvnMW" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_NJLPK-nqm7VbyChQ?e=PbvnMW" target="_blank">gmap395_finalVid.mp4</a><br><br><br><br>Each module for the final includes main requirements and one additional challenge to practice development, critical-thinking, and creativity.<br><br>
Requirements:

<br>‚úÖ Create a procedural or modular system for props, characters, or environments.
<br>‚úÖ Integrate at least three lighting sources: one directional light and two auxiliary lights (e.g., point, spot, area lights).
<br>‚úÖ Use modular assets to build a cohesive scene.
<br>‚úÖ Incorporate a dynamic lighting element, like a day-night cycle or interactive light source.

<br>
üîß Additional Requirement:

<br>Add an advanced procedural element, such as animated modular components or interactive environmental changes (e.g., destructible props, dynamic weather systems).

<br><br><br>
Requirements:

<br>‚úÖ Develop at least two custom shaders using Shader Graph or HLSL.
<br>‚úÖ Include shaders with dynamic properties, like adjustable emission, transparency, or surface effects.
<br>‚úÖ Ensure shaders are cohesive with the overall project aesthetic.

<br>
üîß Additional Requirement:

<br>Design a shader with user-driven interactions (for both required shaders) activated by user interaction or environmental triggers (e.g., heat distortion near light sources, ripple effects when interacted with).

<br><br><br>
Requirements:

<br>‚úÖ Create at least three particle systems (e.g., sparks, smoke, mist).
<br>‚úÖ Use modular techniques for particle creation (e.g., reusable templates, layered systems).
<br>‚úÖ Ensure effects are integrated within a cohesive game art scene.

<br>
üîß Additional Requirement:

<br>Build a reactive particle system (for 2 of the 3 required systems) that changes based on environmental conditions, player interaction, or time (e.g., intensity, color, or behavior adjusting to a day-night cycle).

<br><br><br>
Requirements:

<br>‚úÖ Implement a dynamic camera system using Cinemachine.
<br>‚úÖ Add at least two post-processing effects (e.g., bloom, color grading, depth of field) to enhance visual quality.
<br>‚úÖ Use camera animations or transitions to highlight specific parts of the scene.

<br>
üîß Additional Requirement:

<br>Develop a camera-based interaction system, such as zoom-in on specific triggers or focus shifts during player interactions and manipulate (1 of the 2 required post-process effects) based on player interaction of environmental triggers.**

<br><br><br>What to Submit

<br>Interactive Scene:

<br>A fully developed Unity scene meeting the requirements of the selected module.
<br>The scene must be cohesive, polished, and technically proficient.


<br>Playthrough Video:

<br>A 10-minute video showcasing the final project.
<br>Include annotations or narration explaining key design decisions.


<br>Postmortem Document:

<br>A 1‚Äì2 page reflection including:

<br>Successes: Highlight key achievements.
<br>Challenges: Discuss difficulties and solutions.
<br>Learning Outcomes: Share what you‚Äôve learned.


<br>Include citations for any external assets used.


<br>Unity Project Files:

<br>A zipped folder with only the necessary files: Assets, Packages, ProjectSettings ONLY (‚ùå omit the Library, Temp, and other folders).


<br>Polished Build:

<br>A playable Windows build demonstrating your project.



<br><br>Requirements
For each module there are a set of Requirements that must be met for every module. Then there are Additional Requirements that must only be met for whichever module you choose to polish for the final.
<br><br><br>Your project will be evaluated based on:<br>
<br>Technical Mastery: Effective use of tools and workflows from the chosen module.
<br>Creativity and Originality: Innovative and thoughtful design choices.
<br>Cohesion: Visual and thematic consistency throughout the project.
<br>Polish: Overall quality and refinement of the interactive experience.
<br>Presentation: Clarity and professionalism in the playthrough video and postmortem document.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Main Course Page</a>]]></description><link>gmap-395\gmap-395-final-project-details-and-requirements.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - Final Project - Details and Requirements.md</guid><pubDate>Mon, 03 Mar 2025 21:06:51 GMT</pubDate></item><item><title><![CDATA[Syllabus]]></title><description><![CDATA[ 
 <br><br><br><br>Instructor Details

<br>Name: Darren Woodland, Jr.
<br>Email: <a data-tooltip-position="top" aria-label="mailto:dkw34@drexel.edu" rel="noopener nofollow" class="external-link" href="mailto:dkw34@drexel.edu" target="_blank">dkw34@drexel.edu</a>
<br>Office Hours: By appointment through email or <a data-tooltip-position="top" aria-label="https://outlook.office.com/bookwithme/user/8a28cf456da9442e97dda421b09a3af0@drexel.edu/meetingtype/MWYxQdbZA0mCye-WJGVcQw2?anonymous&amp;ep=mCardFromTile" rel="noopener nofollow" class="external-link" href="https://outlook.office.com/bookwithme/user/8a28cf456da9442e97dda421b09a3af0@drexel.edu/meetingtype/MWYxQdbZA0mCye-WJGVcQw2?anonymous&amp;ep=mCardFromTile" target="_blank">booking</a>.

<br><br>Classroom Info

<br>Term: Summer Quarter 2025
<br>Location: URBN 250
<br>Students will use Drexel Learn and their @drexel.edu emails for all class communication.

<br><br>This course introduces students to procedural real-time game systems and technical art production. Students will explore game engine based workflows, gaining proficiency in shaders, particle systems, modeling, and visual effects. The course emphasizes real-time systems and modular design techniques.<br><br>Key Capabilities

<br>Procedural and modular modeling
<br>Shader and material development
<br>Particle and image effects
<br>Lighting, camera techniques, and post-processing

<br><br>Learning Approach
Studio-Based Learning: Class time prioritizes hands-on practice, peer collaboration, and instructor guidance.<br>
Modular Skill Development: Content is organized into focused, digestible modules that build progressively toward professional competency.<br>
Critique Culture: Weekly progress reviews emphasizing creative growth through peer and instructor feedback.
<br><br>By the end of the course, students will demonstrate skills in:<br>
<br>ü§ñ Procedural modeling
<br>üí° Scene lighting and camera effects
<br>‚ú® VFX creation
<br>üñåÔ∏è Shader and material development
<br>üîÑ Technical workflows for real-time game art
<br>üéØ Professional critique and feedback skills
<br><br><br><br>Useful Links

<br><a data-tooltip-position="top" aria-label="https://unity3d.com/get-unity/download/archive" rel="noopener nofollow" class="external-link" href="https://unity3d.com/get-unity/download/archive" target="_blank">Unity 2022.3.9LTS Download</a>(Lab Version) or 2022.3.45LTS(latest)
<br><a data-tooltip-position="top" aria-label="https://www.blender.org/download/" rel="noopener nofollow" class="external-link" href="https://www.blender.org/download/" target="_blank">Blender 4.4 Download</a>
<br><a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener nofollow" class="external-link" href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a> or your favorite IDE (must support C# + Python)
<br>Screen Recording Software (like OBS)

<br><br>Useful Links

<br><a data-tooltip-position="top" aria-label="https://learn.drexel.edu/" rel="noopener nofollow" class="external-link" href="https://learn.drexel.edu/" target="_blank">Drexel Learn</a>
<br><a data-tooltip-position="top" aria-label="https://dl.acm.org/" rel="noopener nofollow" class="external-link" href="https://dl.acm.org/" target="_blank">ACM Digital Library</a>
<br><a data-tooltip-position="top" aria-label="https://www.gdcvault.com/" rel="noopener nofollow" class="external-link" href="https://www.gdcvault.com/" target="_blank">GDC Vault</a>
<br><a data-tooltip-position="top" aria-label="https://freelibrary.org/" rel="noopener nofollow" class="external-link" href="https://freelibrary.org/" target="_blank">LinkedIn Learning via Free Library of Philadelphia</a>

<br><br><br><br>Week 1 Highlights

<br>Syllabus, Course Structure, and Important Links
<br>Tool setup and workflow establishment
<br>Weekly check-ins and peer feedback
<br>Course Theme 

<br><br>Weeks 2-3 Highlights

<br>Fundamentals of procedural modeling
<br>Modular workflows, node-based workflows, and DAGs
<br>Lighting systems focusing on geometry and light interplay

<br>Assignment 1: Create a modular game asset and integrate lighting systems.<br>
Due: Week 3<br><br>Weeks 4-5 Highlights

<br>Custom shader creation using code and visual scripting
<br>Application of shaders to procedural assets for real-time interactivity
<br>Material properties and real-time rendering

<br>Assignment 2: Develop shaders for the asset created in Assignment 1.<br>
Due: Week 5<br><br>Weeks 6-7 Highlights

<br>VFX design principles and workflows
<br>Particle systems using visual scripting and component-based systems
<br>Creating interactive effects tied to game mechanics

<br>Assignment 3: Add particle and dynamic visual effects to the modular asset.<br>
Due: Week 7<br><br>Week 8-9 Highlights

<br>Camera manipulation techniques
<br>Post-processing pipelines for polish and visual enhancement
<br>Performance and visual quality balancing

<br>Assignment 4: Implement camera effects and post-processing for the asset.<br>
Due: Week 8<br><br>Weeks 10-11 Focus Combine and refine work from Modules 1-4 into a polished scene or artifact.<br>Final Deliverables:<br>
<br>üéØ Cohesive scene incorporating procedural assets, shaders, VFX, lighting, and post-processing.
<br>üé• Presentation videos with technical breakdown
<br><br><br>
<br>Check-in &amp; Critique: Weekly progress presentations and peer feedback
<br>Mini-Lecture &amp; Demo: Just-in-time instruction based on current module
<br>Studio Practice: Hands-on work with instructor guidance and peer collaboration
<br>Wrap-up &amp; Next Steps: Preview upcoming content and assignment clarification
<br><br><br><br><br>Grading Breakdown

<br>35% Assignments: Bi-weekly assignments focusing on module topics.
<br>25% Final Project: Integration of course concepts into a cohesive artifact.
<br>25% Participation and Professionalism: Engagement, attendance, and critique contributions.
<br>15% Weekly Progress Reviews: Short assessments via Drexel Learn to reinforce key concepts.

<br><br><br><br>Classroom Activities
In order to foster a more optimal learning environment and ensure respect for all participants, the following policy is in effect during lectures, live-coding, and both guest and student presentations:<br>
- No personal electronic devices: Cell phones, tablets, laptops, and other devices must be turned off and put away unless explicitly permitted for note-taking or learning activity use.<br>
- No non-course-related activities: Gaming, video watching, social media use, or any other non-course-related activities are strictly prohibited.<br>
- Acceptable learning activities: Note-taking (electronic or handwritten) and productive doodling/drawing related to course content are permitted and encouraged.<br>
- Lab sessions: During hands-on lab portions, device use is allowed for course-related work. Peer discussions, and instructor engagement is strongly encouraged.
<br>Affects Participation + Professionalism
Violations of this policy will impact the Participation and Professionalism grade. Multiple offenses may result in a zero (0) for this component of the course grade, without exception.
<br><br>Cheating and Plagiarism Definitions
Cheating or plagiarism, as defined for this course, are governed by the Drexel University Academic Integrity Policy.<br>
Both are strictly forbidden. DO NOT DO IT!<br>
All instances will be investigated and reported as outlined by Drexel University policy.<br>
They will also result in: at minimum failing the assignment and an automatic decrease&nbsp;of one letter grade for your final grade and may result in your failing the course.
<br><br>Submission Rules

<br>Submit all work via Drexel Learn (unless other wise specified).
<br>Follow assignment submission guidelines outlined in briefs
<br>Use proper file naming conventions (e.g., abc123_a1_lighting_final.mp4).

<br><br>Late Assignmnets
Assignments must be turned in on time!<br>
Lateness will automatically result in at&nbsp;minimum the loss of one letter grade.<br>
Late work incurs a 10% penalty per day.
<br><br>Attendance Requirements

<br>Attendance is mandatory. 
<br>Students are allowed one unexcused absence.
<br>Missing more than one class (unexcused) reduces your grade.
<br>Each late arrival to class will result in 50% attendance for the day.
<br>Weekly Progress Reviews are mandatory - missing reviews impact participation grade

<br>Excused Abcense
Note that an excused absence is defined as one that is the result of a condition or&nbsp;circumstance beyond the student's control, such as illness, a family crisis or&nbsp;emergency, or some other serious and important personal circumstance.
<br>Three or more absences results in course failure.<br><br>AI Use Policy
Artificial intelligence (AI) tools, such as large language models (e.g., ChatGPT or Claude), may be used in this course under specific guidelines, outlined below.
<br>Approved AI Uses

<br>AI tools are permitted for developing assets for assignments and projects, such as generating images or code snippets.
<br>Students may use AI to help better contextualize and understand code, programming concepts, and course structures. This includes using AI for code review, breakdowns, and topic summaries.
<br>All written materials, explanations, and analyses submitted for assignments should be the original work of the student. AI should not be used to generate these portions of your submissions.

<br>Use and Citation
The use of AI tools is not mandatory. Students may opt out of using AI assistants entirely if they prefer to complete all work without AI assistance.<br>
When AI tools are used students must:

<br>Clearly indicate which portions of their work were created with AI assistance and which tools were used
<br>Be able to explain and defend all submitted work
<br>Be able to demonstrate original creative decision-making and artistic voice

<br>Use and Understanding
Regardless of AI usage, students are responsible for understanding and being able to explain all aspects of their submitted work.
<br><br>Course Changes to the Course
It is very important that each student has read and understood all the materials,&nbsp;assignments, and due dates on the syllabus. It is the prerogative of the instructor to change the course during the term at their discretion in the interest of&nbsp;responding to individual class needs. Changes will be communicated to students via Drexel Learn and/or email
<br><br><br>This course, including all meetings, assignments, and activities, operates under Drexel University‚Äôs policies. All students are expected to read and fully understand these policies as they apply to the coursework and conduct within this class.<br><br>Plagiarism and Cheating Policy

<br>Plagiarism or cheating will result in a failing grade for the assignment and potential course failure and further academic discipline.

<br><br><br><br><br><br><br><br><br><br><br><br><br><br>Note: This syllabus reflects our modular learning approach - content may be adjusted based on class needs and pacing, with changes communicated via Drexel Learn and communicated via email announcements.<br> <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\gmap-395-syllabus.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - Syllabus.md</guid><pubDate>Tue, 24 Jun 2025 20:36:18 GMT</pubDate></item><item><title><![CDATA[Welcome to GMAP 395!]]></title><description><![CDATA[ 
 <br><br>About the Course
GMAP 395, Advanced Game Art and Production, is an undergraduate-level course focusing on concepts and techniques related to technical art for games. 
Dive into real-time systems and game engine workflows with topics like:

<br>Shaders: Mastering visual effects and materials.
<br>Procedural Modeling: Automating asset creation.
<br>Lighting Systems: Enhancing mood and realism.
<br>Camera Effects: Dynamic cameras and post-processing.

Whether you're aiming to focus on creating visually stunning worlds or procedural game systems, this course equips you with the tools to succeed.
<br><br><br><br><br><br><br><br>
<br>Instructor: Darren Woodland, Jr.  
<br>Office Hours (by appointment): <a data-tooltip-position="top" aria-label="https://outlook.office.com/bookwithme/user/8a28cf456da9442e97dda421b09a3af0@drexel.edu/meetingtype/MWYxQdbZA0mCye-WJGVcQw2?anonymous&amp;ep=mCardFromTile" rel="noopener nofollow" class="external-link" href="https://outlook.office.com/bookwithme/user/8a28cf456da9442e97dda421b09a3af0@drexel.edu/meetingtype/MWYxQdbZA0mCye-WJGVcQw2?anonymous&amp;ep=mCardFromTile" target="_blank">Microsoft Bookings</a> or email.
<br><br><br>For questions or concerns, feel free to reach out:  <br>
<br>Email: <a data-tooltip-position="top" aria-label="mailto:dkw34@drexel.edu" rel="noopener nofollow" class="external-link" href="mailto:dkw34@drexel.edu" target="_blank">dkw34@drexel.edu</a>
<br>Discord: tromboctopus
<br><br><br><br>
<br>Overview of games, design, and play
<br>Introduction to technical art for games
<br>Introduction to procedural and modular workflows
<br><br>
<br>Overview of procedural modeling
<br>Introduction to node-based workflows for modeling
<br>Introduction to real-time lighting systems
<br><br>
<br>Creating custom shaders
<br>Understanding lighting interactions
<br>Stylized vs. photorealistic materials
<br><br>
<br>Introduction to particle systems
<br>Procedural and modular design with particles
<br>Applications and feedback
<br><br>
<br>Full-screen effects and post processing
<br>Modular camera systems and applications
<br>Camera effects and real-time feedback
<br><br>
<br>A cohesive real-time scene incorporating procedural assets, shaders, VFX, lighting, and post-processing.
<br><br>
<br><a data-href="Legacy Tutorials for Game Audio Implementation and Mixing" href="gmap-395\bonus-proc-audio\legacy-tutorials-for-game-audio-implementation-and-mixing.html" class="internal-link" target="_self" rel="noopener nofollow">Legacy Tutorials for Game Audio Implementation and Mixing</a>
<br><a data-href="Legacy Presentations on Procedural Audio for Games - SU24" href="gmap-395\bonus-proc-audio\legacy-presentations-on-procedural-audio-for-games-su24.html" class="internal-link" target="_self" rel="noopener nofollow">Legacy Presentations on Procedural Audio for Games - SU24</a>
<br><br><br><br><br><br>Recommended Software

<br>Unity: <a data-tooltip-position="top" aria-label="https://unity.com/download" rel="noopener nofollow" class="external-link" href="https://unity.com/download" target="_blank">Download Link</a>
<br>Blender: <a data-tooltip-position="top" aria-label="https://www.blender.org/download/" rel="noopener nofollow" class="external-link" href="https://www.blender.org/download/" target="_blank">Download Link</a>
<br>Visual Studio Code: <a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener nofollow" class="external-link" href="https://code.visualstudio.com/" target="_blank">Download Link</a>
<br>Screen Recording Software: i.e. OBS or Camtasia

<br><br>]]></description><link>gmap-395\gmap-395-welcome.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - Welcome.md</guid><pubDate>Tue, 24 Jun 2025 20:33:45 GMT</pubDate></item><item><title><![CDATA[üê≤ Drexel Courses List]]></title><description><![CDATA[ 
 <br><br>About This Page
Welcome to the landing page for the courses I teach! This includes courses from both:

<br>üé• DIGM (Digital Media)  
<br>üéÆ GMAP (Game Art and Production)  

Explore the courses below to find detailed content, assignments, and resources.
<br><br><br><br>ü§ñ <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395</a>: Advanced Game Art and Production<br>
Technical art for games: shaders, procedural modeling, lighting systems, and real-time workflows.<br>üõ†Ô∏è GMAP 345: Game Development Foundations <br>üìú GMAP 231: Scripting for Game Design  <br><br><br>üìú GMAP 131: Introduction to Scripting for the Digital Content Creation Pipeline<br>
Scripting fundamentals for automating workflows, optimizing pipelines, and enhancing digital content creation processes.<br><br><br>
üß† Expand Your Skills: Learn techniques in digital media and game production.<br>
üéØ Build Your Portfolio: Create projects that can stand out in a portfolio.<br>
üåê Collaborate and Innovate: Work with peers to tackle creative challenges.
<br><br>Use the links above to jump directly to the course materials, assignments, and other resources for each course.<br><br>]]></description><link>index.html</link><guid isPermaLink="false">Index.md</guid><pubDate>Sun, 05 Jan 2025 19:46:34 GMT</pubDate></item></channel></rss>