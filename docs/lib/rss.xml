<rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[drexel-teaching]]></title><description><![CDATA[Obsidian digital garden]]></description><link>http://github.com/dylang/node-rss</link><image><url>lib\media\favicon.png</url><title>drexel-teaching</title><link/></image><generator>Webpage HTML Export plugin for Obsidian</generator><lastBuildDate>Mon, 03 Feb 2025 20:17:19 GMT</lastBuildDate><atom:link href="lib\rss.xml" rel="self" type="application/rss+xml"/><pubDate>Mon, 03 Feb 2025 20:17:04 GMT</pubDate><ttl>60</ttl><dc:creator/><item><title><![CDATA[Introduction and Overview]]></title><description><![CDATA[ 
 <br><br><br>This introductory module sets the stage for the quarter by exploring the core ideas of games, design, and play while introducing technical art and procedural workflows as key methodologies in modern game development.<br><br><a data-tooltip-position="top" aria-label="GMAP 395 - WK 1 - Slides" data-href="GMAP 395 - WK 1 - Slides" href="gmap-395\introduction\gmap-395-wk-1-slides.html" class="internal-link" target="_self" rel="noopener nofollow">Week 1 Slides</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - WK 1 - Video Lecture" data-href="GMAP 395 - WK 1 - Video Lecture" href="gmap-395\introduction\gmap-395-wk-1-video-lecture.html" class="internal-link" target="_self" rel="noopener nofollow">Week 1 Video</a><br><br><br>
<br>The relationship between games, design, and play.
<br>Introduction to technical art for games.
<br>Fundamentals of procedural and modular workflows.
<br><br><br>By the end of this module, you will:<br>
<br>Define key concepts of games, design, and play.
<br>Understand the role of technical art in game development.
<br>Explore the benefits and principles of procedural workflows.
<br><br><br>n/a<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://www.riotgames.com/en/artedu/technical-art" rel="noopener nofollow" class="external-link" href="https://www.riotgames.com/en/artedu/technical-art" target="_blank">What is Technical Art?</a>
<br><a data-tooltip-position="top" aria-label="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" rel="noopener nofollow" class="external-link" href="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" target="_blank">What is Technical Artist?</a>
<br><a data-tooltip-position="top" aria-label="https://www.autodesk.com/solutions/proceduralism" rel="noopener nofollow" class="external-link" href="https://www.autodesk.com/solutions/proceduralism" target="_blank">Procedural Workflows Explained</a>
<br><a data-tooltip-position="top" aria-label="https://www.void1gaming.com/post/3-pillars-in-game-engineering-intro-to-modular-game-design" rel="noopener nofollow" class="external-link" href="https://www.void1gaming.com/post/3-pillars-in-game-engineering-intro-to-modular-game-design" target="_blank">Introduction to Modular Design</a>
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\introduction\gmap-395-introduction-and-overview.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - Introduction and Overview.md</guid><pubDate>Wed, 08 Jan 2025 23:27:36 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 1 - Slides]]></title><description><![CDATA[ 
 <br><br><br><br><br>
<br>Purpose: 

<br>Introduction to procedural real-time game systems and technical art production, exploring workflows in game engines w/ DCCs.


<br>Key Topics:

<br>Procedural and modular workflows.
<br>Real-time systems and node-based workflows.
<br>Shader development and VFX
<br>Lighting systems and camera effects.


<br><br><br>
<br>Definition: The process of designing interactive systems that facilitate structured play.
<br>Core Focus:

<br>Create rules and systems that encourage meaningful interaction.
<br>Design experiences that resonate emotionally and intellectually with players.


<br>--<br><br>
<br>Why Game Design Matters:

<br>Engage players through creativity and interactivity.
<br>Fulfill human needs for autonomy, relatedness, and competence.


<br>Player-Centric Motivations + Goals:

<br>Autonomy: The need to feel in control and make choices that align with your values and priorities.
<br>Relatedness: The need to feel connected to and supported by others.
<br>Competence: The need to feel capable and have the skills and resources to do something.


<br>Self-Determination Theory
<a rel="noopener nofollow" class="external-link" href="https://www.urmc.rochester.edu/community-health/patient-care/self-determination-theory" target="_blank">https://www.urmc.rochester.edu/community-health/patient-care/self-determination-theory</a><br>
<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=3vct13OhIio" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=3vct13OhIio" target="_blank">"The Freedom Fallacy"</a>
<br>--<br><br>
<br>Rules:

<br>The boundaries that define what players can and cannot do.
<br>Examples: Movement rules, scoring systems, and constraints.


<br>Systems:

<br>Interconnected rules that shape gameplay experiences.
<br>Examples: Resource management, combat mechanics, or crafting systems.


<br>Player Experience:

<br>The overarching goal of game design is to evoke emotions and sustain player engagement.


<br>--<br><br>
<br>Conceptualize:

<br>Generate ideas and define the game’s objectives.
<br>Example Activities:

<br>Brainstorm themes and mechanics.
<br>Identify the target audience.




<br>Prototype:

<br>Create a basic, playable version of the game.
<br>Example Activities:

<br>Build a simple demo with placeholder assets.




<br>Playtest:

<br>Test with real players to observe how they interact with the game.
<br>Example Activities:

<br>Record player feedback.




<br>Evaluate:

<br>Analyze feedback and refine mechanics and systems.
<br>Example Activities:

<br>Identify areas of improvement.
<br>Implement changes and repeat the cycle.




<br>--<br><br>
<br>Continuous Improvement:

<br>Iteration allows designers to refine ideas based on real-world feedback.


<br>Learning from Failure:

<br>Unsuccessful elements provide insights for improvement.


<br>Key Takeaway: The best games are shaped through repeated cycles of creation, testing, and refinement.
<br>On Iteration:
"Iteration is the backbone of game design—it's where great games are born."
<br>
<br><a data-tooltip-position="top" aria-label="https://gamedesignskills.com/game-design/iterative-process/" rel="noopener nofollow" class="external-link" href="https://gamedesignskills.com/game-design/iterative-process/" target="_blank">How to Apply the Iterative Process in Game Design</a>
<br><a data-tooltip-position="top" aria-label="https://www.gamedeveloper.com/design/making-better-games-through-iteration" rel="noopener nofollow" class="external-link" href="https://www.gamedeveloper.com/design/making-better-games-through-iteration" target="_blank">Making Better Games Through Iteration</a>
<br><br>--<br><br>
<br>Games as Everyday Things:

<br>Video games are modern artifacts of daily interaction, much like physical tools or interfaces.
<br>Designing games requires the same care and consideration as designing everyday objects.


<br><img alt="GMAP 395/Introduction/design-everyday-things.jpg" src="gmap-395\introduction\design-everyday-things.jpg"><br>--<br><br>Key principles from The Design of Everyday Things<br>
<br>Affordances:

<br>Elements that suggest how they should be used.


<br>
<br>In games: A glowing door suggests it can be opened, or a bouncy surface implies jumping.
<br>
<br>Constraints:

<br>Limitations that guide user interaction.
<br>In games: Invisible walls, restricted areas, or locked abilities.


<br>Feedback:

<br>Immediate response to actions.
<br>In games: Sound effects, visual cues, or vibrations indicating success or failure.


<br>Signifiers:

<br>Visual or auditory cues that communicate functionality.
<br>In games: Icons, markers, or prompts that guide players.


<br>--<br><br>
<br>Clarity in Design:

<br>Clear affordances and signifiers reduce player frustration.


<br>Player Intuition:

<br>Well-designed constraints and feedback align with natural player expectations.


<br>Games as Interfaces:

<br>Like everyday tools, games rely on good design to be engaging and accessible.


<br>Further Reading:

<br><a data-tooltip-position="top" aria-label="https://ia902800.us.archive.org/3/items/thedesignofeverydaythingsbydonnorman/The Design of Everyday Things by Don Norman.pdf" rel="noopener nofollow" class="external-link" href="https://ia902800.us.archive.org/3/items/thedesignofeverydaythingsbydonnorman/The%20Design%20of%20Everyday%20Things%20by%20Don%20Norman.pdf" target="_blank">The Design of Everyday Things by Don Norman</a>
<br>



<br><br><br>
<br>Definition:

<br>Play is an activity undertaken for enjoyment, creativity, and engagement.


<br>Characteristics of Play:

<br>Voluntary: A self-chosen activity, not obligatory.
<br>Imaginative: Often involves creativity, make-believe, or exploration.
<br>Intrinsically Motivated: Done for its own sake, without external rewards.
<br>Bounded: Occurs within defined limits (rules, time, or space).


<br>Why Play Matters:

<br>Satisfies intrinsic human needs like autonomy, competence, and relatedness.


<br>Explore More:
<a data-tooltip-position="top" aria-label="https://nifplay.org/play-science/scientific-disciplines-researching-play/" rel="noopener nofollow" class="external-link" href="https://nifplay.org/play-science/scientific-disciplines-researching-play/" target="_blank">Play: How It Shapes the Brain</a><br>
<a data-tooltip-position="top" aria-label="https://mitpress.mit.edu/9780262534512/play-matters/" rel="noopener nofollow" class="external-link" href="https://mitpress.mit.edu/9780262534512/play-matters/" target="_blank">Play Matters</a><br>
<a data-tooltip-position="top" aria-label="https://www.sciencedirect.com/science/article/pii/S014976342300355X" rel="noopener nofollow" class="external-link" href="https://www.sciencedirect.com/science/article/pii/S014976342300355X" target="_blank">Play in video games</a>
<br>--<br><br>
<br>Play:

<br>A broad concept encompassing all enjoyable, engaging activities.
<br>Examples: Free-form exploration, role-playing, or sandbox experimentation.


<br>Gameplay:

<br>Play structured by the rules and systems of a game.
<br>Examples: Completing objectives, solving puzzles, or managing resources.


<br>Key Distinction:

<br>Play is the overarching activity, while gameplay is a specific form of play within a designed context.


<br>--<br><br>
<br>Key Design Elements:

<br>Meaningful Choices:

<br>Offer players impactful decisions that shape their experience.
<br>Example: Branching storylines or multiple gameplay approaches.


<br>Balanced Challenges:

<br>Create obstacles that are achievable yet rewarding.
<br>Example: Gradual difficulty curves to maintain player engagement.


<br>Social Connections:

<br>Enable interactions that foster collaboration or competition.
<br>Example: Multiplayer modes or shared goals.




<br>Encouraging Exploration:

<br>Design systems that allow players to experiment freely within rules.


<br><br>--<br><br>
<br>Game Spotlight: The Legend of Zelda: Breath of the Wild (2017)

<br>Meaningful Choices:

<br>Players can tackle challenges in various ways, from combat to stealth.


<br>Balanced Challenges:

<br>Flexible difficulty, allowing players to approach objectives at their own pace.


<br>Encouraged Exploration:

<br>A vast open world filled with secrets, puzzles, and rewards that encourage curiosity.




<br>An In-Depth Look at Conventions, Design, and Play:

<br><br><br>
<br>What are Frameworks?

<br>Conceptual tools that can help guide the game design process.
<br>Help designers organize ideas and evaluate design decisions.


<br>Why Use Frameworks?

<br>Provide clarity and focus during development.
<br>Facilitate collaboration and communication among teams.


<br>There are many different frameworks for all aspects of game design!
<br>--<br><br>
<br>Definition:

<br>A formalized approach to understanding and designing games.
<br>Introduced by Robin Hunicke, Marc LeBlanc, and Robert Zubek.


<br>
<br>--<br>Components: MDA<br>
<br>Mechanics: The rules and systems governing gameplay.

<br>Example: Jump mechanics in platformers.


<br>Dynamics: The emergent behavior arising from player interaction.

<br>Example: Strategic decisions in chess.


<br>Aesthetics: The emotional response evoked in players.

<br>Example: Tension in horror games.


<br>Learn More: MDA Framework
<a data-tooltip-position="top" aria-label="http://www.cs.northwestern.edu/~hunicke/MDA.pdf" rel="noopener nofollow" class="external-link" href="http://www.cs.northwestern.edu/~hunicke/MDA.pdf" target="_blank">Original MDA Paper (PDF)</a>

<br>--<br><br>
<br>Definition:

<br>A player-focused framework emphasizing iterative development.
<br>Introduced to complement MDA and focus on outcomes.


<br>Components:

<br>Design: The intentional creation of mechanics and systems.
<br>Dynamics: The real-time interactions and behaviors of players.
<br>Experience: The intended and emergent outcomes of gameplay.


<br>Learn More
<a data-tooltip-position="top" aria-label="https://www.researchgate.net/publication/315854140_Design_Dynamics_Experience_DDE_An_Advancement_of_the_MDA_Framework_for_Game_Design" rel="noopener nofollow" class="external-link" href="https://www.researchgate.net/publication/315854140_Design_Dynamics_Experience_DDE_An_Advancement_of_the_MDA_Framework_for_Game_Design" target="_blank">DDE Paper</a><br>
<a data-tooltip-position="top" aria-label="https://www.gamedeveloper.com/design/from-mda-to-dde" rel="noopener nofollow" class="external-link" href="https://www.gamedeveloper.com/design/from-mda-to-dde" target="_blank">From MDA to DDE</a><br>
<a data-tooltip-position="top" aria-label="https://maxlearn.com/blogs/dde-framework-for-game-design-in-microlearning/" rel="noopener nofollow" class="external-link" href="https://maxlearn.com/blogs/dde-framework-for-game-design-in-microlearning/" target="_blank">How to Apply DDE</a>
<br>--<br><br>
<br>MDA vs. DDE:

<br>MDA: Focuses on the relationship between mechanics, dynamics, and aesthetics from a system perspective.
<br>DDE: Centers on the player experience and iterative refinement.


<br>Use Cases:

<br>MDA: Best for understanding and planning complex systems.
<br>DDE: Ideal for refining player experiences through testing and iteration.


<br><br><br>
<br>
Definition:

<br>The bridge between art and technology in game development.
<br>Combines creative and technical skills to enhance workflows and visual quality.


<br>
Key Roles:

<br>Ensure the seamless integration of assets into game engines.
<br>Solve cross-disciplinary challenges between artists and programmers.



<br>--<br><br>
<br>Attention to Detail
<br>Communication and Collaboration
<br>Strong Art and Technical Knowledge
<br>Technical Proficiency
<br>Creative Problem-Solving
<br>Learn More: Tech Art
<a data-tooltip-position="top" aria-label="https://www.tech-artists.org/t/about-the-professional-category/9845" rel="noopener nofollow" class="external-link" href="https://www.tech-artists.org/t/about-the-professional-category/9845" target="_blank">Tech-Artists Site</a><br>
<a data-tooltip-position="top" aria-label="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" rel="noopener nofollow" class="external-link" href="https://www.screenskills.com/job-profiles/browse/games/technical-art/technical-artist/" target="_blank">Tech Artists in Games</a><br>
<a data-tooltip-position="top" aria-label="https://www.cgspectrum.com/career-pathways/technical-artist" rel="noopener nofollow" class="external-link" href="https://www.cgspectrum.com/career-pathways/technical-artist" target="_blank">Technical Artist Job</a>
<br>--<br><br>
<br>What is Procedural Thinking?

<br>Using algorithms and rules to automate content creation.


<br>Applications in Game Development:

<br>Terrain and foliage generation.
<br>Character customization systems.


<br>Benefits:

<br>Efficiency: Reduces time spent on repetitive tasks.
<br>Scalability: Enables the creation of vast, dynamic worlds.


<br><br>--<br><br>
<br>What is Modular Thinking?

<br>Designing assets and systems in reusable, interchangeable components.


<br>Applications in Game Development:

<br>Modular level design (e.g., room prefabs in a dungeon).
<br>Swappable character parts or weapons.


<br>Benefits:

<br>Reusability: Saves development time and resources.
<br>Flexibility: Allows easy updates and customization.


<br><br>--<br><br>
<br>How They Work Together:

<br>Procedural techniques generate modular components that can be reused across projects.


<br>Example Workflow:

<br>Procedurally create terrain using rules → Populate with modular assets like trees and rocks.


<br>Key Benefits:

<br>Enhances both creativity and efficiency in asset creation.


<br><br><br>
<br>What is a DAG?

<br>A structure where nodes are connected in a one-way direction, forming a tree-like graph with no loops.


<br>Why DAGs?

<br>Support non-linear workflows, enabling iterative and modular development.


<br>Applications in Game Art and Development:

<br>Organizing and optimizing procedural pipelines.
<br>Managing dependencies between assets and systems.
<br>Building, modeling, or texturing assets
<br>Real-time gameplay systems


<br>DAGs
<a rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Directed_acyclic_graph" target="_blank">https://en.wikipedia.org/wiki/Directed_acyclic_graph</a><br>
<a rel="noopener nofollow" class="external-link" href="https://www.getdbt.com/blog/guide-to-dags" target="_blank">https://www.getdbt.com/blog/guide-to-dags</a>
<br>--<br><br>
<br>Definition:

<br>Visual scripting and data-driven approaches used to create procedural systems and assets.


<br>How It Works:

<br>Nodes represent specific tasks or operations.
<br>Connections between nodes define the flow of data or operations.


<br>Common Use Cases:

<br>Procedural content generation.
<br>Shader and material creation.
<br>Logic and gameplay systems in visual scripting tools.


<br><a data-href="GMAP395-DAGsNodes.excalidraw" href="gmap-395\introduction\gmap395-dagsnodes.excalidraw.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP395-DAGsNodes.excalidraw</a><br>--<br><br>
<br>Houdini:

<br>Procedural modeling, VFX, and simulations using node-based workflows.
<br>Example: Generating terrain or foliage with procedural rules.


<br>Unreal Engine:

<br>Blueprint visual scripting for game logic and interactive systems.
<br>Example: Creating interactive gameplay without traditional coding.


<br>Unity Shader Graph:

<br>Node-based tool for crafting complex shaders visually.
<br>Example: Building a dynamic water shader with transparency and reflections.


<br>--<br>Explore Further: Node-Based Workflows
<a data-tooltip-position="top" aria-label="https://www.sidefx.com/tutorials/intro-to-houdinis-node-based-workflow/" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/tutorials/intro-to-houdinis-node-based-workflow/" target="_blank">Introduction to Node-Based Workflows in Houdini</a><br>
<a data-tooltip-position="top" aria-label="https://www.sidefx.com/docs/houdini/nodes/index.html" rel="noopener nofollow" class="external-link" href="https://www.sidefx.com/docs/houdini/nodes/index.html" target="_blank">Houdini's Nodes</a><br>
<a data-tooltip-position="top" aria-label="https://spin.atomicobject.com/blender-node-based-workflows/" rel="noopener nofollow" class="external-link" href="https://spin.atomicobject.com/blender-node-based-workflows/" target="_blank">Blenders Node-Based Workflows</a>

<br>--<br><br>
<br>Modular Logic:

<br>Easily modify individual nodes without disrupting the entire system.


<br>Reusability:

<br>Nodes and node groups can be saved and reused across projects.


<br>Visualization:

<br>Provides a clear visual representation of processes and data flow.


<br>Flexibility:

<br>Supports rapid iteration and experimentation.


<br>--<br><br>
<br>Key Topics Covered:

<br>Game Design:

<br>Foundations, processes, and the importance of play.


<br>Frameworks:

<br>MDA and DDE as tools for understanding player experience.


<br>Technical Art:

<br>Bridging art and technology through procedural and modular workflows.


<br>Node-Based Workflows:

<br>Visual scripting for flexible and scalable game systems.




<br>--<br><br>
<br>Why Iteration Matters:

<br>Continuous Improvement:

<br>Allows for refinement of gameplay and visual quality.


<br>Adaptability:

<br>Respond to player feedback and emerging challenges.


<br>Polished Results:

<br>Iteration ensures systems, mechanics, and art are cohesive and engaging.




<br>Key Takeaway: Iteration isn’t just a step—it’s a philosophy.
<br>--<br><br>
<br>Emerging Technologies:

<br>AI and Machine Learning:

<br>Generative tools for textures, animations, and world-building.


<br>Real-Time Rendering:

<br>Advancements like ray tracing for hyper-realistic visuals.


<br>Procedural Workflows:

<br>Increasing reliance on algorithms to generate complex assets.




<br>The Next Frontier:

<br>Player-Created Content: Empowering users to design within games.
<br>Immersive Systems: Expanding XR (VR/AR/MR) experiences.


<br>Explore More:

<br><a data-tooltip-position="top" aria-label="https://www.gamasutra.com/" rel="noopener nofollow" class="external-link" href="https://www.gamasutra.com/" target="_blank">AI in Game Development</a>
<br><a data-tooltip-position="top" aria-label="https://www.unrealengine.com/" rel="noopener nofollow" class="external-link" href="https://www.unrealengine.com/" target="_blank">Real-Time Rendering Techniques</a>

<br><br><br><br>
<br>What excites (or scares) you most about modern game design and development tools?
<br>How do you think procedural or modular workflows influence the games we play today?
<br>--<br><br><br>
<br>Choose a game you’ve played and enjoyed.
<br>Reflect on:

<br>What elements of the game stand out to you? (e.g., visuals, mechanics, world design)
<br>How do you think these elements were created? Consider tools or workflows like procedural generation, modular design, or shaders.


<br>Light Research:

<br>Look up the game’s development process or tools used by its studio.
<br>Example tools for research:

<br>The Legend of Zelda: Breath of the Wild (physics puzzles, procedural systems)
<br>No Man’s Sky (Procedural world-building)
<br>Celeste (Iteration for accessibility and challenge balance)




<br>--<br><br>
<br>Share your observations with a partner or small group.
<br>Discuss:

<br>Similarities and differences in the chosen games.
<br>How procedural or modular workflows might have influenced the design choices.
<br>Ideas for how you might apply these concepts in your own projects.


<br>--<br><br>
<br>Volunteers and/or groups present highlights of their discussions:

<br>A game they analyzed and how procedural/modular workflows contributed to its design.
<br>An insight or idea they found particularly interesting.


<br><br><br>Reflection Questions
How does understanding the development process help you approach game design or technical art critically?<br>
What trends or common tools did you notice across different games?<br>
How might these approaches inspire your work as a game designer or artist?
]]></description><link>gmap-395\introduction\gmap-395-wk-1-slides.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - WK 1 - Slides.md</guid><pubDate>Tue, 07 Jan 2025 15:54:10 GMT</pubDate><enclosure url="gmap-395\introduction\design-everyday-things.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\introduction\design-everyday-things.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 1 - Video Lecture]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_AsN9Rcq9MtNowLIQ?e=V4Sh1W" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_AsN9Rcq9MtNowLIQ?e=V4Sh1W" target="_blank">Video link if above does not play in browser</a>]]></description><link>gmap-395\introduction\gmap-395-wk-1-video-lecture.html</link><guid isPermaLink="false">GMAP 395/Introduction/GMAP 395 - WK 1 - Video Lecture.md</guid><pubDate>Wed, 08 Jan 2025 23:44:40 GMT</pubDate></item><item><title><![CDATA[Media]]></title><description><![CDATA[ 
 ]]></description><link>gmap-395\module-1\media\media.html</link><guid isPermaLink="false">GMAP 395/Module 1/Media/Media.md</guid><pubDate>Mon, 20 Jan 2025 19:16:35 GMT</pubDate></item><item><title><![CDATA[Assignment 1: Procedural Game Art and Lighting Systems]]></title><description><![CDATA[ 
 <br><br><br>Assignment Overview  
In this assignment, students will:

<br>Create a procedural game asset in a DCC tool of their choice (e.g., Blender, Houdini, Unity).
<br>Import this asset into Unity to design and implement a lighting system that complements the asset's visual and thematic qualities.
<br>Ensure the asset and lighting align with the class theme: Something from the Void.
<br>Present their work as a Unity scene with a README file documenting their process and a recorded video explaining their approach.

<br><br><br>Assignment Breakdown

<br>Part 1: Procedural Game Art <br>
Create a procedural asset using a DCC software like Blender or Houdini. The asset must reflect the artistic theme Something from the Void.<br>
Examples include eerie cosmic objects, Lovecraftian architecture, or mysterious artifacts.<br>

<br>Part 2: Lighting Systems in Unity <br>
Import the procedural asset into Unity, set up a lighting system that complements the theme and enhances its presentation, and apply optional post-processing effects.<br>


<br><br><br><br>How to Approach the Theme  
The theme Something from the Void is intentionally open-ended. Interpret it creatively—examples include:

<br>Cosmic and Space-Inspired: Black holes, celestial ruins, or futuristic alien artifacts.
<br>Horror or Mystery: Dark, surreal environments or Lovecraftian designs.
<br>Abstract Concepts: Geometry and lighting that evoke emptiness, infinity, or the unknown.

<br><br><br>Key Steps for Part 1

<br>Choose a DCC software like Blender, Houdini, or Maya.

<br>The tutorial for part 1 of this module uses Blender Geometry Nodes


<br>Use procedural techniques/operations and a node-based workflow to create or modify a game art asset.
<br>Ensure the asset embodies the class theme.
<br>Export the asset to a format suitable for Unity (e.g., .fbx, .obj).

<br>Example Ideas for Procedural Assets

<br>A glowing, alien crystal pulsing with energy.
<br>Ruined architecture on a distant moon.
<br>A swirling void orb or portal structure.

<br><br><br>Key Steps for Part 2

<br>Import your procedural asset into Unity.
<br>Set up a lighting system that complements the theme and highlights your asset:

<br>Use at least one directional light to simulate natural or artificial light.
<br>Add secondary lights (spotlights, area lights, etc.) for mood and detail.


<br>Design the scene to enhance the asset’s presentation within the theme.

<br>Lighting Design Tips

<br>Think about how lighting enhances the void-related theme (e.g., shadows, stark contrasts, or mysterious glows).
<br>Experiment with unusual light colors and intensities to evoke an otherworldly atmosphere.

<br><br><br>What to Submit

<br>Procedural Asset Source File:

<br>Upload your DCC project file (e.g., .blend, .hip, .mb) to show procedural workflows.


<br>README File:

<br>Create a README file in TXT or Markdown format that explains your work.
<br>Include:

<br>A description of your procedural asset and its thematic inspiration.
<br>Details of your lighting setup in Unity.
<br>Any challenges you faced and how you solved them.




<br>Recorded Video (5–10 Minutes):

<br>Record a video that breaks down your design process.
<br>The video must cover:

<br>Procedural Operations: Explain how you created your procedural game asset.
<br>Lighting Setup: Discuss your lighting choices in Unity, including tools and techniques used.
<br>Theme Alignment: Reflect on how your work ties into Something from the Void.





<br>README Example Format
# Assignment 1: Procedural Game Art and Lighting Systems

## Procedural Asset
- Software Used: Blender  
- Description: A modular crystal formation inspired by black holes, procedurally generated using Geometry Nodes.

## Unity Lighting Setup
- Lighting Design: Directional light for a natural glow, spotlights for eerie highlights.  
- Post-Processing: Enabled bloom and vignette for a mystical, void-like effect.

## Challenges
- Issue: Balancing the asset’s high-detail geometry for real-time performance.  
- Solution: Reduced polygon count and baked high-resolution normals.  

<br><br>Submission Guidelines

<br>Submission Format: Upload your project as a ZIP file to Drexel Learn.
<br>File Naming Convention: abc123_Lastname_Firstname_A1.zip.
<br>Late submissions will incur a 10% penalty per day.

<br><br><br>By completing this assignment, you will:

<br>Understand and apply procedural workflows to create modular assets.
<br>Develop an artistic vision aligned with the theme Something from the Void.
<br>Gain technical skills in importing assets into Unity and optimizing them for real-time use.
<br>Explore Unity’s lighting systems to design atmospheric and visually appealing scenes.
<br>Develop an iterative workflow for asset creation, scene design, and troubleshooting.

<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\gmap-395-asn-1-brief.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - ASN 1 - Brief.md</guid><pubDate>Fri, 17 Jan 2025 19:49:24 GMT</pubDate></item><item><title><![CDATA[Module 1 - Procedural Modeling and Lighting]]></title><description><![CDATA[ 
 <br><br><br>This module introduces foundational skills in procedural modeling and lighting systems. Students will explore creating modular assets and environments using DCC tools and plugins.<br><br><a data-href="GMAP 395 - WK 2 - Slides" href="gmap-395\module-1\gmap-395-wk-2-slides.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 2 - Slides</a><br>
<a data-href="GMAP 395 - WK 2 - Video Lecture" href="gmap-395\module-1\gmap-395-wk-2-video-lecture.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 2 - Video Lecture</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395/Module 1/GMAP 395 - WK 2 - Tutorial" data-href="GMAP 395/Module 1/GMAP 395 - WK 2 - Tutorial" href="gmap-395\module-1\gmap-395-wk-2-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 2 - Tutorial</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - WK 3 - Slides" data-href="GMAP 395 - WK 3 - Slides" href="gmap-395\module-1\gmap-395-wk-3-slides.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 3 - Slides + Video</a><br>
<a data-href="GMAP 395 - WK 3 - Tutorial" href="gmap-395\module-1\gmap-395-wk-3-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 3 - Tutorial</a><br>
<a data-href="GMAP 395 - ASN 1 - Brief" href="gmap-395\module-1\gmap-395-asn-1-brief.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - ASN 1 - Brief</a><br><br><br>
<br>Introduction to procedural modeling with Blender.
<br>Basics of lighting systems with Unity.
<br>Overview of procedural and  for modular workflows.
<br><br><br>By the end of this module, you will:<br>
<br>Gain foundational knowledge in procedural modeling techniques and lighting systems.
<br>Explore the use of industry-standard tools like Blender and Unity.
<br>Understand the importance of modular workflows in game art development.
<br>Build confidence in preparing and setting up tools for complex projects.
<br><br><br>
<br>Confirm your computer meets the recommended specifications for Blender and Unity.
<br>Install <a data-tooltip-position="top" aria-label="https://www.blender.org/download/" rel="noopener nofollow" class="external-link" href="https://www.blender.org/download/" target="_blank">Blender</a> 3.9 or higher.
<br>Install Unity (2022.3) via the <a data-tooltip-position="top" aria-label="https://unity.com/download" rel="noopener nofollow" class="external-link" href="https://unity.com/download" target="_blank">Unity Hub</a>
<br>If you have never used Blender

<br>If you have never used Unity

<br><br><br><br><br>
<br>Blender 3.9 or higher: Download from <a rel="noopener nofollow" class="external-link" href="https://www.blender.org/download/" target="_blank">https://www.blender.org/download/</a>.
<br><br>
<br>Unity (LTS version): Download from <a rel="noopener nofollow" class="external-link" href="https://unity.com/download" target="_blank">https://unity.com/download</a>.
<br>Ensure the system specifications match or exceed Unity's requirements.
<br><br><br><br><br><br>
<br><a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/4.3/getting_started/about/index.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/4.3/getting_started/about/index.html" target="_blank">Blender Quick Start Guide</a>
<br><a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/introduction.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/introduction.html" target="_blank">Introduction to Geometry Nodes</a>
<br><a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/interface/keymap/introduction.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/interface/keymap/introduction.html" target="_blank">Blender Keyboard Shortcuts</a>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/pathway/unity-essentials" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/pathway/unity-essentials" target="_blank">Unity Essentials (Getting Started)</a>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/mission/creative-core-lighting?uv=2022.3&amp;pathwayId=61a65568edbc2a00206076dd" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/mission/creative-core-lighting?uv=2022.3&amp;pathwayId=61a65568edbc2a00206076dd" target="_blank">Unity Lighting Tutorials</a>
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\module-1\gmap-395-module-1.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - Module 1.md</guid><pubDate>Tue, 21 Jan 2025 00:14:29 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 2 - Slides]]></title><description><![CDATA[ 
 <br><br><br><br><br><br><img alt="GMAP 395/Module 1/Media/gamefeelcover.webp" src="gmap-395\module-1\media\gamefeelcover.webp" style="width: 320px; max-width: 100%;"><br>Game Feel
Real-time control of virtual objects in a simulated space, with interaction emphasized by polish.<br>
-- Steve Swink
<br><br><br><br>
<br>Definition: The visceral, tactile experience of interacting with a game, making it feel responsive and tangible.
<br>Components:

<br>Real-Time Control: Immediate response to player input.
<br>Simulated Space: Believable virtual environments with realistic or stylized physics.
<br>Polish: Visual, audio, and interactive feedback that enhances immersion.


<br>Examples:<br>
<br>Super Mario Bros: Precise platforming.
<br>Celeste: Forgiving yet challenging controls.
<br>DOOM (2016): Weighty, impactful combat.
<br><br><br>
<br>Momentum and Inertia (Physics):

<br>Creating a sense of weight and speed in character and object movement.
<br>Example: Rolling boulders in The Legend of Zelda: Breath of the Wild.


<br>Input Responsiveness:

<br>Reducing input lag to ensure tight controls.
<br>Example: Fighting games like Street Fighter prioritize frame-perfect inputs.


<br><br><br>
<br>What Are Procedural Workflows?

<br>Automating content creation using algorithms and rules.
<br>Efficiently producing scalable, dynamic assets and systems.


<br>Why It Matters:

<br>Reduces repetitive tasks.
<br>Enables scalability for vast game worlds.
<br>Facilitates rapid prototyping and iteration.


<br><br><br>
<br>Applications:

<br>Terrain and Landscapes: Dynamic natural environments (e.g., Minecraft).
<br>Characters and Creatures: Diverse entities (e.g., Spore).
<br>Loot Systems: Unique equipment and items (e.g., Borderlands).
<br>Buildings and Cities: Algorithmic urban designs. (e.g., Spiderman)


<br>Efficiency: Combines hand-crafted content with procedural systems for optimal results.<br><br><br>
<br>Over-Generation:

<br>Excessively random content can feel disjointed.
<br>Solution: Blend procedural elements with curated designs and a cehesive artistic vision.


<br>Player Fatigue:

<br>Repetitive patterns may reduce engagement.
<br>Solution: Introduce meaningful variability and uniqueness within procedural systems/design.


<br><br><br>
<br>What is Modularity?

<br>Reusable components for streamlined development.


<br>Benefits:

<br>Reusability: Assets can be used across levels/projects.
<br>Flexibility: Easier updates and maintenance.
<br>Performance: Reduces memory load by optimizing reusable assets.


<br>Synergy with Proceduralism:<br>
<br>Modular assets populated procedurally for diverse environments (e.g., No Man’s Sky).
<br><a data-tooltip-position="top" aria-label="https://www.beyondextent.com/articles/balancing-modularity-and-uniqueness-in-environment-art" rel="noopener nofollow" class="external-link" href="https://www.beyondextent.com/articles/balancing-modularity-and-uniqueness-in-environment-art" target="_blank">Balancing modularity and uniqueness in Environment Art</a><br><img alt="GMAP 395/Module 1/Media/modualassetpack.png" src="gmap-395\module-1\media\modualassetpack.png" style="width: 640px; max-width: 100%;"><br><br><br>
<br>Asset Organization:

<br>Maintain a clean structure for quick access and scalability.


<br>Consistent Metrics:

<br>Standardize dimensions and pivot points.


<br>Interoperability:

<br>Ensure modular assets work seamlessly in various configurations.


<br><br><br>Book: <br> <a data-tooltip-position="top" aria-label="https://www.pcgbook.com/" rel="noopener nofollow" class="external-link" href="https://www.pcgbook.com/" target="_blank">Procedural Content Generation in Games</a><br><br><br><br><img alt="GMAP 395/Module 1/Media/pcgTaxonomy.png" src="gmap-395\module-1\media\pcgtaxonomy.png"><br>
<br>Game Bits: Assets (textures, sounds, models).
<br>Game Space: Levels, terrains, maps.
<br>Game Systems: Rules and mechanics (e.g., weather systems).
<br>Game Scenarios: Events, narratives, quests.
<br>Examples:<br>
<br>Roguelikes: Procedurally generated levels (e.g., Hades).
<br>Survival Games: Dynamic environments (e.g., Subnautica).
<br><a data-tooltip-position="top" aria-label="https://dl.acm.org/doi/10.1145/2422956.2422957" rel="noopener nofollow" class="external-link" href="https://dl.acm.org/doi/10.1145/2422956.2422957" target="_blank">Procedural content generation for games:&nbsp;A survey</a><br><br><br>
<br>Hybrid Approaches:

<br>Combining procedural and hand-crafted elements.
<br>Example: Shadow of Mordor’s Nemesis system mixes procedural generation with predefined rules.<br>



<br>Adaptive PCG:

<br>Systems that adjust content based on player behavior.
<br>Example: Dynamic difficulty adjustment in Left 4 Dead.


<br><br><br>
<br>Definition: Visual scripting using nodes to represent operations and data flow.
<br>Advantages:

<br>Artist-friendly and intuitive.
<br>Clear visual representation of processes.
<br>Supports modularity and reusability.


<br>Tools:<br>
<br>Blender Geometry Nodes: Procedural modeling nodes.
<br>Houdini: Procedural modeling and VFX.
<br>Unreal Engine Blueprint: Gameplay logic.
<br>Unity Shader Graph: Material creation.
<br><br><br>
<br>Dynamic Dependencies:

<br>Create relationships between nodes for real-time updates.
<br>Example: Automatically updating materials when assets change.


<br>Optimizations:

<br>Collapse redundant nodes for streamlined performance.
<br>Example: Combining noise and displacement nodes in terrain shaders.


<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=Wmwe1fmR1SM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=Wmwe1fmR1SM" target="_blank">Geometry Fundamentals</a>:

<br>Vertices: Points in 3D space.
<br>Edges: Lines connecting vertices.
<br>Faces: Surfaces defined by edges.
<br>Normals: Perpendicular vectors to surfaces.


<br>Math Concepts:

<br><a data-tooltip-position="top" aria-label="https://www.khanacademy.org/math/algebra-home/alg-vectors/alg-vector-basics/v/introduction-to-vectors-and-scalars" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/math/algebra-home/alg-vectors/alg-vector-basics/v/introduction-to-vectors-and-scalars" target="_blank">Vectors</a>: Direction and magnitude.
<br><a data-tooltip-position="top" aria-label="https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:matrices/x9e81a4f98389efdf:mat-intro/v/introduction-to-the-matrix" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/math/precalculus/x9e81a4f98389efdf:matrices/x9e81a4f98389efdf:mat-intro/v/introduction-to-the-matrix" target="_blank">Matrices</a>: Transformations in space.
<br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=zjMuIxRvygQ" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=zjMuIxRvygQ" target="_blank">Quaternions</a>: Representing rotations.


<br>Applications:<br>
<br>Procedural transformations (e.g., proportional scaling).
<br><img alt="GMAP 395/Module 1/Media/3D-Shapes-01-01.png" src="gmap-395\module-1\media\3d-shapes-01-01.png" style="width: 320px; max-width: 100%;"><br><br><br>
<br>Nodes and Data Flow: Organizing procedural steps.
<br>Scattering/Copying: Distributing objects procedurally (e.g., foliage).
<br>Splines: Creating paths and smooth curves.
<br>Parameter Manipulation: Dynamically adjusting properties.
<br>Attributes: Defining object-specific data.
<br>Randomization/Noise: Adding variation and realism.
<br>Boolean Operations: Combining or subtracting shapes.
<br>Instancing: Efficiently reusing objects.
<br>Deformations: Transforming shapes procedurally (e.g., terrain sculpting).
<br>Constraints: Guiding procedural behaviors.
<br>Looping: Repeating processes for consistency.
<br><br><br>
<br>Noise Patterns: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=erI7k3lt4UY" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=erI7k3lt4UY" target="_blank">The Art of Procedural Noise</a>

<br>Procedural textures for organic designs.
<br>Example: Voronoi patterns used for terrain generation or cellular structures.


<br>Fractals: <a data-tooltip-position="top" aria-label="https://www.wired.com/video/watch/5-levels-computer-scientist-explains-fractals-in-5-levels-of-difficulty" rel="noopener nofollow" class="external-link" href="https://www.wired.com/video/watch/5-levels-computer-scientist-explains-fractals-in-5-levels-of-difficulty" target="_blank">Explaining Fractals in 5 Levels</a>

<br>Recursive geometries for complex visuals.
<br>Example: Mandelbrot sets for landscapes or branching systems like lightning.


<br>Flow Fields: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=na7LuZsW2UM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=na7LuZsW2UM" target="_blank">The Beauty of Code: Flow Fields</a>

<br>Directing particle systems dynamically.
<br>Example: Simulating wind patterns or flocking behaviors in particle systems.


<br>L-Systems: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=egxBK_EGauM" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=egxBK_EGauM" target="_blank">L-Systems Fundamentals</a>

<br>Rule-based systems for generating fractal-like structures.
<br>Example: Procedurally creating realistic trees, plants, or coral.


<br>Shape Grammars: <a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=zCeqBV0Amm0" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=zCeqBV0Amm0" target="_blank">Procedural Building: Shape Grammars</a>

<br>Rule-based approach for generating architectural or structured designs.
<br>Example: Creating procedurally generated buildings or city layouts.


<br><br><img alt="GMAP 395/Module 1/Media/fractals.png" src="gmap-395\module-1\media\fractals.png" style="width: 320px; max-width: 100%;"><br>
<img alt="GMAP 395/Module 1/Media/noise.jpg" src="gmap-395\module-1\media\noise.jpg"><br><br><br>
<br>Nodes: Visual representation of workflows.
<br>Attributes: Define unique object behaviors.
<br>Randomization: Add variation for realism.
<br>Scalability: Efficiently create vast, dynamic environments.
<br>Practical Example:<br>
<br>Generate a forest:

<br>Use splines for paths.
<br>Scatter trees procedurally.
<br>Add random noise for variation.


<br><br><br>
<br>Overview:

<br>Infinite universe generated procedurally.


<br>Key Techniques:

<br>Procedural Terrain: Dynamic landscapes with varied biomes.
<br>Modular Assets: Ships, flora, and fauna built from reusable parts.
<br>Node-Based Workflows: Data-driven algorithms for content generation.


<br>Impact: Demonstrates the synergy of proceduralism and modularity for immersive exploration.<br><a data-tooltip-position="top" aria-label="https://www.rambus.com/blogs/the-algorithms-of-no-mans-sky-2/" rel="noopener nofollow" class="external-link" href="https://www.rambus.com/blogs/the-algorithms-of-no-mans-sky-2/" target="_blank">The algorithms of No Man’s Sky</a><br><br><br><br>
<br>Procedural Workflows: Automate and enhance creativity.
<br>Modularity: Reuse and optimize assets.
<br>Game Feel: Ensure tactile and immersive experiences.
<br>Tools and Techniques: Build scalable, dynamic, and engaging game worlds.
<br>Reflection Questions: <br>
<br>How will you apply procedural and modular techniques in your projects?
<br>How do node-based workflows enhance creativity and efficiency in game design?
<br>What are the advantages and challenges of combining proceduralism and modularity in a game project?
<br>Can you identify a game you’ve played that effectively uses procedural techniques? How did it enhance (or detract from) the gameplay experience?
<br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\gmap-395-wk-2-slides.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - WK 2 - Slides.md</guid><pubDate>Mon, 20 Jan 2025 19:17:08 GMT</pubDate><enclosure url="gmap-395\module-1\media\gamefeelcover.webp" length="0" type="image/webp"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-1\media\gamefeelcover.webp"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[<strong><em>Procedural Eldritch Portal + Environment: A Tutorial for Blender</em></strong>]]></title><description><![CDATA[ 
 <br><br><img alt="GMAP 395/Module 1/Media/395tut1portal.png" src="gmap-395\module-1\media\395tut1portal.png" style="width: 640px; max-width: 100%;"><br><br><br>In this tutorial, we will create a Procedural "Eldritch Portal" Environment Art, an ominous and glowing gateway surrounded by rocky terrain and organic tendrils. This project aims to integrates procedural modeling techniques and node-based workflows to craft a dynamic and mystical game-based environment artifact.<br><br>
<br>Understand the Geometry Nodes system in Blender.
<br>Apply procedural workflows to create modular and reusable assets.
<br>Explore node-based techniques for attributes like scattering, randomization, and deformation.
<br>Gain insight into exporting assets for game engines like Unity.
<br>Reminder: Documentation is your best friend!
<a rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/index.html" target="_blank">https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/index.html</a>
<br>Intro Video: <br>
[gmap395_tut1_intro.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_Ewtu7qaLOfP_oFTQ?e=Dfjfxw)<br><br><br><br><br>
<br>Open Blender and create a new project.
<br>Switch to the Geometry Nodes workspace.

<br>This can be found on the top toolbar.


<br>Add a Plane (Shift + A &gt; Mesh &gt; Plane) and assign a new Geometry Nodes modifier.
<br>Name your Geometry Nodes setup descriptively, e.g., Rocky_Base_Geo.<br><br><br>
<br>Adding Noise Deformation: Use a Noise Texture and Displacement Modifier to create an uneven, rocky surface.

<br>Let's start by subdividing our plan to allow for more detail when we apply a noise function. Create a Subdivide Mesh node and plug the Group Input's geometry output into the mesh input slot. Adjust the subdivision Level to 6. 
<br>Next let's scale our plane to make more room. Create a Transform Geometry node and plug the mesh output of the subdivide mesh not into geometry input. Adjust the Scale property(attribute) to a desired size; but keep int under 5 for now just to keep things speedy/snappy.
<br>Now we can work on applying some noise distortion so our plane look smore like a terrain. We will need the following nodes: Set Position, Position(Read) Combine XYZ, and a Noise Texture

<br>Plug the geometry out from the transform node into the geometry input of Set Position. The geometry output from this node will go into the Group Output geometry input.
<br>Plug the Position(Read) into the position input of Set Position. What this does is get the position of our plane and makes sure set position uses its current position.
<br>Now the vector output of the Combine XYZ node will go into the offset input of Set Position.
<br>Finally the color output of Noise Texture will go into the Z input of Combine XYZ.

<br>From here you can adjust the values of the parameters for the noise node to reach a desired look. For more on how this node works and what those parameters mean have a look the the <a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/texture/noise.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/geometry_nodes/texture/noise.html" target="_blank">noise texture node documentation</a>.




<br>For reference we are performing a noise deformation similar to this video: <a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=LmPhbfb2DH8" target="_blank">https://www.youtube.com/watch?v=LmPhbfb2DH8</a>


<br>Scattering Rocks: Now let's scatter some "rocks" by using Point Distribution to scatter stand-in geometry and vary the size by Randomizing Attributes.

<br>We'll add a Distribute Points on Faces node to the end of the chain. So, the geometry output from Set Position will go into the mesh input. This randomly scatters points onto the surface of our terrain geometry base. Use the Density and Seed values to adjust the amount of points.
<br>Next we will need an Instance on Points node and an Ico Sphere node. Take the points output of the distribute node and plug it into the points input of the Instance on Points node. This is assigning the points we generated as the points we will not copy(instance) more geometry onto.
<br>Now we need to adjust the size of our "rocks" so they look a bit more "natural" by randomizing the scale. You'll now need a Random Value(Float) and another Combine XYZ node. Plug the value output of the Random Value into the XYZ of the combine node. The vector output of this node will go into the scale input of the Instance Geometry node. 

<br>If you want you can duplicate this section and apply it to the rotation of the instance node to randomize the rotation too.


<br>Adjust the Min, Max, and Seed values to achieve a desired look.


<br>
Section Recap: Now you've got a basic terrain base and some rocks scattered along the surface. The scattering and rock scale are randomized to provide a more natural look. If you want to later, you can procedurally model some rocks and replate the basic primitive used as a stand-in.  
<br>
[gmap395_tut1_p1.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_Ev1DF4vxnCCHC5jw?e=fayUeZ)<br><br><br><br><br>
<br>Start with a Base Shape:

<br>Add a Bezier Circle (Shift + A &gt; Curve &gt; Circle) to represent the outer edge of your portal. Name it appropriately, like portal_base_geo. Now assign a new geometry node modifier to it in the Geometry Nodes context. This provides a smooth and flexible base for the portal geometry.
<br>Drop down and Curve to Points node and an Instance on Points node. Adjust the Count of the curve points node to a number you like, I started with default 10. Plug the points output into the points input of the instance node.
<br>Now we need some geometry to instance onto the points of our curve to start making the portals base structure. create Cube(Primitive) and a Transform Geometry node. the mesh output of the cube will go into the geometry input of the transform node.

<br>Adjust the Scale(XYZ) of the transform node to get cubes of a desired size/shape.


<br>As you may have noticed, the cubes are all around the circle but their rotation does not face the form of the curve, we will fix that now. Create an Align Rotation to Vector node. This node can read the Normals or Tangent of the vector direction of the points along the curve and we can then assign that rotation to another object, like the cubes.

<br>Take the Tangent output of the Curve to Points node and plug it into the Vector input of the align node.
<br>The parameter values on the Align Rotation to Vector node I found most helpful are to pick the X axis (below Rotation), and set the Pivot to Z.
<br>Now the Rotation output of the align nodes goes to the Rotation input of the  Instance on Points node.
<br>This process is similar to what is found in this video: <a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=J4RpyR3jN-U" target="_blank">https://www.youtube.com/watch?v=J4RpyR3jN-U</a>




<br><br>
<br>Creating additional portal stones:

<br>Now that we have some basic stones for the portal we can duplicate some nodes and run essentially the same/similar operations to create the second set of stones.
<br>Start by creating  a Transform Geometry node; we will use this to offset the rotation of our points later. 
<br>Now you can duplicate(copy and paste) the nodes and connections for all of the nodes we used in Part 2 - Step 1 from above. Connect the Geometry output of the transform node into the Curve input of the newly duplicated Curve to Points node.
<br>Now, keep all of the connections in tact from the nodes that were copied. We can now just go back into some of the nodes and adjust some parameters to get more of a stone portal look.

<br>Start with the Transform Geometry node and adjust the Rotation(Z)  offset the second set of cubes.
<br>Adjust the Scale(XYZ) of the cubes transform geometry node to make the smaller and a little longer in the second set.




<br>To See All Geometry
You will need to temporarily connect the Instances output from  both Instance to Points nodes into a Join Geometry node, then connect that to the Group Output.
<br><br>
<br>Apply Boolean Operations:

<br>Drop down a Mesh Boolean node. If you used a Join Geometry node to see all of the geometry together, you can delete that now.
<br>The Mesh Boolean node will allow us to perform a boolean operation using the two sets of cube/stones we made for the portal. In this case we will use Union as the operation type and tick on both Self Intersection and Hole Tolerant.
<br>Now plug the Instances outputs from both chains/trees Instance on Points into the Mesh input of the Mesh Boolean. This can now be plugged into the main Group Output node.


<br>Filling the Portal
If you with to have a circular plane to fill the void in the portal (maybe for doing a shader later on) you can use a Fill Curve node. Just connect a new edge from the geometry output of the main Group Input node to it and then connect the Mesh output to the Mesh input of the Mesh Boolean 
<br>
Section Recap: Boolean operations allow us to create complex shapes by combining or subtracting simpler ones. Here, we use the smaller set of geometry to combine with the larger set of geometry, forming the portal’s basic structure. Now, if you wish to later, you can model better stone using the cubes as a base to make the portal look better.
<br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_EuJDcode-o2D6LIA?e=rsBx7O" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_EuJDcode-o2D6LIA?e=rsBx7O" target="_blank">gmap395_tut1_p2.mp4</a><br><br><br><br><br><br>
<br>Define Tendril Paths:

<br>Add a Curve Line (Shift + A &gt; Curve &gt; Curve Line) and then add a Transform Geometry node to a new modifier context.
<br>Us the transform node to adjust the Rotation(X) to around -90 degrees. Now we will essentially be using nodes used earlier in this tutorial to construct the rest of the tendrils. Create a Curve to Points node and an Instance on Points node. Adjust the Count of the curve points node to a larger number number, like 30. Plug the points output into the points input of the instance node.
<br>We will need another Align Rotation to Vector node. Connect it like before, where the vector comes from the Curve to Points tangent output and the rotation output goes to the rotation input of the Instance to Points.
<br>Create another Mesh Boolean node and plug the Instances output from instance points into the Mesh input.

<br>You will need to set the boolean nodes parameters to Union and Exact respectively.


<br>


<br><br>
<br>Adding Tendrils to their place :

<br>We will use a Curve Circle node with a 0.5 Radius as a frame for the tendrils to be spawned on to. So, create this now.
<br>Then, use another Curve to Points node and Instance to Points node combo to create a 6 Count points and instance the tendrils onto those points. 

<br>Connect the Mesh output of the Mesh Boolean from earlier to the Instances input.


<br>You'll use another Align Rotation to Vector node to get the Tangent from the curve points to the vector input. Then the Rotation output from this node matches to the Rotation input of the Instance on Points.
<br>To create a more "natural" look we will add some random roatation so the tendrils are not all uniform. Grab a Random Value node set to Vector. Max value are 0.0, 0.1, and 1.90.

<br>The Value output goes to the Rotation input of a Rotate Instances node. This connects to the Instance on Points and the Group Output nodes. You can also use a Transform Geometry node to move all the tendrils into place.




<br>
[gmap395_tut1_p3.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_EtzgD0ilFKv0Moww?e=JO4ROa)<br><br><br>Optimization and Export
We will do the optimization and mesh export in week 3 before importing to Unity. Just be sure to have some procedural game art ready to go.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\gmap-395-wk-2-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - WK 2 - Tutorial.md</guid><pubDate>Mon, 20 Jan 2025 19:16:51 GMT</pubDate><enclosure url="gmap-395\module-1\media\395tut1portal.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-1\media\395tut1portal.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 2 - Video Lecture]]></title><description><![CDATA[ 
 <br><br><a data-tooltip-position="top" aria-label="[gmap395_wk2.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_EnKYcs_oFzmZB0Sg?e=abV2gc)" rel="noopener nofollow" class="external-link" href="[gmap395_wk2.mp4](https:\\1drv.ms\v\s!AqQzGx8l4o2wk_EnKYcs_oFzmZB0Sg?e=abV2gc)" target="_blank">Video Link</a><br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\gmap-395-wk-2-video-lecture.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - WK 2 - Video Lecture.md</guid><pubDate>Fri, 17 Jan 2025 19:49:10 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 3 - Slides]]></title><description><![CDATA[ 
 <br><br><br><br><a data-tooltip-position="top" aria-label="[gmap395_wk3.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_FWfbFNa6ud6HX0Eg?e=LHB4am)" rel="noopener nofollow" class="external-link" href="[gmap395_wk3.mp4](https:\\1drv.ms\v\s!AqQzGx8l4o2wk_FWfbFNa6ud6HX0Eg?e=LHB4am)" target="_blank">Week 3 Video Lecture Link</a>

<br><br><br>
<br>Purpose of Lighting:

<br>Enhance mood and atmosphere.
<br>Guide the player’s attention.
<br>Improve visual clarity and realism.
<br>Communicate gameplay mechanics and objectives.
<br>Balance aesthetics with performance.


<br><br><br>
<br>Quality: Determines how light interacts with surfaces.

<br>Example: Realistic shadows, soft light falloffs.


<br>Quantity: The intensity and coverage of light.

<br>Example: Brightness levels and area of influence.


<br>Direction: The angle and position of light.

<br>Example: Backlighting for dramatic silhouettes.


<br><br><br><br>
<br>Understanding Quality:

<br>High-quality lighting enhances immersion with realistic shadows and nuanced illumination.
<br>Balancing quality ensures performance optimization.


<br>Managing Quantity:

<br>Excessively bright or dim lighting can confuse players.
<br>Adjust light intensity to fit the scene’s tone and function.


<br>Using Direction Effectively:

<br>Side or top-down lighting can highlight textures or contours.
<br>Directional lighting aids in visual storytelling.


<br><br><br><br>
<br>Direct Lighting: Hits surfaces directly.
<br>Indirect Lighting: Bounces light off surfaces.
<br>Ambient Lighting: General illumination without a specific source.
<br>Emissive Lighting: Objects emit their own light.
<br>Global Illumination (GI): Simulates realistic light interactions through bounces.
<br><a data-tooltip-position="top" aria-label="https://www.adobe.com/products/substance3d/discover/what-is-global-illumination.html#:~:text=Global illumination is a feature,doesn't look very realistic." rel="noopener nofollow" class="external-link" href="https://www.adobe.com/products/substance3d/discover/what-is-global-illumination.html#:~:text=Global%20illumination%20is%20a%20feature,doesn't%20look%20very%20realistic." target="_blank">A guide to global illumination - ADOBE </a><br><br><br><br>
<br>General Principles:

<br>All game engines rely on similar principles for rendering lighting.
<br>Systems like lightmaps, probes, and dynamic adjustments are ubiquitous.


<br>Implementation Tips:

<br>Always profile lighting performance.
<br>Utilize modular workflows for scalability when needed/possible.


<br><br><br>
<br>Directional Light: Simulates sunlight, infinite reach.
<br>Point Light: Emits light uniformly in all directions.
<br>Spot Light: Creates a cone-shaped beam.
<br>Area Light: Illuminates a specific area (baked only).
<br><a data-tooltip-position="top" aria-label="https://book.leveldesignbook.com/process/lighting" rel="noopener nofollow" class="external-link" href="https://book.leveldesignbook.com/process/lighting" target="_blank">The Level Design Book - Lighting</a><br><br><br>
<br>Dynamic Lighting: Updates continuously, ideal for interactive or changing environments.
<br>Static Lighting: Pre-calculated for non-interactive elements to reduce processing.
<br>Hybrid Systems: Combine dynamic and static methods for optimized results.
<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/6000.0/Documentation/Manual/LightModes-introduction.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/6000.0/Documentation/Manual/LightModes-introduction.html" target="_blank">Unity Documentation on "Light Modes"</a><br><br><br>
<br>Limit Realtime Lights: Use baked lighting wherever possible.
<br>Leverage Mixed Lighting: Combine dynamic and static lighting.
<br>Light Probes: Optimize lighting for dynamic objects.
<br>Reflection Probes: Simulate realistic reflections.
<br>Profile Lighting Costs: Regularly monitor performance impact.
<br><a data-tooltip-position="top" aria-label="https://vintay.medium.com/difference-between-realtime-mixed-and-baked-lighting-in-unity-6bda1f24bfb" rel="noopener nofollow" class="external-link" href="https://vintay.medium.com/difference-between-realtime-mixed-and-baked-lighting-in-unity-6bda1f24bfb" target="_blank">Difference Between Realtime, Mixed, And Baked Lighting in Unity</a><br>See again (<a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=04YUZ3bWAyg" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=04YUZ3bWAyg" target="_blank">Global Illumination in Tom Clancy's The Division</a>)<br><br><br>
<br>Baking Systems: Pre-render static lights for better performance.
<br>Volumetric Effects: Add atmospheric depth with fog and light scattering.
<br>Custom Shaders: Fine-tune light interactions for specific materials.
<br>Node-Based Workflows and Code: Use visual tools for procedural lighting systems.
<br><br><br>
<br>Day/Night Cycles: Transition lighting over time to match environmental storytelling.
<br>Interactive Lighting: Lights that respond to player actions or environmental triggers.
<br>Color and Intensity Shifts: Create mood transitions or dramatic effects.
<br><br><br>
<br>Guidance: Direct player attention to objectives.

<br>Example: Highlight interactable objects or paths.


<br>Atmosphere: Build tension or mood.

<br>Example: Dim, flickering lights in a horror game.


<br>Puzzle Elements: Use light as an integral component of gameplay challenges.

<br>Example: Reflective surfaces or light-activated mechanisms.


<br><br><br><br>
<br>Layered Lighting: Combine ambient, direct, and dynamic sources for depth.
<br>Color Theory in Lighting: Use color to evoke emotions or set the scene’s tone.
<br>Light-Based Storytelling: Subtle shifts in lighting to hint at narrative progression.
<br><br><br>
<br>LOD Systems: Adjust lighting details based on distance.
<br>Render Pipelines (Graphics Pipeline): Use advanced pipelines for better control.
<br>Post-Processing: Enhance visuals without additional light sources.
<br><a data-tooltip-position="top" aria-label="https://www.geeksforgeeks.org/opengl-rendering-pipeline-overview/" rel="noopener nofollow" class="external-link" href="https://www.geeksforgeeks.org/opengl-rendering-pipeline-overview/" target="_blank">OpenGL Rendering Pipeline | An Overview</a><br>
<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Graphics_pipeline" rel="noopener nofollow" class="external-link" href="https://en.wikipedia.org/wiki/Graphics_pipeline" target="_blank">Graphics Pipelines</a><br><br><br><br><br>
<br>Emotion and Atmosphere:

<br>Colors evoke specific emotions and set the tone of a scene.
<br>Example: Warm colors like orange and red convey energy or danger, while cool colors like blue and green suggest calm or mystery.


<br>Player Guidance:

<br>Bright or contrasting colors naturally draw attention to key gameplay elements.
<br>Example: A glowing blue portal in a dimly lit room.


<br><br><br>
<br>Hue, Saturation, and Value (HSV):

<br>Hue: The color itself (e.g., red, blue, yellow).
<br>Saturation: The intensity or purity of the color.
<br>Value: The brightness or darkness of the color.


<br>Color Harmony:

<br>Complementary Colors: Opposite on the color wheel (e.g., blue and orange) create contrast.
<br>Analogous Colors: Side-by-side on the wheel (e.g., red, orange, yellow) create harmony.
<br>Triadic Colors: Equally spaced around the wheel for balance (e.g., red, yellow, blue).


<br>Color Temperature:

<br>Warm Colors: Reds, yellows, and oranges evoke energy and warmth.
<br>Cool Colors: Blues and greens create calm or distance.


<br><br><br><br><br>
<br>A previsualization tool that maps out the emotional journey of a game using color.
<br>Often used in animated films and games to ensure consistency and coherence in visual storytelling.
<br><br>
<br>Break down the game or level into key moments or scenes.
<br>Assign a dominant color palette to each moment based on its mood or theme.

<br>Example: Use red hues for high-intensity battles and softer blues for reflective or quiet moments.


<br>Create thumbnail sketches or storyboards with approximate lighting and color.
<br><a data-tooltip-position="top" aria-label="https://photography.tutsplus.com/tutorials/how-to-colourscripts-animation--cms-38391" rel="noopener nofollow" class="external-link" href="https://photography.tutsplus.com/tutorials/how-to-colourscripts-animation--cms-38391" target="_blank">How to Make a Color Script</a><br>
<a data-tooltip-position="top" aria-label="https://www.khanacademy.org/computing/pixar/art-of-lighting/introduction-to-virtual-lighting/a/exercise-5-color-scripts" rel="noopener nofollow" class="external-link" href="https://www.khanacademy.org/computing/pixar/art-of-lighting/introduction-to-virtual-lighting/a/exercise-5-color-scripts" target="_blank">Color Scripting - Khan Academy</a><br><br><br><br>
<br>Color Temperature in Lighting:

<br>Use warm light for natural, inviting environments (e.g., sunlight or firelight).
<br>Use cool light for sterile or eerie settings (e.g., moonlight or fluorescent light).


<br>Color Grading in Post-Processing:

<br>Adjust the overall tone of a scene to emphasize mood.
<br>Example: Desaturate colors for a bleak, dystopian setting or enhance vibrancy for fantastical worlds.


<br>Dynamic Color Shifts:

<br>Change lighting color dynamically to reflect gameplay events or mood shifts.
<br>Example: A room flooding with red light during an alarm.


<br><br><br><br>
<br>Platform: High-spec PC and consoles (PS4/PS5, Xbox One/Series).
<br>Lighting Techniques Used:

<br>Dynamic Lighting: Utilizes real-time ray tracing for accurate reflections, shadows, and indirect lighting. Light changes dynamically as the player interacts with the environment or moves through different spaces.
<br>Global Illumination: Achieved through ray tracing to simulate realistic light bounces, enhancing immersion in its moody, supernatural world.
<br>Volumetric Lighting: Used extensively to create atmospheric effects like light beams filtering through dust or fog, amplifying the game's eerie tone.


<br>Optimization Techniques:

<br>Ray tracing is scaled back on lower-end systems by using approximations or turning off certain effects while maintaining the overall mood.
<br>Selective use of baked lighting for static geometry.


<br><br><br><br>
<br>Platform: Mobile devices.
<br>Lighting Techniques Used:

<br>Baked Lighting: Pre-calculated lightmaps are used for all scenes, ensuring the game runs smoothly on low-power devices while maintaining visual appeal.
<br>Ambient Occlusion: Baked into textures to give depth and definition to the minimalist geometric environments.
<br>Color as Light: Simple, vibrant color palettes imply lighting and shadow, reducing computational overhead while creating an artistic, dreamlike aesthetic.


<br>Optimization Techniques:

<br>Fixed camera angles and static environments allow for efficient pre-rendering.
<br>Minimal reliance on dynamic lights, focusing instead on artistic use of gradients and shading.


<br><br><br><br><br><br>
<br>How does each game leverage its lighting strategy to create a distinct mood and enhance the player experience?
<br>What challenges might developers face when scaling the lighting approach for different platforms or performance tiers?
<br>How do the artistic and technical choices in each game reflect the limitations or opportunities of their respective platforms?
<br><br><br><br>
<br>Use baked lighting for static elements.
<br>Add light probes for dynamic objects.
<br>Profile scene with Unity’s Profiler.
<br><br>
<br>Add spotlights to key areas.
<br>Use color grading for mood.
<br>Implement dynamic light triggers for interactivity.
<br><br><br>
<br>Lighting Attributes: Quality, quantity, direction.
<br>Optimization Tools: Lightmaps, probes, and profiling.
<br>Dynamic Techniques: Time-of-day, animated lights, interactive systems.
<br>Gameplay Integration: Light as a mechanic for guidance and immersion.
<br><br><br><br>
<br>Lighting Principles Are Universal: The same concepts apply across all major engines and tools.
<br>Always Iterate: Refine lighting to balance performance and aesthetics.
<br>Stay Curious: Explore how other games use light to innovate.
<br><br><br>
<br>How does lighting influence player decision-making?
<br>What challenges arise when balancing performance with high-quality lighting?
<br>How can you apply these concepts across different game engines or tools?
<br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 1" data-href="GMAP 395 - Module 1" href="gmap-395\module-1\gmap-395-module-1.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-1\gmap-395-wk-3-slides.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - WK 3 - Slides.md</guid><pubDate>Mon, 20 Jan 2025 19:17:15 GMT</pubDate><enclosure url="gmap-395\module-1\media\6492c4abf65d6e4dfffbb89e_control_worldtrailer_quarry_sky-p-500.avif" length="0" type="false"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-1\media\6492c4abf65d6e4dfffbb89e_control_worldtrailer_quarry_sky-p-500.avif"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Lab Exercise: Lighting, Post-Processing, and Dynamic Camera in Unity URP]]></title><description><![CDATA[ 
 <br><br><br>In this lab, you'll create a simple 3D scene using the Universal Render Pipeline (URP), apply basic lighting techniques and a dynamic day-night cycle that affects gameplay and mood. This scene will be incorporating you Procedural Game Art Asset from Module 1 - Part 1.<br><br>
<br>Unity 2022.3 LTS or later
<br>Basic familiarity with the Unity interface
<br>Basic familiarity with C# scripting in Unity
<br><br><br><br><br><br>We will need to do some very simple <a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/meshes/retopology.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/meshes/retopology.html" target="_blank">Retopology</a> in blender with out geometry then apply some simple <a data-tooltip-position="top" aria-label="https://docs.blender.org/manual/en/latest/modeling/meshes/uv/index.html" rel="noopener nofollow" class="external-link" href="https://docs.blender.org/manual/en/latest/modeling/meshes/uv/index.html" target="_blank">UVs</a> before we export and import into Unity.<br><br>Modularity and Reuse
We will be doing the following operations to all of our procedural geometry. So just pick one object from Part 1 and and follow along (e.g. start with tendrals_base_geo).
<br>For this portion of the tutorial watch and follow along with the video from Entagma, on doing the Retopology and UV Unwrapping procedurally using geometry nodes. You will apply this same process to all sections of the procedural game art from Part 1. <br>Blender Tutorial: Procedural UV Unwrapping with Geometry Nodes

<a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=02XNGOVpSV4" target="_blank">https://www.youtube.com/watch?v=02XNGOVpSV4</a>
<br>Types of Retopology
It is important to note that we are aiming for a quick version of retopology that is rapid for our prototyping in this course. IF you were going to work on retopology for animation, it would be best to do a more traditional method like Quad Remeshing with some manual retopology. Like in this video: <a rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=hQ8HvDuSWCQ" target="_blank">https://www.youtube.com/watch?v=hQ8HvDuSWCQ</a>
<br><br>
<br>
Create a new URP 3D Unity project.

<br>When creating a new project, select "3D (URP)" as the template.


<br>
In the Hierarchy window, right-click and select 3D Object &gt; Plane to create a ground plane. ONLY IF NEEDED.

<br><br>If using Blender Geometry Nodes, to properly export that geometry to a useful data format like FBX or glTF. You will need to first Realize Instances then Apply the geometry modifiers to make a static piece of geometry in Blender. You can see this is action in Part 2 from the Video Tutorials above.<br><br><br><a rel="noopener nofollow" class="external-link" href="https://blender.community/c/rightclickselect/G9Jy/?sorting=hot" target="_blank">https://blender.community/c/rightclickselect/G9Jy/?sorting=hot</a><br>Tip
Use different materials for each object to make them visually distinct. Select each object, create a new material (right-click in Project window &gt; Create &gt; Material), and set a unique color in the Inspector. Make sure to use the "Universal Render Pipeline/Lit" shader for these materials.
<br><br><br>
<br>
The default URP project comes with a Directional Light. Adjust its settings:

<br>Set the Directional Light rotation to (50, -30, 0) and reduce its Intensity to 0.5.


<br>
Create two additional lights:

<br>Create a Point Light (GameObject &gt; Light &gt; Point Light)
<br>Create a Spot Light (GameObject &gt; Light &gt; Spot Light)


<br>
Configure the lights:

<br>Position the Point Light at (0, 3, 0) and set its Range to 10. Set intensity to 5
<br>Position the Spot Light at (-5, 5, -5), rotate it to (45, 45, 0), and set its Range to 15 and Spot Angle to 30. Set intensity to 35
<br>Set all of the lights' Mode to Mixed in their Light component settings.<br>
<img alt="lightingMode.png" src="gmap-395\module-1\media\lightingmode.png">


<br>Connection to Lecture
Each Light type serves a specific purpose in lighting your scene. The Directional Light acts as your main light source (like the sun), while Point and Spot Lights add depth and focus to specific areas.
<br>
<br>Experiment with light colors:

<br>Set the Directional Light to a warm color (e.g., FFF4E0).
<br>Set the Point Light to a cool blue color (e.g., ADD8E6).
<br>Set the Spot Light to a subtle purple (e.g., 8A2BE2).<br>
<img alt="colorHexCode.png" src="gmap-395\module-1\media\colorhexcode.png">
Tip
Use color theory to create mood and depth in your scene. Warm colors tend to advance (appear closer), while cool colors recede (appear farther away).




<br><br><br>
<br>
Create a new empty GameObject and name it "DayNightController".

<br>
Add a new script to this object, also named "DayNightController".

<br>
Open the script and add the following code:

<br>using UnityEngine;

public class DayNightController : MonoBehaviour
{
    public Light sunLight;
    public float dayDuration = 60f; // One day every 60 seconds
    
    public float timeOfDay = 0.25f; // Start at 6:00 AM

    void Update()
    {
        timeOfDay += Time.deltaTime / dayDuration;
        if (timeOfDay &gt;= 1f) timeOfDay -= 1f;

        float sunRotation = timeOfDay * 360f;
        sunLight.transform.rotation = Quaternion.Euler(sunRotation, 230f, 0);
    }
}
<br>
<br>Create a Directional Light for the sun (only if one does not already exist) and assign it to the sunLight variable in the DayNightController component.
<br><img alt="sunLight.png" src="gmap-395\module-1\media\sunlight.png"><br>Sun Position
The sun's starting rotation of (90, 230, 0) positions it in the east at the start of the day.
<br><br>
<br>Modify the DayNightController script to change the sun's color based on the time of day:
<br>public class DayNightController : MonoBehaviour
{
    // ... previous code ...

    public Gradient sunColor;

    void Update()
    {
        // ... previous update code ...

        sunLight.color = sunColor.Evaluate(timeOfDay);
    }
}
<br>
<br>In the Inspector, set up the color gradient for the sun:

<br>Morning: Soft orange
<br>Midday: Bright white
<br>Evening: Deep orange
<br>Night: Dark blue


<br><img alt="sunColor.png" src="gmap-395\module-1\media\suncolor.png"><br>Color Selection
Use warm colors for sunrise/sunset and cool colors for night to create a more realistic atmosphere.
<br>
<br>Extend the DayNightController script to modify the sun's intensity:
<br>public class DayNightController : MonoBehaviour
{
    // ... previous code ...
    public AnimationCurve lightIntensityCurve;

    void Update()
    {
        // ... previous update code ...
        
        // Update sun intensity
        float intensityMultiplier = lightIntensityCurve.Evaluate(timeOfDay);
        sunLight.intensity = intensityMultiplier * 1.5f; // Base intensity of 1.5
    }
}
<br>
<br>In the Inspector, set up the Light Intensity Curve:

<br>Create an AnimationCurve with the following key points:

<br>Time 0.0 (Midnight): Value 0.1
<br>Time 0.25 (Sunrise): Value 0.8
<br>Time 0.5 (Noon): Value 1.0
<br>Time 0.75 (Sunset): Value 0.8
<br>Time 1.0 (Midnight): Value 0.1




<br><img alt="sunIntensity.png" src="gmap-395\module-1\media\sunintensity.png"><br>Light Intensity
The intensity curve allows for smooth transitions between day and night, with peak brightness at noon and minimum at midnight.
<br>
<br>Adjust the base intensity (1.5f in the example) to fit your scene's lighting needs.
<br>Fine-tuning
Experiment with different intensity values and curve shapes to achieve the desired lighting effect for your specific environment.
<br><br><br>
<br>
Open the Lighting window:

<br>Go to Window &gt; Rendering &gt; Lighting


<br>
Familiarize yourself with the Lighting window:

<br>Scene: Contains general lighting settings for the current scene
<br>Environment: Controls skybox and ambient lighting and fog
<br>Realtime Lightmaps: Shows real-time lightmaps
<br>Baked Lightmaps: Shows baked lightmaps


<br>Connection to Lecture
The Lighting window is your central hub for controlling global lighting settings and baking lightmaps.
<br><img alt="lightingWindow.png" src="gmap-395\module-1\media\lightingwindow.png"><br>
<br>
Create a Lighting Settings Asset:

<br>In the Lighting window, click "New" next to "Lighting Settings Asset"
<br>Save it as "MainLightingSettings" in your project's Settings folder


<br>
Configure Lighting Settings:

<br>In the Scene section

<br>Create a new Lighting Settings Asset

<br>Name it "LightSettings_" + your scene name 


<br>Turn on Realtime Global Illumination

<br>Adjust Indirect Resolution to 2 Texels Per Unit




<br>In the Environment section:

<br>Set Skybox Material to "Default-Skybox"
<br>Change Sun Source to your scene Directional Light


<br>In the Mixed Lighting section:

<br>Set Lighting Mode to "Baked Indirect"


<br>In the Lightmapping Settings section:

<br>Set Lightmapper to "Progressive GPU (Preview)"
<br>Leave the default settings for now. You can adjust with these later.




<br>
Open the Light Explorer:

<br>Go to Window &gt; Rendering &gt; Light Explorer
<br>The Light Explorer has taps to access quick settings changes for Lights, 2D Lights, Reflection Probes, Light Probes, and Static Emissives.


<br>
Use the Light Explorer to quickly adjust multiple lights:

<br>Review and adjust thing like the Mode, Intensity, and Range of your lights among other settings.


<br>Tip
The Light Explorer is excellent for getting an overview of all lights in your scene and making bulk adjustments.
<br><img alt="lightExplorer.png" src="gmap-395\module-1\media\lightexplorer.png"><br>
<br>
Prepare for lightmap baking:

<br>Select all static objects in your scene (ground plane and any non-moving objects)
<br>In the Inspector, check "Static" at the top
<br>Expand the Static dropdown and ensure "Contribute Global Illumination (Contribute GI)" is checked


<br>
Generate lighting:

<br>In the Lighting window, scroll to the bottom
<br>Click "Generate Lighting"
<br>Wait for the baking process to complete


<br>Important
Lightmap baking can take some time, especially for complex scenes. Be patient!
<br>Warning
It is not recommended to tick on Auto Generate. This is because lighting will constantly cook anytime a change is made. For very large scene with Mixed or Baked lighting, this can take hours and slows down the Unity Editor.
<br>
<br>Review the results:

<br>Once baking is complete, examine your scene in both the Scene and Game views
<br>Look for any areas where the lighting seems off or could be improved


<br><br><br>
<br>
Create a new material:

<br>In the Project window, right-click &gt; Create &gt; Material
<br>Name it "EmissiveMaterial"


<br>
Configure the emissive material:

<br>Select the EmissiveMaterial in the Project window
<br>In the Inspector, ensure the Shader is set to "Universal Render Pipeline/Lit"
<br>Scroll down to the Emission section
<br>Check the "Emission" box to enable it
<br>Click the color picker next to Emission to choose a color (e.g., a bright blue 00FFFF)
<br>Set the Emission color Intensity to 2 (you can adjust this value to increase or decrease the glow intensity)


<br>
Apply the emissive material:

<br>Drag the EmissiveMaterial onto the Sphere in your scene.
<br>Place another primitive object close to the sphere with the emissive material applied.


<br>How Emissive Materials Work
Emissive materials simulate light-emitting surfaces. They don't actually emit light that affects other objects in real-time, but they appear to glow and can contribute to the overall lighting of the scene when lighting is generated.
<br><img alt="emissiveMat.png" src="gmap-395\module-1\media\emissivemat.png"><br>
<br>
Observe the difference in Realtime vs Baked lighting: For Realtime:

<br>The emissive object will appear to glow.
<br>If the object is marked as "Static" in the Inspector, it can contribute to real-time Global Illumination (GI).
<br>Open the Light Explorer (Window &gt; Rendering &gt; Light Explorer) and ensure the emissive object has "Contribute Global Illumination" checked.
<br>Non-static (dynamic) emissive objects will not affect GI but will still glow.

For Baked:

<br>Make sure the Sphere is marked as "Static" in the Inspector.
<br>In the Lighting window, under Baked Lightmaps, ensure "Baked Global Illumination" is enabled.
<br>Click "Generate Lighting" to bake the lighting.


<br>Emissives and Global Illumination In both realtime and baked scenarios, static emissive materials can contribute to global illumination, subtly lighting nearby surfaces. This creates a more realistic and integrated lighting effect. However, moving (dynamic) emissive objects are not supported.<br>Performance Consideration Realtime GI from emissive materials can be performance-intensive. For mobile or performance-critical projects, consider using baked lighting or limiting the use of emissive materials that contribute to realtime GI.<br>
<br>
Experiment with static vs dynamic emissive objects:

<br>Create a copy of your emissive sphere and place it in the scene.
<br>Keep one sphere marked as "Static" and the other unmarked.
<br>Compare how they interact with the environment in both realtime and baked lighting scenarios.


<br>
Iterate and refine:

<br>Adjust light settings, object materials, or lightmapping settings as needed
<br>Regenerate lighting after making significant changes


<br>Connection to Lecture
Baked lighting is crucial for performance in many games, especially on mobile or VR platforms. It allows for complex lighting scenarios without the performance cost of real-time lights.
<br>Experiment
Try adjusting the light positions, intensities, and colors. See how these changes affect the mood of your scene. Also, experiment with different post-processing settings to achieve various visual styles.
<br><br><br>Post Processing Lesson
We will revisit Post Processing at a later time in the course in more detail, for now, we need it to comprehend Emissive Materials and how they affect lighting.
<br>
<br>
Set up the Post-Processing Volume:

<br>Create a Global Volume (GameObject &gt; Volume &gt; Global Volume)


<br>
Create a Post-Processing Profile:

<br>Create a Rendering folder in your Project window.
<br>In the Project window, right-click &gt; Create &gt; Volume Profile.
<br>Name it "Main Profile".
<br>Drag this profile into the Profile slot of your Global Volume component.


<br>
Add and configure effects:

<br>Select the "Main Profile" in the Project window.
<br>Click Add Override and add the following:

<br>Bloom
<br>Color Adjustments (URP uses this instead of Color Grading)
<br>Vignette




<br>
Configure the effects:

<br>Bloom: Set Intensity to 1 and Threshold to 0.9.
<br>Color Adjustments: Change Contrast to 10 and Saturation to 10. Give the Color Filter a slightly warmer or cooler tone using the color picker.
<br>Vignette: Set Intensity to 0.4 and Smoothness to 0.3.<br>
<img alt="globalVolume.png" src="gmap-395\module-1\media\globalvolume.png">


<br>Connection to Lecture
Post-processing effects are applied after the scene is rendered, similar to filters in photo editing software. They can dramatically enhance the mood and style of your game.
<br>
<br>Enable post-processing on the camera:

<br>Select the Main Camera in the Hierarchy.
<br>Ensure it has a "Universal Additional Camera Data" component.
<br>Under the Rendering section tick on Post Processing
<br>In this component, set "Render Type" to "Base" if it isn't already.<br>
<img alt="cameraPP.png" src="gmap-395\module-1\media\camerapp.png">


<br>Important
If you don't see any change, ensure that your Scene View is set to have Post-Processing turned on using the top right hotbar.
<br><br>
<br>
Create a Light Probe Group:

<br>In the Hierarchy, right-click &gt; Light &gt; Light Probe Group


<br>
Position Light Probes:

<br>With the Light Probe Group selected, you'll see spheres in the scene view
<br>Position these spheres around your scene, focusing on areas where dynamic objects will move. 
<br>Select the Light Probe Group in the Hierarchy. In the Inspector, click Edit Light probe Positions. You can now move the yellow spheres.
<br>Place probes near corners, under overhangs, and in open areas. Anywhere where moving objects or better lighting data is needed.
<br>Aim for a good coverage without overdoing it (start with about 8-10 probes for our small scene)


<br><img alt="editLightProbe.png" src="gmap-395\module-1\media\editlightprobe.png"><br>Light Probe Placement
Think of light probes as sampling points for lighting. Place them where you want dynamic objects to pick up lighting information, especially in areas with significant lighting changes or dynamic objects.
<br>
<br>
Create a dynamic object:

<br>Add a new cube to your scene (GameObject &gt; 3D Object &gt; Cube)
<br>Position it slightly above the ground plane
<br>Ensure it's not marked as Static in the Inspector


<br>
Set up a simple movement script:

<br>Create a new script called "ObjectMover"
<br>Add this script to your new cube
<br>Open the script and replace its contents with:


<br>using UnityEngine;

public class ObjectMover : MonoBehaviour
{
    public float speed = 2f;
    public float distance = 4f;

    private Vector3 startPosition;

    void Start()
    {
        startPosition = transform.position;
    }

    void Update()
    {
        float newX = startPosition.x + Mathf.Sin(Time.time * speed) * distance;
        transform.position = new Vector3(newX, transform.position.y, transform.position.z);
    }
}
<br>
<br>
Bake lighting:

<br>Ensure your static objects are marked as Static
<br>Open the Lighting window (Window &gt; Rendering &gt; Lighting)
<br>Click "Generate Lighting" to bake your lightmaps and light probes


<br>
Observe the results:

<br>Play the scene and watch how the moving cube picks up lighting information from the probes
<br>The cube should show smooth lighting transitions as it moves through different areas of your scene


<br>Light Probes and URP
In URP, Light Probes work seamlessly with the scriptable render pipeline, providing efficient lighting for dynamic objects in both forward and deferred rendering paths.
<br>
<br>Experiment with probe placement:

<br>Try adding more probes or adjusting their positions
<br>Rebake lighting and observe how it affects the lighting on your moving cube


<br>Performance Consideration
While Light Probes are more performance-friendly than real-time lighting, too many probes can increase memory usage and baking times. Start with a minimal set and add more only where needed.
<br>
<br>Combine with emissive materials:

<br>Try placing some light probes near your emissive object from the previous sections
<br>Observe how the moving cube picks up the glow from the emissive object as it passes nearby


<br><br><br>
<br>
Add a Sphere your scene and ensure it is set to Static

<br>
Create a highly reflective material for the sphere. Something with full Metallic Map and Smoothness should work.<br>
<img alt="metalMaterial.png" src="gmap-395\module-1\media\metalmaterial.png">

<br>
Add a reflection probe to your scene:

<br>Right-click &gt; Light &gt; Reflection Probe
<br>Generally, place probes in key areas of your environment (e.g., near water bodies, in the center of clearings) where accurate reflections are needed. 

<br>Place this probe around the sphere with the reflective material.




<br>
Configure the Reflection Probe:

<br>Set the Type to Realtime
<br>Set Refresh Mode to Every Frame
<br>Adjust the Box Size to cover the desired area


<br>Real-time Reflection Probes
Setting the Reflection Probe to update every frame ensures that it will always reflect the current state of your scene, including changes in lighting from the day/night cycle. However, be aware that this can be performance-intensive, especially for larger or more complex scenes.
<br>
<br>(Optional) For performance optimization, you can adjust the Time Slicing setting:

<br>Set Time Slicing to All Faces At Once for immediate updates (more performance-intensive)
<br>Or choose "Individual Faces" to spread the update over multiple frames (better performance, slight delay in reflections)


<br>Performance Considerations
If you notice performance issues, consider reducing the update frequency or using a mix of real-time and baked probes in your scene. You can also adjust the resolution of the probe to balance between quality and performance.
<br>Reflection Probes
Reflection probes will now update as the day-night cycle progresses, providing dynamic reflections that match the changing lighting conditions.
]]></description><link>gmap-395\module-1\gmap-395-wk-3-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 1/GMAP 395 - WK 3 - Tutorial.md</guid><pubDate>Wed, 22 Jan 2025 16:15:57 GMT</pubDate><enclosure url="gmap-395\module-1\media\lightingmode.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-1\media\lightingmode.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Module 1]]></title><description><![CDATA[ 
 ]]></description><link>gmap-395\module-1\module-1.html</link><guid isPermaLink="false">GMAP 395/Module 1/Module 1.md</guid><pubDate>Mon, 20 Jan 2025 19:16:44 GMT</pubDate></item><item><title><![CDATA[media]]></title><description><![CDATA[ 
 ]]></description><link>gmap-395\module-2\media\media.html</link><guid isPermaLink="false">GMAP 395/Module 2/media/media.md</guid><pubDate>Mon, 27 Jan 2025 14:35:58 GMT</pubDate></item><item><title><![CDATA[Assignment 2: Dynamic Shaders and Materials]]></title><description><![CDATA[ 
 <br><br><br>Assignment Overview  
In this assignment, students will:

<br>Develop custom shaders and materials for the procedural game asset created in Assignment 1.
<br>Use Unity's Shader Graph or a similar node-based tool to create dynamic, real-time effects (must be displayed in Unity).
<br>Ensure shaders and materials enhance the asset’s presentation, aligning with the class theme: Something from the Void.
<br>Present the final shaders in a Unity scene and document the process in a README file.

<br><br><br>Assignment Breakdown

<br>Part 1: Shader Creation<br>
Design and implement dynamic shaders to achieve real-time visual effects for your asset.
<br>Part 2: Interactive Material Application<br>
Use the shaders and materials from Part 1, to create a real-time feedback based on a game event.

<br><br><br><br>Shader Inspiration from the Void  
Explore the theme by crafting shaders and materials that evoke mystery, emptiness, or cosmic energy. Examples include:

<br>A swirling galaxy effect on a portal or artifact.
<br>A glowing material with pulsating patterns and emissive highlights.
<br>Transparency effects to mimic glass-like or ethereal surfaces.

<br><br><br>Key Steps for Part 1

<br>Use Unity Shader Graph or a compatible node-based shader tool.
<br>Develop shaders that include at least two of the following techniques:

<br>Transparency or Opacity Masks: Create layered effects or partial visibility.
<br>Emissive Effects: Add glowing patterns or highlights.
<br>Procedural Textures: Use noise or gradients for dynamic surface details.
<br>Animation: Introduce movement, such as shifting patterns or pulsating effects.


<br>Apply the shaders to your procedural asset from Assignment 1.
<br>Test the shaders in Unity to ensure real-time performance.

<br><br>Key Steps for Part 2

<br>Use exposed shader parameters and C# in Unity to created real-time feedback.
<br>Further develop your shaders and materials for:

<br>Game-based Interaction: React to lighting, proximity, or player actions.


<br>Adjust material properties for optimal presentation:

<br>Set parameters for color, intensity, transparency, and more.


<br>Design the Unity scene to showcase the material effects:

<br>Add secondary lights, adjust post-processing (bloom), and environmental elements for context.



<br>Shader Design Tips

<br>Use color theory and emissive settings to emphasize the void theme.
<br>Combine procedural noise and gradient ramps to create abstract patterns.
<br>Test your shaders with different lighting conditions to ensure versatility.

<br><br><br>What to Submit

<br>README File:

<br>A Markdown, TXT, or PDF file that explains your work:

<br>Shader design techniques and inspirations.
<br>Material setup and Unity scene configuration.
<br>Challenges encountered and solutions implemented.




<br>Recorded Video (5–10 Minutes):

<br>A Screen Recorded video walkthrough showcasing:

<br>Record the Unity Scene and any other relevant DDC application used
<br>Shader effects and how they align with the theme.
<br>Material application in Unity and real-time demonstration of effects.
<br>Integration of lights and post-processing(optional) to complement the shaders.





<br>Screenrecording
Download OBS Studio or some other comparable software, record your screen and talk me through your design process and other requirements specified in the document.
<br>README Example Format
# Assignment 2: Dynamic Shaders and Materials

## Shader Design
- Tool Used: Unity Shader Graph  
- Techniques: Animated emissive glow, noise-based texture movement.  
- Theme Connection: Represents cosmic energy and the void’s ethereal nature.

## Unity Material Setup
- Material Design: Applied to a swirling portal with emissive highlights and transparency.  
- Lighting Design: Purple spotlights to enhance the glowing edges.

## Challenges
- Issue: Achieving smooth animation at runtime.  
- Solution: Adjusted shader parameters and optimized node setups.  

<br><br><br>By completing this assignment, you will:

<br>Gain hands-on experience in shader and material development using node-based tools.
<br>Enhance your procedural asset with dynamic, real-time effects.
<br>Understand the technical workflow for applying shaders in Unity.
<br>Align technical art skills with creative storytelling and thematic presentation.

<br><br>Submission Guidelines

<br>Submission Format: ZIP file uploaded to Drexel Learn.
<br>File Naming: abc123_Lastname_Firstname_A2.zip.
<br>Late submissions will incur a 10% penalty per day.

<br><br>]]></description><link>gmap-395\module-2\gmap-395-asn-2-brief.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - ASN 2 - Brief.md</guid><pubDate>Tue, 28 Jan 2025 20:44:35 GMT</pubDate></item><item><title><![CDATA[Module 2 - Shaders and Material Development]]></title><description><![CDATA[ 
 <br><br><br>This module deals with shader creation and material development, essential skills for adding dynamic visual behavior to assets. Students will explore both code-based and node-based shader workflows, focusing on enhancing procedural assets for real-time interactivity.<br><br><a data-href="GMAP 395 - WK 4 - Slides + Video" href="gmap-395\module-2\gmap-395-wk-4-slides-+-video.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 4 - Slides + Video</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395/Module 2/GMAP 395 - WK 4 - Tutorial" data-href="GMAP 395/Module 2/GMAP 395 - WK 4 - Tutorial" href="gmap-395\module-2\gmap-395-wk-4-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 4 - Tutorial</a><br>
<a data-href="GMAP 395 - WK 4 - In-Class Lab" href="gmap-395\module-2\gmap-395-wk-4-in-class-lab.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 4 - In-Class Lab</a><br>
<a data-tooltip-position="top" aria-label="GMAP 395 - WK 5 - Slides + Video" data-href="GMAP 395 - WK 5 - Slides + Video" href="gmap-395\module-2\gmap-395-wk-5-slides-+-video.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 5 - Slides + Video</a><br>
<a data-href="GMAP 395 - WK 5 - Tutorial" href="gmap-395\module-2\gmap-395-wk-5-tutorial.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - WK 5 - Tutorial</a><br>
<a data-href="GMAP 395 - ASN 2 - Brief" href="gmap-395\module-2\gmap-395-asn-2-brief.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395 - ASN 2 - Brief</a><br><br><br>
<br>Introduction to Unity Shader Graph and custom shader creation.
<br>Exploring material properties and real-time interactions.
<br>Applying shaders to procedural assets developed in Module 1.
<br><br><br>By the end of this module, you will:<br>
<br>Gain foundational knowledge of shader and material workflows.
<br>Create custom shaders using Unity Shader Graph and scripting.
<br>Enhance procedural assets with dynamic visual behaviors.
<br>Understand the integration of shaders into real-time systems.
<br><br><br>
<br>Ensure Unity (2022.3 or higher) is installed and updated.
<br>Confirm your computer meets the recommended specifications for shader development.
<br>Helpful Resources

<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Manual/shader-graph.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Manual/shader-graph.html" target="_blank">Unity Shader Graph Documentation</a>
<br><a data-tooltip-position="top" aria-label="https://www.kodeco.com/5671826-introduction-to-shaders-in-unity" rel="noopener nofollow" class="external-link" href="https://www.kodeco.com/5671826-introduction-to-shaders-in-unity" target="_blank">Introduction to Shaders in Unity</a>

<br>If you are new to Shader Graph

<br><br><br><br><br>
<br>Unity 2022.3 SRP with Shader Graph: Included with Unity Editor.
<br>An IDE (w/ optional HLSL support): Examples include Visual Studio or Visual Studio Code.
<br><br><br><br>
<br>Objective: Develop shaders to enhance the visual behavior of assets created in Assignment 1.
<br>Key Deliverables:

<br>A shader with dynamic effects (e.g., glow, transparency).
<br>A material applied to a procedural asset demonstrating interactivity.


<br>Due Date: Week 5
<br><br><br>
<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.shadergraph@16.0/manual/Node-Library.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.shadergraph@16.0/manual/Node-Library.html" target="_blank">Shader Graph Node Library</a>
<br><a data-tooltip-position="top" aria-label="https://learn.unity.com/mission/creative-core-shaders-and-materials?pathwayId=61a65568edbc2a00206076dd" rel="noopener nofollow" class="external-link" href="https://learn.unity.com/mission/creative-core-shaders-and-materials?pathwayId=61a65568edbc2a00206076dd" target="_blank">Unity Learn - Shaders and Materials</a>
<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/2022.3/Documentation/Manual/class-GraphicsSettings.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/2022.3/Documentation/Manual/class-GraphicsSettings.html" target="_blank">Unity Graphics Settings Overview</a>
<br><br><a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\module-2\gmap-395-module-2.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - Module 2.md</guid><pubDate>Sun, 02 Feb 2025 20:30:40 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 4 - In-Class Lab]]></title><description><![CDATA[ 
 <br><br>Gain hands-on experience creating and modifying basic shaders using Unity's Shader Graph. <br><br>
<br>Unity 2022.3
<br>Basic understanding of Unity interface
<br>Universal Render Pipeline (URP) set up in your project
<br><br><br><br>
<br>In Unity, right-click in the Project window
<br>Select Create &gt; Shader &gt; Universal Render Pipeline &gt; Unlit Shader Graph
<br>Name it "MyFirstShaderGraph"
<br>Double-click to open it in the Shader Graph window
<br><br>
<br>In the Shader Graph window, locate the Blackboard (usually on the left side)
<br>In the Blackboard:

<br>Click the + button
<br>Choose Color from the dropdown
<br>Name it _Color (or any appropriate name)
<br>Set a default color if desired (found in the Graph Inspector &gt; Node Settings)


<br>In the graph area:

<br>Click and drag the _Color property from the Blackboard directly into the graph area


<br>Connect the Color property node's output to the Base Color input of the "Fragment" node
<br>Click "Save Asset" to save your shader graph
<br><br>
<br>In Unity, create a new 3D object (e.g., Sphere) in your scene
<br>Create a new material:

<br>Right-click in the Project window &gt; Create &gt; Material
<br>Name it appropriately


<br>In the new material's Inspector:

<br>Set the Shader to your "Shader Graph/MyFirstShaderGraph"
<br>Adjust the Color property to see changes on your 3D object


<br><br><br><br>
<br>
In the Blackboard, add the following properties:

<br>Texture2D named _MainTex
<br>Vector2 named _Tiling (set default to 1,1)
<br>Vector2 named _Offset (set default to 0,0)


<br>
In your Shader Graph, add the following nodes:

<br>Drag the _MainTex, _Tiling, and _Offset properties from the Blackboard into the graph
<br>Add a Tiling And Offsetnode
<br>Add a Sample Texture 2D node


<br>Hotkey
SPACEBAR is the hotkey shortcut to open the create node dialogue box.
<br>
<br>Connect the nodes:

<br>Connect the _Tiling and _Offset outputs to the respective inputs of the Tiling And Offset node
<br>Connect the UV output of Tiling And Offset to the UV input of Sample Texture 2D
<br>Connect the _MainTex property to the Texture input of Sample Texture 2D


<br><br>
<br>
Add a Multiply node

<br>
Connect:

<br>The RGBA output of Sample Texture 2D to one input of Multiply
<br>The _Color property to the other input of Multiply
<br>The output of Multiply to the Base Color of the Fragment node


<br>
Save the Shader Graph

<br><br>
<br>Select your 3D object in the scene
<br>In the Inspector, you should now see slots for Texture, Tiling, and Offset
<br>Assign a texture to the Texture slot
<br>Adjust Tiling and Offset values to see how they affect the texture
<br><br><br><br>
<br>
In the Blackboard, add these Float properties:

<br>_WaveAmount (default 1)
<br>_WaveSpeed (default 1)
<br>_WaveFrequency (default 1)


<br>
In your Shader Graph, add these nodes:

<br>Drag the new Float properties from the Blackboard into the graph
<br>Add Time node
<br>Add Position node (set to World)
<br>Add Sine node
<br>Add several Multiply (3) nodes
<br>Add Add node
<br>Add Split node


<br>
Connect the nodes to create the wave effect:

<br>Connect the output of the World Position node to the input of the Split node
<br>Connect the R output of the Split node (which represents the X component) to one input of a Multiply node
<br>Connect the _WaveFrequency to the other input of this Multiply node
<br>Multiply _WaveSpeed by Time
<br>Add the results of the above two operations using an Add node
<br>Feed the output of the Add node into the Sine node
<br>Multiply the Sine output by _WaveAmount


<br>
Add a Combine node:

<br>Connect the R (X) and B (Z) from the Split node to the corresponding inputs on the Combine
<br>For the G(Y) input of the Combine node, add the wave calculation to the G(Y) output of the Split node and connect it.


<br>
Connect the Combine node's output (RGBA or RGB) to the Position input of the Vertex node

<br><br>
<br>Save the Shader Graph
<br>Select your 3D object in the scene
<br>In the Inspector, you should now see Wave Amount, Wave Speed, and Wave Frequency properties
<br>Adjust these values to see how they affect the object's shape
<br><br><br><br>Modify your shader to blend between two colors based on a custom parameter.<br><br>
<br>In the Blackboard, add:

<br>Another Color property named _Color2
<br>A Float property named _BlendFactor (set range 0 to 1)


<br>Modes in Graph Inspector
You can change the Mode of a property in the Graph Inspector to something like Slider
<br>
<br>
In the graph area:

<br>Drag the new properties from the Blackboard
<br>Add a Lerp node


<br>
Connect the nodes:

<br>Connect _Color and _Color2 to the A and B inputs of the Lerp node respectively
<br>Connect _BlendFactor to the T input of the Lerp node


<br>
Use the output of the Lerp node in your final color calculation (e.g., multiply it with your texture sample)

<br>
Save the Shader Graph and adjust the Blend Factor in your material's Inspector to blend between the two colors.

<br><br>
<br>Try blending based on vertex position instead of a custom parameter
<br>Implement a smooth transition that cycles between the colors over time (Time or Sine)
<br>Add a third color and blend between all three
<br>Check
Remember to save your Shader Graph after each major change, and don't hesitate to experiment with different connections and values!
]]></description><link>gmap-395\module-2\gmap-395-wk-4-in-class-lab.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 4 - In-Class Lab.md</guid><pubDate>Mon, 27 Jan 2025 21:55:53 GMT</pubDate></item><item><title><![CDATA[GMAP 395 - WK 4 - Slides + Video]]></title><description><![CDATA[ 
 <br><br><br><br>Week 4 Video Lecture

<a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_F3vSAiT9rcAKv5Jw?e=HRmiMT" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_F3vSAiT9rcAKv5Jw?e=HRmiMT" target="_blank">gmap395_wk4.mp4</a>
<br><br><br>
<br>Definition: Shaders are small programs that run on the GPU, defining the visual appearance of objects in a scene.
<br>Purpose: Control how materials interact with light to achieve desired visual effects.
<br>Core Shader Types:

<br>Vertex Shaders: Modify geometry at the vertex level.
<br>Fragment Shaders (Pixel Shaders): Control pixel-level color and lighting.


<br><br><a data-tooltip-position="top" aria-label="https://www.youtube.com/watch?v=ax1JLQABmOw" rel="noopener nofollow" class="external-link" href="https://www.youtube.com/watch?v=ax1JLQABmOw" target="_blank">What are shaders? - GDQuest</a><br><br><br>
<br>Customization: Allows unique material creation.
<br>Optimization: Efficient use of GPU resources for real-time rendering.
<br>Dynamic Effects: Enables interactive and changing visuals.
<br>Examples:

<br>"Stylized" water effects (Breath of the Wild).
<br>Holograms (Halo).
<br>Cel-shading (Borderlands).


<br><br><br>
<br>Bridging Art and Code:

<br>Shaders enable technical artists to bridge visual design and programming.


<br>Dynamic Visuals:

<br>Create interactive and adaptive visuals for game systems.


<br>Procedural Systems:

<br>Shaders are often used in procedural workflows for generating textures, patterns, and effects.


<br><br><br>
<br>Procedural Textures:

<br>Use math and logic to generate seamless textures.


<br>Modular Workflows:

<br>Reusable shader modules can streamline development.


<br>Examples:

<br>Procedural weathering effects.
<br>Adjustable material templates for diverse assets.


<br><br><br>
<br>Define Properties: Expose parameters like color or texture to customize materials.
<br>Create SubShaders: Specify rendering techniques for different hardware or conditions.
<br>Write Passes: Describe rendering steps (e.g., vertex and fragment programs).
<br><br><br>Shader "Custom/ExampleShader"
{
    Properties
    {
        _Color ("Main Color", Color) = (1,1,1,1)
    }
    SubShader
    {
        Pass
        {
            CGPROGRAM
            #pragma vertex vert
            #pragma fragment frag
            // Declare the _Color property as a uniform
            fixed4 _Color;
            struct appdata
            {
                float4 vertex : POSITION; // Vertex position
            };
            struct v2f
            {
                float4 pos : SV_POSITION; // Transformed position
            };
            v2f vert (appdata v)
            {
                v2f o;
                o.pos = UnityObjectToClipPos(v.vertex);
                return o;
            }
            // Use _Color in the fragment shader
            fixed4 frag (v2f i) : SV_Target
            {
                return _Color; // Output the color
            }
            ENDCG
        }
    }
}

<br><br><br>
<br>Shader Properties:

<br>_Color: Exposed parameter for material customization.


<br>SubShader:

<br>Contains rendering passes for different GPU capabilities.


<br>Vertex Function:

<br>Processes vertex data (positions, normals, UVs).


<br>Fragment Function:

<br>Determines final pixel color using inputs from the vertex shader.


<br><br><br>
<br>Uniform Variables:

<br>Definition: Global variables that are constant during the rendering of a single draw call. These are set by the CPU and shared across all invocations of a shader program.
<br>Examples:

<br>Time values for animations.




<br>Attributes:

<br>Definition: Input data that is unique for each vertex and provided by the vertex buffer. Attributes are available only in the vertex shader.
<br>Examples:

<br>Texture coordinates (TEXCOORD).




<br>Varyings:

<br>Definition: Variables used to pass interpolated data from the vertex shader to the fragment shader.
<br>Examples:

<br>Lighting data like vertex colors or normals.




<br><a data-tooltip-position="top" aria-label="https://thebookofshaders.com/" rel="noopener nofollow" class="external-link" href="https://thebookofshaders.com/" target="_blank">The Book of Shaders</a><br><br><br>
<br>Inputs:

<br>Vertex Data: Positions, normals, UVs.
<br>Textures: Color or detail maps.
<br>Uniforms: Constants like time or transformations.


<br>Outputs:

<br>Final pixel colors rendered to the screen.


<br><br><br><br>
<br>Vertices: Define points in 3D space.
<br>Edges: Connect vertices to outline shapes.
<br>Faces: Form surfaces using connected edges.
<br>UVs: Map 2D textures to 3D surfaces.
<br>Normals: Vectors perpendicular to faces for lighting calculations.
<br><br>
<br>Vertex Data: Input for vertex shaders to transform 3D geometry.
<br>Normals: Used in lighting equations for shading effects.
<br>UV Mapping: Guides texture placement via fragment shaders.
<br>Shader Outputs: Define the final appearance of geometry on-screen.
<br><br><br><br><br>
<br>Small programs executed on the GPU.
<br>Control how light interacts with geometry.
<br>Types: Vertex, Fragment, Compute.
<br><br>
<br>Definition: A wrapper for shaders, combining textures and parameters.
<br>Role: Define the look of objects by associating shaders with visual properties.
<br>Example: A reflective material uses a custom shader for specular highlights.
<br><br>
<br>Definition: 2D images mapped to 3D geometry.
<br>Purpose: Add details like color, patterns, or surface irregularities.
<br>Common Types: Diffuse, Normal, Specular, Emissive.
<br><br><br><br><br>
<br>Physically Based Rendering (PBR): A method to simulate realistic lighting and material behavior.
<br>Key Concepts: Energy conservation, physically accurate shading.
<br>Benefits: Consistent results across lighting environments.
<br><br>
<br>Base Color: Defines the albedo (color) of the surface.
<br>Metallic: Specifies if the material is metal (affects reflection).
<br>Roughness/Smoothness: Controls surface reflectivity.
<br>Normal Map: Adds surface details without extra geometry.
<br>Ambient Occlusion (AO): Simulates soft shadows in crevices.
<br><a data-tooltip-position="top" aria-label="https://www.materialmaker.org/" rel="noopener nofollow" class="external-link" href="https://www.materialmaker.org/" target="_blank">Material Maker</a>
Material Maker is a procedural materials authoring tool based on the Godot Engine.
<br><br><br>
<br>Vector Operations:

<br>Dot Product: Lighting calculations.
<br>Cross Product: Surface normals.


<br>Matrix Transformations:

<br>Object to world space conversions.


<br>Color Operations:

<br>RGB blending and transitions.


<br>Noise Functions:

<br>Create procedural patterns for effects.


<br><br><br>
<br>Minimize Complexity:

<br>Use simple math operations where possible.


<br>Reuse Variables:

<br>Avoid redundant calculations.


<br>LOD Techniques:

<br>Reduce detail for distant objects.


<br><br><br>
<br>Dissolve Effects:

<br>Use noise textures to create fading effects.


<br>Holographic Shaders:

<br>Add transparency and scrolling UV animations.


<br>Water Shaders:

<br>Simulate refraction and wave movement.


<br><a data-tooltip-position="top" aria-label="https://realtimevfx.com/" rel="noopener nofollow" class="external-link" href="https://realtimevfx.com/" target="_blank">Real-Time VFX Website</a><br><br><br>
<br>What Is Shader Graph?

<br>A node-based interface for creating shaders visually.


<br>Benefits:

<br>No coding required.
<br>Rapid iteration and prototyping.


<br>Components:

<br>Blackboard, Nodes, Master Stack, Preview, etc.


<br><a data-tooltip-position="top" aria-label="https://docs.unity3d.com/Packages/com.unity.shadergraph@14.0/manual/Getting-Started.html" rel="noopener nofollow" class="external-link" href="https://docs.unity3d.com/Packages/com.unity.shadergraph@14.0/manual/Getting-Started.html" target="_blank">Shader Graph Docs</a>
<br>
![[blackboard_shadergraph_path.png]]
![[GraphSettings_Menu.png]]
![[MasterStack_Populated.png|320]]
<br><br><br><br>
<br>Write a basic color shader.
<br>Add texture support.
<br>Implement vertex manipulation for dynamic effects.
<br><br><br><br><br><a data-tooltip-position="top" aria-label="https://jettelly.com/store/the-unity-shaders-bible" rel="noopener nofollow" class="external-link" href="https://jettelly.com/store/the-unity-shaders-bible" target="_blank">The Unity Shader Bible</a><br><br><a data-tooltip-position="top" aria-label="https://www.shadertoy.com/" rel="noopener nofollow" class="external-link" href="https://www.shadertoy.com/" target="_blank">Shadertoy</a><br><br><br><br>
<br>How do shaders enhance visual storytelling?
<br>What challenges might arise in shader development?
<br>Where could you apply shaders in your current projects?
<br><br><br>
<br>Shaders are a powerful tool for creating immersive, visually striking experiences.
<br>Mastering shaders bridges a gap between art and technology in game development and beyond.
<br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-2\gmap-395-wk-4-slides-+-video.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 4 - Slides + Video.md</guid><pubDate>Mon, 03 Feb 2025 16:29:14 GMT</pubDate></item><item><title><![CDATA[Creating an Eldritch Portal Shader]]></title><description><![CDATA[ 
 <br><br><br>Create a swirling circular portal shader using Unity’s Shader Graph, complete with dynamic transparency and procedural motion effects.<br><img alt="portalShaderGrab.png" src="gmap-395\module-2\media\portalshadergrab.png" style="width: 640px; max-width: 100%;"><br><br><br>
[gmap395_tut3.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_F1UOYs8x0W2JbJRQ?e=JOQ7gp)<br><br><br>
<br>Unity 2022.3 with URP installed.
<br>Basic understanding of Shader Graph.
<br>Completion of previous shader lab (recommended).
<br><br><br><br>
<br>In Unity, navigate to the Project tab.
<br>Right-click and select Create &gt; Shader Graph &gt; URP/Lit Shader Graph.
<br>Name it "EldritchPortalShader".
<br>Important Graph Inspector Settings
Surface Type : Transparent<br>
Blending Mode: Multiply or Alpha<br>
Render Face: Both<br>
Alpha Clipping: ✅
<br>Swirl Pattern Texture

<br>Use a PNG with an alpha channel
<br>Find something with a lot of "texture" or noise<br>
What I used: <a data-tooltip-position="top" aria-label="https://1drv.ms/i/s!AqQzGx8l4o2wk_F0d_KPRwOyyq1jzg?e=mqpCpS" rel="noopener nofollow" class="external-link" href="https://1drv.ms/i/s!AqQzGx8l4o2wk_F0d_KPRwOyyq1jzg?e=mqpCpS" target="_blank">liquid_swirl_alpha.png</a>

<br><br>
<br>Open the Shader Graph and access the Blackboard.
<br>Add the following properties:

<br>Color: EdgeColor (default: Purple)
<br>Float: EdgeWidth (default: 0.5, range: 0 to 1)
<br>Texture2D: SwirlPattern (default: Procedural noise texture)
<br>Float: SwirlSpeed (default: 1)
<br>Float: Power (default: 2, range: 0.1 to 10)
<br>Vector2: CenterPosition (default: 0,0)


<br><br><br><br>
<br>Time-Based Swirl Rotation:

<br>Add a Time node and connect it to the A input of a Multiply node.
<br>Link SwirlSpeed to the B input of the Multiply node.

<br>the swirl speed can be set to a Slider (Mode) in the Graph Inspector (Node Settings)
<br>Set the desired Min and Max; e.g. 0.1 - 1.


<br>Connect the output to the Rotation input of a Rotate node.


<br>Swirl UV Transformation:

<br>Pass the output of the Rotate node to the UV input of a Tiling and Offset node.
<br>Connect the output of Tiling and Offset to  to the UV input of a Polar Coordinates node.
<br>Use CenterPosition as the Center input of the Polar Coordinates.
<br>In Polar Coordinates Radial Scale should be ~1.25 and Length Scale ~1


<br>Texture Sampling:

<br>Add a Sample Texture 2D node.
<br>Connect SwirlPattern to the Texture input and the output of Polar Coordinates to the UV input.

<br>An important note for the next section, change the Mip Sampling Mode of the Sample Texture 2D node to Gradient in the Graph Inspector (Node Settings)


<br>Use a DDX node, a DDY node, and the SamplerState to refine UV sampling.

<br>Drop down a UV node and connect it to both DDX and DDY
<br>Connect DDX to the DDX input of the Sample Texture 2D
<br>Connect DDY to the DDY input of the Sample Texture 2D


<br>Drop down a Sampler State node: set its Filter to Linear and its Warp to Mirror

<br>Connect this node to the Sampler input of Sample Texture 2D




<br>Swirl Blend:

<br>Add a Blend node.
<br>Connect the output of the Sample Texture 2D node to the Base input.
<br>Connect EdgeColor to the Blend input.

<br>The Mode should be set to Multiply (but feel free to experiment with looks)




<br><br><br>
<br>Noise Generation:

<br>Add a Time node and connect it to a Multiply node for animation.

<br>Multiply by ~.25


<br>Pass the output to the Offset a Tiling and Offset node.


<br>Noise Texture Sampling:

<br>Add a Voronoi noise node and use the output of Time as its Angle Offset.

<br>Experiment with Cell Density, but a good value is ~3.


<br>Add a Gradient Noise node, connecting the output of Tiling and Offset to its UV input.

<br>The Scale of the gradient node should be ~5.75.




<br>Noise Blending:

<br>Use a Blend node to combine the outputs of Voronoi and Gradient Noise.

<br>I think the Mode Negation works well here; but again, experiment with it.




<br><br><br>
<br>Radial Transparency:

<br>Add a Polar Coordinates node.

<br>Set the Length Scale to ~2.45


<br>Connect EdgeWidth as the Radial Scale input.


<br>Gradient Sampling:

<br>Pass the output of Polar Coordinates to the Time input of a Sample Gradient node.
<br>Set the Gradient so it goes from Black &gt;&gt; White with more black showing, about halfway point.


<br><br><br>
<br>Base Swirl and Noise Combination:

<br>Add a Multiply node.
<br>Connect the output of the Blend node from the Basic Swirl Nodes section to A.
<br>Connect the output of the Blend node from the Additional Noise section to B.


<br>Power Adjustment:

<br>Add a Power node and connect Power to its second input.
<br>Pass the output of the Multiply node to the A input of Power.


<br>Blend Blending:

<br>Add a Blend(1) node to combine the outputs of the Power (into Blend input) node and the Sample Gradient node (into Base input) from the  Radial Alpha section.

<br>Set the Opacity to ~1


<br>Now Copy and Paste this Blend(2) node (you should now have 2)

<br>Set this ones Opacity to ~0.5




<br>Final Blend

<br>Drop down a new Blend(Final) node.
<br>Connect Blend(1) to Base
<br>Connect Blend(2) to Base
<br>Set the Opacity to ~0.5


<br>Fragment Shader Stack:

<br>Connect the final blend output to the main Fragment Shader output:

<br>Base Color
<br>Emission
<br>Alpha
<br>Alpha Clip Threshold




<br><br><br><br>
<br>Create or import a circular plane in Unity (or use a cylinder primitive).
<br>Create a material from the Shader Graph (right-click &gt; create &gt; material)
<br>Assign the material using the Eldritch Portal Shader to this mesh.
<br><br>
<br>Adjust the properties (EdgeWidt, SwirlSpeed, CenterPosition, etc.) to fine-tune the effect.
<br>Experiment with different textures for SwirlPattern and different types of noise to create unique styles.
<br><br>
<br>Color Shifting: Use a Sample Gradient node linked to Time(Sine) for dynamic color transitions and pulsating effect.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-2\gmap-395-wk-4-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 4 - Tutorial.md</guid><pubDate>Mon, 03 Feb 2025 16:29:40 GMT</pubDate><enclosure url="gmap-395\module-2\media\portalshadergrab.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-2\media\portalshadergrab.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[GMAP 395 - WK 5 - Slides + Video]]></title><description><![CDATA[ 
 <br><br><br><br><a data-tooltip-position="top" aria-label="https://1drv.ms/v/s!AqQzGx8l4o2wk_IPty_ck4XywUX00A?e=r8xsqz" rel="noopener nofollow" class="external-link" href="https://1drv.ms/v/s!AqQzGx8l4o2wk_IPty_ck4XywUX00A?e=r8xsqz" target="_blank">gmap395_wk5.mp4</a><br><br><br><br>
<br>Shader Structure

<br>Properties, Subshaders, Passes
<br>Vertex Shaders 
<br>Fragment Shaders


<br><br><br>
<br>Visual Shader Creation Tool in Unity
<br>Node-Based Interface

<br>No need for manual HLSL coding
<br>Drag-and-drop workflow


<br>Requires Scriptable Render Pipeline (SRP)

<br>URP (Universal Render Pipeline) is recommended for this course


<br><br><br>
<br>Blackboard: Define and expose parameters
<br>Graph Inspector: Contextual information about nodes
<br>Main Stack: Handles Vertex and Fragment logic
<br>Main Preview: Real-time shader preview (can be unreliable)
<br>Toolbar: Save, compile, and debug shaders
<br><br><br>
<br>Base Color Texturing

<br>Sample a Texture2D and apply UV coordinates


<br>Using Lerp for Blending

<br>Combine two textures using a Mask Texture


<br>Adding Detail Textures

<br>Multiply noise maps for realistic effects


<br><br><br><br>
<br>Normal Maps Enhance Perceived Depth

<br>Adds lighting-based details without extra geometry


<br>Implementation:

<br>Use a Sample Texture 2D Node
<br>Convert RGB values to Normal Data
<br>Blend Normal Maps for extra detail


<br><a data-tooltip-position="top" aria-label="https://www.artstation.com/blogs/typhen/GMyG/this-is-normal-1-what-normal-maps-are-and-how-they-work" rel="noopener nofollow" class="external-link" href="https://www.artstation.com/blogs/typhen/GMyG/this-is-normal-1-what-normal-maps-are-and-how-they-work" target="_blank">This is Normal - ArtStation</a><br>
<a data-tooltip-position="top" aria-label="https://www.adobe.com/products/substance3d/discover/normal-mapping.html" rel="noopener nofollow" class="external-link" href="https://www.adobe.com/products/substance3d/discover/normal-mapping.html" target="_blank">What is Normal Mapping? - Adobe</a><br><br><br>
<br>Color Adjustments

<br>Adjust color values dynamically


<br>UV Manipulation

<br>Tiling, Offset, and Rotation


<br>Vertex Displacement

<br>Animate geometry movement


<br>Time-Based Animations

<br>Scroll textures, pulse effects


<br><br><br><br><br>
<br>Use the Position Node
<br>Apply Sine Waves for Oscillating Movement
<br>Combine Noise for Organic Deformations
<br>Practical Use: Water ripples, grass swaying, liquid surfaces
<br><br><br><br>
<br>Types of Noise

<br>Perlin Noise: Soft organic patterns
<br>Voronoi Noise: Cellular structure
<br>Gradient Noise: Blending &amp; soft transitions
<br>Many more...


<br>Blending Techniques

<br>Combine noise with Lerp &amp; Multiply Nodes
<br>Adjust intensity via Remap Node


<br><br><br><br>
<br>Lighting Models

<br>PBR-based or Custom Light Calculations


<br>Creating Custom Rim Lighting

<br>Multiply View Direction and Normal
<br>Apply an Fresnel Node for edge glow


<br><br><br><br><br>
<br>Handles transformations of vertex positions and attributes.
<br>Adjusts geometry before rasterization.
<br>Key Operations:

<br>Model-View-Projection transformations.
<br>Vertex displacement (e.g., vertex animation for waves or procedural terrain).


<br><br>
<br>Groups vertices into triangles or other primitives.
<br>Prepares geometry for rasterization.
<br>Affects edge visibility and culling.
<br><br><br><br>
<br>Converts primitives (triangles) into pixel fragments.
<br>Determines which pixels will be rendered on the screen.
<br><br>
<br>Calculates the final color of each pixel.
<br>Executes texture mapping, lighting calculations, and shading effects.
<br><br>
<br>Combines rendered pixels into a final image.
<br>Handles blending, depth testing, and post-processing effects.
<br><a rel="noopener nofollow" class="external-link" href="https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview" target="_blank">https://www.khronos.org/opengl/wiki/Rendering_Pipeline_Overview</a><br><br><img alt="renderPipeline.jpg" src="gmap-395\module-2\media\renderpipeline.jpg" style="width: 640px; max-width: 100%;"><br><br><br><br><br>
<br>VFX Meshes

<br>Assign shaders to particle systems


<br>Custom VFX Shaders

<br>Modify shaders dynamically in real-time


<br>Particle Systems

<br>Practical Use: Fire, smoke, dissolving effects


<br><br><br>
<br>Manipulating Shader Properties via C#

<br>Expose shader parameters in Shader Graph (e.g., _Color, _Emission, _DistortionAmount)
<br>Use C# scripts to modify material properties dynamically


<br>Responding to Game Events

<br>Change material colors when taking damage
<br>Adjust transparency when cloaking
<br>Animate distortion or displacement over time


<br>Example: Modifying Shader Properties in C#
using UnityEngine;

public class MaterialController : MonoBehaviour
{
    public Material dynamicMaterial;
    public float pulseSpeed = 2f;

    void Update()
    {
        // Animate Emission Intensity Over Time
        float emission = Mathf.PingPong(Time.time * pulseSpeed, 1f);
        dynamicMaterial.SetFloat("_EmissionIntensity", emission);
    }

    public void SetDamageEffect()
    {
        // Flash red when hit
        dynamicMaterial.SetColor("_BaseColor", Color.red);
    }
}


<br>Real-World Uses

<br>Player Interaction: Change material properties based on proximity
<br>UI Feedback: Highlight objects when hovered over
<br>Environmental Effects: Shift colors based on time of day or weather conditions


<br><br><br>
<br>What is Tweening?

<br>Smooth interpolation of values over time


<br>Linking Animations to Shader Properties

<br>Change Emission Intensity, Transparency, Displacement


<br>Tweening Libraries in Unity

<br>DOTween, LeanTween


<br>Example: Glow pulse shader using a tweened float variable
<br>using DG.Tweening;
Material mat;
void Start() {
    mat = GetComponent&lt;Renderer&gt;().material;
    mat.DOColor(Color.blue, "_EmissionColor", 2f).SetLoops(-1, LoopType.Yoyo);
}
<br><br><br>
<br>Cel Shading in Borderlands

<br>Uses custom ramp shading
<br>Simplified shadows for comic book style


<br>Hologram Effects in Halo

<br>Vertex displacement for distortion
<br>Transparency with additive blending


<br>Water Simulation in Sea of Thieves

<br>Vertex waves via sine displacement
<br>Reflection and refraction shaders


<br><br><br>
<br>Procedural Modeling generates game assets dynamically—Shaders can complement this by adding:

<br>Procedural Textures: Generate surface detail without needing high-resolution textures
<br>Dynamic Surface Effects: Adapt material appearance based on model parameters
<br>Example: A procedural rock model can have a procedural shader that controls:

<br>Color variation based on world position
<br>Edge wear effects using curvature maps
<br>Moss or dirt accumulation in crevices




<br>Key Concept: Both Procedural Modeling &amp; Shaders use node-based workflows (Houdini, Blender Geometry Nodes, Unity Shader Graph)
<br><br><br>
<br>Lighting in Games defines how objects appear based on:

<br>Direct Lighting (sunlight, spotlights)
<br>Indirect Lighting (bounced light, reflections)
<br>Ambient Lighting (general scene illumination)


<br>Shaders Enhance Lighting by:

<br>Controlling how materials respond to light (diffuse, metallic, specular)
<br>Using custom lighting models to override Unity’s default lighting
<br>Adding real-time effects, like rim lighting, emissive glow, and reflections


<br>Example: A lava shader that uses emissive properties to glow in dark environments<br>

<br><br><br>
<br>Shader Graph

<br>Visual scripting for shaders
<br>No need for HLSL coding
<br>Best for rapid prototyping
<br>Limited in customization (but extendable with code)


<br>HLSL / Custom Shader Code

<br>More control over rendering logic
<br>Better for performance optimizations
<br>Required for advanced effects (custom lighting, procedural vertex animations)


<br>When to Use Each?

<br>Shader Graph: Prototyping, procedural textures, stylized effects
<br>Handwritten Code: Performance-critical shaders, advanced lighting, VFX shaders


<br><br><br>
<br>Performance Considerations

<br>Reduce Overdraw: Use Alpha Clipping instead of transparent materials when possible
<br>Shader Complexity: Limit the number of shader passes (each pass is an extra rendering step)
<br>Optimize Textures: Avoid high-res textures where procedural patterns can be used


<br>Debugging Shader Graph

<br>Use Frame Debugger (Window &gt; Analysis &gt; Frame Debugger) to see rendering steps
<br>Use Material Debugging Mode (Scene View &gt; Debug Shading Modes) to isolate issues
<br>Always test shaders under different lighting conditions


<br><br><br>
<br>Stylized Games

<br>Example: Hollow Knight uses hand-painted textures + simple shaders for a 2D lighting effect


<br>Realistic Games

<br>Example: The Last of Us 2 uses physically-based shaders for materials like leather and metal


<br>Procedural Effects

<br>Example: No Man’s Sky procedural planets use Shader Graph for terrain blending


<br>Interactive Environments

<br>Example: Control by Remedy uses dynamic shaders for real-time environment shifts


<br>Takeaway: Shaders are a core part of how modern games achieve immersion and responsiveness!
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-2\gmap-395-wk-5-slides-+-video.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 5 - Slides + Video.md</guid><pubDate>Mon, 03 Feb 2025 19:40:02 GMT</pubDate><enclosure url="gmap-395\module-2\media\renderpipeline.jpg" length="0" type="image/jpeg"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-2\media\renderpipeline.jpg"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[Game-Based Real-Time Shader Control w/ DOTween]]></title><description><![CDATA[ 
 <br><br><br>In this tutorial, students will control shader parameters in real-time using C# scripts and game-based events. The goal is to modify the Eldritch Portal Shader from Week 4 dynamically, based on game logic (e.g., an enemy spawning from the portal).<br><br><br>
[gmap395_tut4.mp4](https://1drv.ms/v/s!AqQzGx8l4o2wk_IOWxZ2Vcsusxzvng?e=ONBhuI)<br><br><br>✅ Unity 2022.3 with URP<br>
✅ <a data-tooltip-position="top" aria-label="https://dotween.demigiant.com/getstarted.php" rel="noopener nofollow" class="external-link" href="https://dotween.demigiant.com/getstarted.php" target="_blank">DOTween</a><br>
✅ Completion of Week 4’s Eldritch Portal Shader<br>
✅ Basic familiarity with Shader Graph &amp; C# Scripting<br><br><br><br>Before we start controlling shader parameters, we need to install and set up DOTween in Unity. DOTween is a tweening engine that allows us to animate values smoothly over time, including object positions, UI elements, and shader properties.<br><br><br>
<br>Open Unity and go to the Asset Store (Window &gt; Asset Store). The asset store can also be accesses from the Unity Hub (Community &gt; Asset Store)
<br>Search for DOTween (by Demigiant). The free version is fine for this course.
<br>Click Add to My Assets, then Open in Unity it into your project. Then Import it.
<br>After importing, go to Tools &gt; DOTween Utility Panel in the top menu bar.
<br>Click Setup DOTween (this generates the necessary setup files).
<br><img alt="dotween1.png" src="gmap-395\module-2\media\dotween1.png"><br>
✅ DOTween is now ready to use in your project! 🎉
<br><br><br>Let’s create a quick cube animation to test DOTween.<br><br>
<br>In a new test scene, in the Hierarchy, right-click and select 3D Object &gt; Cube.
<br>Rename it "TweenCube".
<br>Reset its Transform (Right-click Transform &gt; Reset in the Inspector).
<br><br>
<br>In the Project Window, in your Scripts folder create a new C# script named DOTweenTest.cs.
<br>Attach it to TweenCube.
<br>Open the script and replace its contents with:
<br>using UnityEngine;
using DG.Tweening; // Import DOTween

public class DOTweenTest : MonoBehaviour
{
    void Start()
    {
        // Move the cube up and down repeatedly
        transform.DOMoveY(3f, 1f) // Move to Y = 3 in 1 second
            .SetLoops(-1, LoopType.Yoyo) // Infinite loop with Yoyo effect
            .SetEase(Ease.InOutSine); // Smooth transition
    }
}
<br><br>
<br>Click Play in Unity.
<br>The cube will move up and down smoothly forever.
<br>Try modifying values like:

<br>Changing DOMoveY(3f, 1f) to DOMoveX(5f, 2f) to move sideways instead.
<br>Adjusting .SetEase(Ease.InOutSine) to .SetEase(Ease.OutBounce) for a different effect.


<br><br><br>✅ DOMoveY(3f, 1f) → Moves the cube’s Y position to 3 over 1 second.<br>
✅ .SetLoops(-1, LoopType.Yoyo) → Makes it loop infinitely (up and down).<br>
✅ .SetEase(Ease.InOutSine) → Creates a smooth, natural motion.<br>DOTween Documentation
All of the possible functions/methods and concepts around the tweening engine can be learned from the <a data-tooltip-position="top" aria-label="https://dotween.demigiant.com/documentation.php" rel="noopener nofollow" class="external-link" href="https://dotween.demigiant.com/documentation.php" target="_blank">documentation</a>.
<br><br><br><br>
<br>Open the EldritchPortalShader in Shader Graph.
<br>Locate the EdgeWidth property in the Blackboard.
<br>Check its Reference Name is set to _EdgeWidth in the Graph Inspector &gt; Node Settings (for C# access).
<br>Check that Exposed is ticked on.
<br>Save and Apply changes.
<br><br><br>We will use DOTween to smoothly animate the portal’s EdgeWidth when an "enemy is about to spawn."<br><br>
<br>In Unity, create a new C# script named PortalShaderController.cs.
<br>Attach it to the Portal GameObject, the one with the shader and material applied to it.
<br>Replace its contents with the following:
<br>using UnityEngine;
using DG.Tweening; // Import DOTween

public class PortalShaderController : MonoBehaviour
{
    public Material portalMaterial;  // Assign the material in the Inspector
    private static readonly int EdgeWidthProperty = Shader.PropertyToID("_EdgeWidth");

    public float normalWidth = 0.2f;
    public float alertWidth = 0.6f;
    public float transitionDuration = 1.0f; // How long the animation takes

    void Start()
    {
        if (portalMaterial == null)
        {
            Debug.LogError("Portal material not assigned!");
            return;
        }

        // Ensure EdgeWidth starts at normal width
        portalMaterial.SetFloat(EdgeWidthProperty, normalWidth);
    }

    // Triggered when an enemy is about to spawn
    public void ActivateAlert()
    {
        Debug.Log("Portal activating.");
        
        // DOTween smoothly changes EdgeWidth over time
        portalMaterial.DOFloat(alertWidth, EdgeWidthProperty, transitionDuration)
            .SetEase(Ease.InOutQuad);
    }

    // Reset the effect after a delay
    public void DeactivateAlert()
    {
        Debug.Log("Portal deactivating.");
        
        // DOTween smoothly returns EdgeWidth to normal
        portalMaterial.DOFloat(normalWidth, EdgeWidthProperty, transitionDuration)
            .SetEase(Ease.InOutQuad);
    }
}
<br><br>✅ DOFloat(): Smoothly transitions the shader property over time.<br>
✅ SetEase(Ease.InOutQuad): Adds a smooth acceleration/deceleration.<br>
✅ ActivateAlert(): Expands the portal effect.<br>
✅ DeactivateAlert(): Resets the effect after a delay.<br>Inspector Values
Be sure to assign the correct POrtal Material and tweak the Normal Width and Alert Width values in the Inspector for this script. If not errors may arise, such as a "NullReferenceExcpetion"
<br><img alt="portalInspector.png" src="gmap-395\module-2\media\portalinspector.png"><br><br><br><br>
<br>Create an empty GameObject named "EnemySpawner".
<br>Create a new script called EnemySpawner.
<br>Attach the script to it and replace its contents:
<br>using UnityEngine;
using System.Collections;

public class EnemySpawner : MonoBehaviour
{
    public PortalShaderController portalShader;
    public float spawnDelay = 5f;  // Time before enemy spawns

    void Start()
    {
        StartCoroutine(TriggerPortalAlert());
    }

    IEnumerator TriggerPortalAlert()
    {
        while (true)
        {
            yield return new WaitForSeconds(spawnDelay);
            
            Debug.Log("Enemy spawning. Triggering portal effect.");
            portalShader.ActivateAlert();
            
            yield return new WaitForSeconds(3f);
            
            Debug.Log("Enemy spawned. Resetting portal.");
            portalShader.DeactivateAlert();
        }
    }
}
<br><br>
<br>Drag the Portal GameObject into the portalShader field in the EnemySpawner script.
<br>Play the scene—the portal will expand and contract smoothly when an enemy is "about to spawn."
<br><img alt="enemySpawnerInspector.png" src="gmap-395\module-2\media\enemyspawnerinspector.png"><br><br><br>✅ Test different EdgeWidth values to fine-tune the visual effect.<br>
✅ Experiment with DOTween easing settings (Ease.OutBounce, Ease.InCirc, etc.).<br>
✅ Try different game triggers instead of a timer (e.g., using OnTriggerEnter).<br><br><br>✅ Connected a C# script to Shader Graph to modify EdgeWidth dynamically.<br>
✅ Used DOTween for smooth, animated transitions.<br>
✅ Triggered the effect using a simulated enemy spawn event.<br>
✅ Enhanced the experience with sound and particles.<br><br>
<br>Try controlling other shader properties (like SwirlSpeed or EdgeColor).
<br>Replace the enemy timer with a real game event (e.g., player proximity).  
<br>Experiment with DOTween sequencing for more complex VFX.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Module 2" data-href="GMAP 395 - Module 2" href="gmap-395\module-2\gmap-395-module-2.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Module Page</a>]]></description><link>gmap-395\module-2\gmap-395-wk-5-tutorial.html</link><guid isPermaLink="false">GMAP 395/Module 2/GMAP 395 - WK 5 - Tutorial.md</guid><pubDate>Mon, 03 Feb 2025 16:32:19 GMT</pubDate><enclosure url="gmap-395\module-2\media\dotween1.png" length="0" type="image/png"/><content:encoded>&lt;figure&gt;&lt;img src="gmap-395\module-2\media\dotween1.png"&gt;&lt;/figure&gt;</content:encoded></item><item><title><![CDATA[🕹️ <strong>*GMAP 395: Final Project Guide</strong>]]></title><description><![CDATA[ 
 <br><br><br>Students will create a polished, interactive game art piece by focusing on one module of their choice from the course. This final deliverable will showcase their technical and artistic skills while demonstrating mastery of the selected module.<br><br><br>Each module for the final includes main requirements and one additional challenge to practice development, critical-thinking, and creativity.<br><br>
Requirements:

<br>✅ Create a procedural or modular system for props, characters, or environments.
<br>✅ Integrate at least three lighting sources: one directional light and two auxiliary lights (e.g., point, spot, area lights).
<br>✅ Use modular assets to build a cohesive scene.
<br>✅ Incorporate a dynamic lighting element, like a day-night cycle or interactive light source.

<br>
🔧 Additional Requirement:

<br>Add an advanced procedural element, such as animated modular components or interactive environmental changes (e.g., destructible props, dynamic weather systems).

<br><br><br>
Requirements:

<br>✅ Develop at least two custom shaders using Shader Graph or HLSL.
<br>✅ Include shaders with dynamic properties, like adjustable emission, transparency, or surface effects.
<br>✅ Ensure shaders are cohesive with the overall project aesthetic.

<br>
🔧 Additional Requirement:

<br>Design a shader with user-driven interactions (for both required shaders) activated by user interaction or environmental triggers (e.g., heat distortion near light sources, ripple effects when interacted with).

<br><br><br>
Requirements:

<br>✅ Create at least three particle systems (e.g., sparks, smoke, mist).
<br>✅ Use modular techniques for particle creation (e.g., reusable templates, layered systems).
<br>✅ Ensure effects are integrated within a cohesive game art scene.

<br>
🔧 Additional Requirement:

<br>Build a reactive particle system (for 2 of the 3 required systems) that changes based on environmental conditions, player interaction, or time (e.g., intensity, color, or behavior adjusting to a day-night cycle).

<br><br><br>
Requirements:

<br>✅ Implement a dynamic camera system using Cinemachine.
<br>✅ Add at least two post-processing effects (e.g., bloom, color grading, depth of field) to enhance visual quality.
<br>✅ Use camera animations or transitions to highlight specific parts of the scene.

<br>
🔧 Additional Requirement:

<br>Develop a camera-based interaction system, such as zoom-in on specific triggers or focus shifts during player interactions and manipulate (1 of the 2 required post-process effects) based on player interaction of environmental triggers.

<br><br><br>What to Submit

<br>Interactive Scene:

<br>A fully developed Unity scene meeting the requirements of the selected module.
<br>The scene must be cohesive, polished, and technically proficient.


<br>Playthrough Video:

<br>A 10-minute video showcasing the final project.
<br>Include annotations or narration explaining key design decisions.


<br>Postmortem Document:

<br>A 1–2 page reflection including:

<br>Successes: Highlight key achievements.
<br>Challenges: Discuss difficulties and solutions.
<br>Learning Outcomes: Share what you’ve learned.


<br>Include citations for any external assets used.


<br>Unity Project Files:

<br>A zipped folder with only the necessary files: Assets, Packages, ProjectSettings ONLY (❌ omit the Library, Temp, and other folders).


<br>Polished Build:

<br>A playable Windows build demonstrating your project.



<br><br>Requirements
For each module there are a set of Requirements that must be met for every module. Then there are Additional Requirements that must only be met for whichever module you choose to polish for the final.
<br><br><br>Your project will be evaluated based on:<br>
<br>Technical Mastery: Effective use of tools and workflows from the chosen module.
<br>Creativity and Originality: Innovative and thoughtful design choices.
<br>Cohesion: Visual and thematic consistency throughout the project.
<br>Polish: Overall quality and refinement of the interactive experience.
<br>Presentation: Clarity and professionalism in the playthrough video and postmortem document.
<br><br><br> <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Main Course Page</a>]]></description><link>gmap-395\gmap-395-final-project-details-and-requirements.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - Final Project - Details and Requirements.md</guid><pubDate>Mon, 03 Feb 2025 20:16:05 GMT</pubDate></item><item><title><![CDATA[Syllabus]]></title><description><![CDATA[ 
 <br><br><br><br>Instructor Details

<br>Name: Darren Woodland, Jr.
<br>Email: <a data-tooltip-position="top" aria-label="mailto:dkw34@drexel.edu" rel="noopener nofollow" class="external-link" href="mailto:dkw34@drexel.edu" target="_blank">dkw34@drexel.edu</a>
<br>Office Hours: By appointment through email or <a data-tooltip-position="top" aria-label="https://outlook.office.com/bookwithme/user/8a28cf456da9442e97dda421b09a3af0@drexel.edu/meetingtype/MWYxQdbZA0mCye-WJGVcQw2?anonymous&amp;ep=mCardFromTile" rel="noopener nofollow" class="external-link" href="https://outlook.office.com/bookwithme/user/8a28cf456da9442e97dda421b09a3af0@drexel.edu/meetingtype/MWYxQdbZA0mCye-WJGVcQw2?anonymous&amp;ep=mCardFromTile" target="_blank">booking</a>.

<br><br>Classroom Info

<br>Location: URBN 252
<br>Students will use Drexel Learn and their @drexel.edu emails for all class communication.

<br><br>This course introduces students to procedural real-time game systems and technical art production. Students will explore game engine based workflows, gaining proficiency in shaders, particle systems, modeling, and visual effects. The course emphasizes real-time systems and modular design techniques.<br><br>Key Capabilities

<br>Procedural and modular modeling
<br>Shader and material development
<br>Particle and image effects
<br>Lighting, camera techniques, and post-processing

<br><br>By the end of the course, students will demonstrate skills in:<br>
<br>🤖 Procedural modeling
<br>💡 Scene lighting and camera effects
<br>✨ VFX creation
<br>🖌️ Shader and material development
<br>🔄 Technical workflows for real-time game art
<br><br><br><br>Useful Links

<br><a data-tooltip-position="top" aria-label="https://unity3d.com/get-unity/download/archive" rel="noopener nofollow" class="external-link" href="https://unity3d.com/get-unity/download/archive" target="_blank">Unity 2022.3.9LTS Download</a>
<br><a data-tooltip-position="top" aria-label="https://www.blender.org/download/" rel="noopener nofollow" class="external-link" href="https://www.blender.org/download/" target="_blank">Blender 4.3 Download</a>
<br><a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener nofollow" class="external-link" href="https://code.visualstudio.com/" target="_blank">Visual Studio Code</a> or your favorite IDE (must support C# + Python)

<br><br>Useful Links

<br><a data-tooltip-position="top" aria-label="https://learn.drexel.edu/" rel="noopener nofollow" class="external-link" href="https://learn.drexel.edu/" target="_blank">Drexel Learn</a>
<br><a data-tooltip-position="top" aria-label="https://dl.acm.org/" rel="noopener nofollow" class="external-link" href="https://dl.acm.org/" target="_blank">ACM Digital Library</a>
<br><a data-tooltip-position="top" aria-label="https://www.gdcvault.com/" rel="noopener nofollow" class="external-link" href="https://www.gdcvault.com/" target="_blank">GDC Vault</a>
<br><a data-tooltip-position="top" aria-label="https://freelibrary.org/" rel="noopener nofollow" class="external-link" href="https://freelibrary.org/" target="_blank">LinkedIn Learning via Free Library of Philadelphia</a>

<br><br><br><br>Weeks 1-3 Highlights

<br>Fundamentals of procedural modeling
<br>Modular workflows
<br>Lighting systems focusing on geometry and light interplay

<br>Assignment 1: Create a modular game asset and integrate lighting systems.<br>
Due: Week 3<br><br>Weeks 4-5 Highlights

<br>Custom shader creation using code and visual scripting
<br>Application of shaders to procedural assets for real-time interactivity

<br>Assignment 2: Develop shaders for the asset created in Assignment 1.<br>
Due: Week 5<br><br>Weeks 6-7 Highlights

<br>Particle systems using visual scripting and component-based systems
<br>Creating interactive effects tied to game mechanics

<br>Assignment 3: Add particle and dynamic visual effects to the modular asset.<br>
Due: Week 7<br><br>Week 8 Highlights

<br>Camera manipulation techniques
<br>Post-processing pipelines for polish and visual enhancement

<br>Assignment 4: Implement camera effects and post-processing for the asset.<br>
Due: Week 8<br><br>Weeks 9-11 Focus Combine and refine work from Modules 1-4 into a polished scene or artifact.<br>Final Deliverables:<br>
<br>🎯 Cohesive scene incorporating procedural assets, shaders, VFX, lighting, and post-processing.
<br><br><br><br><br><br>Grading Breakdown

<br>35% Assignments: Bi-weekly assignments focusing on module topics.
<br>25% Final Project: Integration of course concepts into a cohesive artifact.
<br>25% Participation and Professionalism: Engagement, attendance, and critique contributions.
<br>15% Weekly Quizzes: Short assessments via Drexel Learn to reinforce key concepts.

<br><br><br><br>Classroom Activities
In order to foster a more optimal learning environment and ensure respect for all participants, the following policy is in effect during lectures, live-coding, and both guest and student presentations:<br>
- No personal electronic devices: Cell phones, tablets, laptops, and other devices must be turned off and put away unless explicitly permitted for note-taking or learning activity use.<br>
- No non-course-related activities: Gaming, video watching, social media use, or any other non-course-related activities are strictly prohibited.<br>
- Acceptable learning activities: Note-taking (electronic or handwritten) and productive doodling/drawing related to course content are permitted and encouraged.<br>
- Lab sessions: During hands-on lab portions, device use is allowed for course-related work, peer discussions, and instructor engagement.
<br>Affects Participation + Professionalism
Violations of this policy will impact the Participation and Professionalism grade. Multiple offenses may result in a zero (0) for this component of the course grade, without exception.
<br><br>Cheating and Plagiarism Definitions
Cheating or plagiarism, as defined for this course, are governed by the Drexel University Academic Integrity Policy.<br>
Both are strictly forbidden. DO NOT DO IT!<br>
All instances will be investigated and reported as outlined by Drexel University policy.<br>
They will also result in: at minimum failing the assignment and an automatic decrease&nbsp;of one letter grade for your final grade and may result in your failing the course.
<br><br>Submission Rules

<br>Submit all work via Drexel Learn (unless other wise specified).
<br>Follow assignment submission guidelines outlined in briefs
<br>Use proper file naming conventions (e.g., abc123_a1_lighting_final.mp4).

<br><br>Late Assignmnets
Assignments must be turned in on time!<br>
Lateness will automatically result in at&nbsp;minimum the loss of one letter grade.<br>
Late work incurs a 10% penalty per day.
<br><br>Attendance Requirements

<br>Attendance is mandatory. 
<br>Students are allowed one unexcused absence.
<br>Missing more than one class (unexcused) reduces your grade.
<br>Each late arrival to class will result in 50% attendance for the day.

<br>Excused Abcense
Note that an excused absence is defined as one that is the result of a condition or&nbsp;circumstance beyond the student's control, such as illness, a family crisis or&nbsp;emergency, or some other serious and important personal circumstance.
<br>Three or more absences results in course failure.<br><br>AI Use Policy
Artificial intelligence (AI) tools, such as large language models (e.g., ChatGPT or Claude), may be used in this course under specific guidelines, outlined below.
<br>Approved AI Uses

<br>AI tools are permitted for developing assets for assignments and projects, such as generating images or code snippets.
<br>Students may use AI to help better contextualize and understand code, programming concepts, and course structures. This includes using AI for code review, breakdowns, and topic summaries.
<br>All written materials, explanations, and analyses submitted for assignments should be the original work of the student. AI should not be used to generate these portions of your submissions.

<br>Use and Citation
The use of AI tools is not mandatory. Students may opt out of using AI assistants entirely if they prefer to complete all work without AI assistance.<br>
When AI tools are used, students must clearly indicate which portions of their work were created with AI assistance and which tools were used.
<br>Use and Understanding
Regardless of AI usage, students are responsible for understanding and being able to explain all aspects of their submitted work.
<br><br>Course Changes to the Course
It is very important that each student has read and understood all the materials,&nbsp;assignments, and due dates on the syllabus. It is the prerogative of the instructor to change the course during the term at their discretion in the interest of&nbsp;responding to individual class needs. Changes will be communicated to students via Drexel Learn and/or email
<br><br><br>This course, including all meetings, assignments, and activities, operates under Drexel University’s policies. All students are expected to read and fully understand these policies as they apply to the coursework and conduct within this class.<br><br>Plagiarism and Cheating Policy

<br>Plagiarism or cheating will result in a failing grade for the assignment and potential course failure and further academic discipline.

<br><br><br><br><br><br><br><br><br><br>Instructor Notes: Some smaller incremental updates or changes to the syllabus may not result in a notification via Drexel Learn or email.<br> <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">Return to the Course Main Page</a>]]></description><link>gmap-395\gmap-395-syllabus.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - Syllabus.md</guid><pubDate>Tue, 14 Jan 2025 00:30:33 GMT</pubDate></item><item><title><![CDATA[Welcome to GMAP 395!]]></title><description><![CDATA[ 
 <br><br>About the Course
GMAP 395, Advanced Game Art and Production, is an undergraduate-level course focusing on concepts and techniques related to technical art for games. 
Dive into real-time systems and game engine workflows with topics like:

<br>Shaders: Mastering visual effects and materials.
<br>Procedural Modeling: Automating asset creation.
<br>Lighting Systems: Enhancing mood and realism.
<br>Camera Effects: Dynamic cameras and post-processing.

Whether you're aiming to focus on creating visually stunning worlds or procedural game systems, this course equips you with the tools to succeed.
<br><br><br><br><br><br><br>
<br>Instructor: Darren Woodland, Jr.  
<br>Office Hours (by appointment): <a data-tooltip-position="top" aria-label="https://outlook.office.com/bookwithme/user/8a28cf456da9442e97dda421b09a3af0@drexel.edu/meetingtype/MWYxQdbZA0mCye-WJGVcQw2?anonymous&amp;ep=mCardFromTile" rel="noopener nofollow" class="external-link" href="https://outlook.office.com/bookwithme/user/8a28cf456da9442e97dda421b09a3af0@drexel.edu/meetingtype/MWYxQdbZA0mCye-WJGVcQw2?anonymous&amp;ep=mCardFromTile" target="_blank">Microsoft Bookings</a> or email.
<br><br><br>For questions or concerns, feel free to reach out:  <br>
<br>Email: <a data-tooltip-position="top" aria-label="mailto:dkw34@drexel.edu" rel="noopener nofollow" class="external-link" href="mailto:dkw34@drexel.edu" target="_blank">dkw34@drexel.edu</a>
<br>Discord: tromboctopus
<br><br><br><br>
<br>Overview of games, design, and play
<br>Introduction to technical art for games
<br>Introduction to procedural and modular workflows
<br><br>
<br>Overview of procedural modeling
<br>Introduction to node-based workflows for modeling
<br>Introduction to real-time lighting systems
<br><br>
<br>Creating custom shaders
<br>Understanding lighting interactions
<br>Stylized vs. photorealistic materials
<br><br>
<br>Introduction to particle systems
<br>Procedural and modular design with particles
<br>Applications and feedback
<br><br>
<br>Full-screen effects and post processing
<br>Modular camera systems and applications
<br>Camera effects and real-time feedback
<br><br>
<br>A cohesive real-time scene incorporating procedural assets, shaders, VFX, lighting, and post-processing.
<br><br><br>Recommended Software

<br>Unity: <a data-tooltip-position="top" aria-label="https://unity.com/download" rel="noopener nofollow" class="external-link" href="https://unity.com/download" target="_blank">Download Link</a>
<br>Blender: <a data-tooltip-position="top" aria-label="https://www.blender.org/download/" rel="noopener nofollow" class="external-link" href="https://www.blender.org/download/" target="_blank">Download Link</a>
<br>Visual Studio Code: <a data-tooltip-position="top" aria-label="https://code.visualstudio.com/" rel="noopener nofollow" class="external-link" href="https://code.visualstudio.com/" target="_blank">Download Link</a>

<br><br><br>"Learn to merge art with technology in innovative ways."
By the end of this course, you'll:

<br>Build visually compelling and efficient game environments.
<br>Understand the interplay of art and programming.
<br>Gain a portfolio-ready project demonstrating your technical art skills.

<br><br>]]></description><link>gmap-395\gmap-395-welcome.html</link><guid isPermaLink="false">GMAP 395/GMAP 395 - Welcome.md</guid><pubDate>Mon, 27 Jan 2025 16:31:06 GMT</pubDate></item><item><title><![CDATA[🐲 Drexel Courses List]]></title><description><![CDATA[ 
 <br><br>About This Page
Welcome to the landing page for the courses I teach! This includes courses from both:

<br>🎥 DIGM (Digital Media)  
<br>🎮 GMAP (Game Art and Production)  

Explore the courses below to find detailed content, assignments, and resources.
<br><br><br><br>🤖 <a data-tooltip-position="top" aria-label="GMAP 395 - Welcome" data-href="GMAP 395 - Welcome" href="gmap-395\gmap-395-welcome.html" class="internal-link" target="_self" rel="noopener nofollow">GMAP 395</a>: Advanced Game Art and Production<br>
Technical art for games: shaders, procedural modeling, lighting systems, and real-time workflows.<br>🛠️ GMAP 345: Game Development Foundations <br>📜 GMAP 231: Scripting for Game Design  <br><br><br>📜 GMAP 131: Introduction to Scripting for the Digital Content Creation Pipeline<br>
Scripting fundamentals for automating workflows, optimizing pipelines, and enhancing digital content creation processes.<br><br><br>
🧠 Expand Your Skills: Learn techniques in digital media and game production.<br>
🎯 Build Your Portfolio: Create projects that can stand out in a portfolio.<br>
🌐 Collaborate and Innovate: Work with peers to tackle creative challenges.
<br><br>Use the links above to jump directly to the course materials, assignments, and other resources for each course.<br><br>]]></description><link>index.html</link><guid isPermaLink="false">Index.md</guid><pubDate>Sun, 05 Jan 2025 19:46:34 GMT</pubDate></item></channel></rss>